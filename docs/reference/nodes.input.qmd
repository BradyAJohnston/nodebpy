# nodes.input { #nodebpy.nodes.input }

`nodes.input`



## Classes

| Name | Description |
| --- | --- |
| [ActiveCamera](#nodebpy.nodes.input.ActiveCamera) | Retrieve the scene's active camera |
| [ActiveElement](#nodebpy.nodes.input.ActiveElement) | Active element indices of the edited geometry, for tool execution |
| [Boolean](#nodebpy.nodes.input.Boolean) | Provide a True/False value that can be connected to other nodes in the tree |
| [CameraInfo](#nodebpy.nodes.input.CameraInfo) | Retrieve information from a camera object |
| [Collection](#nodebpy.nodes.input.Collection) | Output a single collection |
| [CollectionInfo](#nodebpy.nodes.input.CollectionInfo) | Retrieve geometry instances from a collection |
| [Color](#nodebpy.nodes.input.Color) | Output a color value chosen with the color picker widget |
| [CornersOfEdge](#nodebpy.nodes.input.CornersOfEdge) | Retrieve face corners connected to edges |
| [CornersOfFace](#nodebpy.nodes.input.CornersOfFace) | Retrieve corners that make up a face |
| [CornersOfVertex](#nodebpy.nodes.input.CornersOfVertex) | Retrieve face corners connected to vertices |
| [Cursor3D](#nodebpy.nodes.input.Cursor3D) | The scene's 3D cursor location and rotation |
| [CurveHandlePositions](#nodebpy.nodes.input.CurveHandlePositions) | Retrieve the position of each Bézier control point's handles |
| [CurveOfPoint](#nodebpy.nodes.input.CurveOfPoint) | Retrieve the curve a control point is part of |
| [CurveTangent](#nodebpy.nodes.input.CurveTangent) | Retrieve the direction of curves at each control point |
| [CurveTilt](#nodebpy.nodes.input.CurveTilt) | Retrieve the angle at each control point used to twist the curve's normal around its tangent |
| [EdgeAngle](#nodebpy.nodes.input.EdgeAngle) | The angle between the normals of connected manifold faces |
| [EdgeNeighbors](#nodebpy.nodes.input.EdgeNeighbors) | Retrieve the number of faces that use each edge as one of their sides |
| [EdgePathsToSelection](#nodebpy.nodes.input.EdgePathsToSelection) | Output a selection of edges by following paths across mesh edges |
| [EdgeVertices](#nodebpy.nodes.input.EdgeVertices) | Retrieve topology information relating to each edge of a mesh |
| [EdgesOfCorner](#nodebpy.nodes.input.EdgesOfCorner) | Retrieve the edges on both sides of a face corner |
| [EdgesOfVertex](#nodebpy.nodes.input.EdgesOfVertex) | Retrieve the edges connected to each vertex |
| [EdgesToFaceGroups](#nodebpy.nodes.input.EdgesToFaceGroups) | Group faces into regions surrounded by the selected boundary edges |
| [EndpointSelection](#nodebpy.nodes.input.EndpointSelection) | Provide a selection for an arbitrary number of endpoints in each spline |
| [FaceArea](#nodebpy.nodes.input.FaceArea) | Calculate the surface area of a mesh's faces |
| [FaceGroupBoundaries](#nodebpy.nodes.input.FaceGroupBoundaries) | Find edges on the boundaries between groups of faces with the same ID value |
| [FaceNeighbors](#nodebpy.nodes.input.FaceNeighbors) | Retrieve topology information relating to each face of a mesh |
| [FaceOfCorner](#nodebpy.nodes.input.FaceOfCorner) | Retrieve the face each face corner is part of |
| [FaceSet](#nodebpy.nodes.input.FaceSet) | Each face's sculpt face set value |
| [ID](#nodebpy.nodes.input.ID) | Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist |
| [Image](#nodebpy.nodes.input.Image) | Input an image data-block |
| [ImageInfo](#nodebpy.nodes.input.ImageInfo) | Retrieve information about an image |
| [ImportCSV](#nodebpy.nodes.input.ImportCSV) | Import geometry from an CSV file |
| [ImportOBJ](#nodebpy.nodes.input.ImportOBJ) | Import geometry from an OBJ file |
| [ImportPLY](#nodebpy.nodes.input.ImportPLY) | Import a point cloud from a PLY file |
| [ImportSTL](#nodebpy.nodes.input.ImportSTL) | Import a mesh from an STL file |
| [ImportText](#nodebpy.nodes.input.ImportText) | Import a string from a text file |
| [ImportVDB](#nodebpy.nodes.input.ImportVDB) | Import volume data from a .vdb file |
| [Index](#nodebpy.nodes.input.Index) | Retrieve an integer value indicating the position of each element in the list, starting at zero |
| [InstanceBounds](#nodebpy.nodes.input.InstanceBounds) | Calculate position bounds of each instance's geometry set |
| [InstanceRotation](#nodebpy.nodes.input.InstanceRotation) | Retrieve the rotation of each instance in the geometry |
| [InstanceScale](#nodebpy.nodes.input.InstanceScale) | Retrieve the scale of each instance in the geometry |
| [InstanceTransform](#nodebpy.nodes.input.InstanceTransform) | Retrieve the full transformation of each instance in the geometry |
| [Integer](#nodebpy.nodes.input.Integer) | Provide an integer value that can be connected to other nodes in the tree |
| [IsEdgeSmooth](#nodebpy.nodes.input.IsEdgeSmooth) | Retrieve whether each edge is marked for smooth or split normals |
| [IsFacePlanar](#nodebpy.nodes.input.IsFacePlanar) | Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal |
| [IsFaceSmooth](#nodebpy.nodes.input.IsFaceSmooth) | Retrieve whether each face is marked for smooth or sharp normals |
| [IsSplineCyclic](#nodebpy.nodes.input.IsSplineCyclic) | Retrieve whether each spline endpoint connects to the beginning |
| [IsViewport](#nodebpy.nodes.input.IsViewport) | Retrieve whether the nodes are being evaluated for the viewport rather than the final render |
| [Material](#nodebpy.nodes.input.Material) | Output a single material |
| [MaterialIndex](#nodebpy.nodes.input.MaterialIndex) | Retrieve the index of the material used for each element in the geometry's list of materials |
| [MeshIsland](#nodebpy.nodes.input.MeshIsland) | Retrieve information about separate connected regions in a mesh |
| [MousePosition](#nodebpy.nodes.input.MousePosition) | Retrieve the position of the mouse cursor |
| [NamedAttribute](#nodebpy.nodes.input.NamedAttribute) | Retrieve the data of a specified attribute |
| [NamedLayerSelection](#nodebpy.nodes.input.NamedLayerSelection) | Output a selection of a Grease Pencil layer |
| [Normal](#nodebpy.nodes.input.Normal) | Retrieve a unit length vector indicating the direction pointing away from the geometry at each element |
| [Object](#nodebpy.nodes.input.Object) | Output a single object |
| [ObjectInfo](#nodebpy.nodes.input.ObjectInfo) | Retrieve information from an object |
| [OffsetCornerInFace](#nodebpy.nodes.input.OffsetCornerInFace) | Retrieve corners in the same face as another |
| [OffsetPointInCurve](#nodebpy.nodes.input.OffsetPointInCurve) | Offset a control point index within its curve |
| [PointsOfCurve](#nodebpy.nodes.input.PointsOfCurve) | Retrieve a point index within a curve |
| [Position](#nodebpy.nodes.input.Position) | Retrieve a vector indicating the location of each element |
| [Radius](#nodebpy.nodes.input.Radius) | Retrieve the radius at each point on curve or point cloud geometry |
| [Rotation](#nodebpy.nodes.input.Rotation) | Provide a rotation value that can be connected to other nodes in the tree |
| [SceneTime](#nodebpy.nodes.input.SceneTime) | Retrieve the current time in the scene's animation in units of seconds or frames |
| [Selection](#nodebpy.nodes.input.Selection) | User selection of the edited geometry, for tool execution |
| [SelfObject](#nodebpy.nodes.input.SelfObject) | Retrieve the object that contains the geometry nodes modifier currently being executed |
| [ShortestEdgePaths](#nodebpy.nodes.input.ShortestEdgePaths) | Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge |
| [SpecialCharacters](#nodebpy.nodes.input.SpecialCharacters) | Output string characters that cannot be typed directly with the keyboard |
| [SplineLength](#nodebpy.nodes.input.SplineLength) | Retrieve the total length of each spline, as a distance or as a number of points |
| [SplineParameter](#nodebpy.nodes.input.SplineParameter) | Retrieve how far along each spline a control point is |
| [SplineResolution](#nodebpy.nodes.input.SplineResolution) | Retrieve the number of evaluated points that will be generated for every control point on curves |
| [String](#nodebpy.nodes.input.String) | Provide a string value that can be connected to other nodes in the tree |
| [UVTangent](#nodebpy.nodes.input.UVTangent) | Generate tangent directions based on a UV map |
| [Vector](#nodebpy.nodes.input.Vector) | Provide a vector value that can be connected to other nodes in the tree |
| [VertexNeighbors](#nodebpy.nodes.input.VertexNeighbors) | Retrieve topology information relating to each vertex of a mesh |
| [VertexOfCorner](#nodebpy.nodes.input.VertexOfCorner) | Retrieve the vertex each face corner is attached to |
| [ViewportTransform](#nodebpy.nodes.input.ViewportTransform) | Retrieve the view direction and location of the 3D viewport |
| [VoxelIndex](#nodebpy.nodes.input.VoxelIndex) | Retrieve the integer coordinates of the voxel that the field is evaluated on |

### ActiveCamera { #nodebpy.nodes.input.ActiveCamera }

```python
nodes.input.ActiveCamera()
```

Retrieve the scene's active camera

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.ActiveCamera.name) |  |
| [node](#nodebpy.nodes.input.ActiveCamera.node) |  |
| [o_active_camera](#nodebpy.nodes.input.ActiveCamera.o_active_camera) | Output socket: Active Camera |
| [tree](#nodebpy.nodes.input.ActiveCamera.tree) |  |
| [type](#nodebpy.nodes.input.ActiveCamera.type) |  |

### ActiveElement { #nodebpy.nodes.input.ActiveElement }

```python
nodes.input.ActiveElement(domain='POINT')
```

Active element indices of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.input.ActiveElement.domain) |  |
| [name](#nodebpy.nodes.input.ActiveElement.name) |  |
| [node](#nodebpy.nodes.input.ActiveElement.node) |  |
| [o_exists](#nodebpy.nodes.input.ActiveElement.o_exists) | Output socket: Exists |
| [o_index](#nodebpy.nodes.input.ActiveElement.o_index) | Output socket: Index |
| [tree](#nodebpy.nodes.input.ActiveElement.tree) |  |
| [type](#nodebpy.nodes.input.ActiveElement.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.input.ActiveElement.edge) | Create Active Element with operation 'Edge'. |
| [face](#nodebpy.nodes.input.ActiveElement.face) | Create Active Element with operation 'Face'. |
| [layer](#nodebpy.nodes.input.ActiveElement.layer) | Create Active Element with operation 'Layer'. |
| [point](#nodebpy.nodes.input.ActiveElement.point) | Create Active Element with operation 'Point'. |

##### edge { #nodebpy.nodes.input.ActiveElement.edge }

```python
nodes.input.ActiveElement.edge()
```

Create Active Element with operation 'Edge'.

##### face { #nodebpy.nodes.input.ActiveElement.face }

```python
nodes.input.ActiveElement.face()
```

Create Active Element with operation 'Face'.

##### layer { #nodebpy.nodes.input.ActiveElement.layer }

```python
nodes.input.ActiveElement.layer()
```

Create Active Element with operation 'Layer'.

##### point { #nodebpy.nodes.input.ActiveElement.point }

```python
nodes.input.ActiveElement.point()
```

Create Active Element with operation 'Point'.

### Boolean { #nodebpy.nodes.input.Boolean }

```python
nodes.input.Boolean(boolean=False)
```

Provide a True/False value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.input.Boolean.boolean) |  |
| [name](#nodebpy.nodes.input.Boolean.name) |  |
| [node](#nodebpy.nodes.input.Boolean.node) |  |
| [o_boolean](#nodebpy.nodes.input.Boolean.o_boolean) | Output socket: Boolean |
| [tree](#nodebpy.nodes.input.Boolean.tree) |  |
| [type](#nodebpy.nodes.input.Boolean.type) |  |

### CameraInfo { #nodebpy.nodes.input.CameraInfo }

```python
nodes.input.CameraInfo(camera=None)
```

Retrieve information from a camera object

#### Attributes

| Name | Description |
| --- | --- |
| [i_camera](#nodebpy.nodes.input.CameraInfo.i_camera) | Input socket: Camera |
| [name](#nodebpy.nodes.input.CameraInfo.name) |  |
| [node](#nodebpy.nodes.input.CameraInfo.node) |  |
| [o_clip_end](#nodebpy.nodes.input.CameraInfo.o_clip_end) | Output socket: Clip End |
| [o_clip_start](#nodebpy.nodes.input.CameraInfo.o_clip_start) | Output socket: Clip Start |
| [o_focal_length](#nodebpy.nodes.input.CameraInfo.o_focal_length) | Output socket: Focal Length |
| [o_focus_distance](#nodebpy.nodes.input.CameraInfo.o_focus_distance) | Output socket: Focus Distance |
| [o_is_orthographic](#nodebpy.nodes.input.CameraInfo.o_is_orthographic) | Output socket: Is Orthographic |
| [o_orthographic_scale](#nodebpy.nodes.input.CameraInfo.o_orthographic_scale) | Output socket: Orthographic Scale |
| [o_projection_matrix](#nodebpy.nodes.input.CameraInfo.o_projection_matrix) | Output socket: Projection Matrix |
| [o_sensor](#nodebpy.nodes.input.CameraInfo.o_sensor) | Output socket: Sensor |
| [o_shift](#nodebpy.nodes.input.CameraInfo.o_shift) | Output socket: Shift |
| [tree](#nodebpy.nodes.input.CameraInfo.tree) |  |
| [type](#nodebpy.nodes.input.CameraInfo.type) |  |

### Collection { #nodebpy.nodes.input.Collection }

```python
nodes.input.Collection()
```

Output a single collection

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Collection.name) |  |
| [node](#nodebpy.nodes.input.Collection.node) |  |
| [o_collection](#nodebpy.nodes.input.Collection.o_collection) | Output socket: Collection |
| [tree](#nodebpy.nodes.input.Collection.tree) |  |
| [type](#nodebpy.nodes.input.Collection.type) |  |

### CollectionInfo { #nodebpy.nodes.input.CollectionInfo }

```python
nodes.input.CollectionInfo(
    collection=None,
    separate_children=False,
    reset_children=False,
    *,
    transform_space='ORIGINAL',
)
```

Retrieve geometry instances from a collection

#### Attributes

| Name | Description |
| --- | --- |
| [i_collection](#nodebpy.nodes.input.CollectionInfo.i_collection) | Input socket: Collection |
| [i_reset_children](#nodebpy.nodes.input.CollectionInfo.i_reset_children) | Input socket: Reset Children |
| [i_separate_children](#nodebpy.nodes.input.CollectionInfo.i_separate_children) | Input socket: Separate Children |
| [name](#nodebpy.nodes.input.CollectionInfo.name) |  |
| [node](#nodebpy.nodes.input.CollectionInfo.node) |  |
| [o_instances](#nodebpy.nodes.input.CollectionInfo.o_instances) | Output socket: Instances |
| [transform_space](#nodebpy.nodes.input.CollectionInfo.transform_space) |  |
| [tree](#nodebpy.nodes.input.CollectionInfo.tree) |  |
| [type](#nodebpy.nodes.input.CollectionInfo.type) |  |

### Color { #nodebpy.nodes.input.Color }

```python
nodes.input.Color(value=(0.735, 0.735, 0.735, 1.0))
```

Output a color value chosen with the color picker widget

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Color.name) |  |
| [node](#nodebpy.nodes.input.Color.node) |  |
| [o_color](#nodebpy.nodes.input.Color.o_color) | Output socket: Color |
| [tree](#nodebpy.nodes.input.Color.tree) |  |
| [type](#nodebpy.nodes.input.Color.type) |  |
| [value](#nodebpy.nodes.input.Color.value) |  |

### CornersOfEdge { #nodebpy.nodes.input.CornersOfEdge }

```python
nodes.input.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0)
```

Retrieve face corners connected to edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_index](#nodebpy.nodes.input.CornersOfEdge.i_edge_index) | Input socket: Edge Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfEdge.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfEdge.i_weights) | Input socket: Weights |
| [name](#nodebpy.nodes.input.CornersOfEdge.name) |  |
| [node](#nodebpy.nodes.input.CornersOfEdge.node) |  |
| [o_corner_index](#nodebpy.nodes.input.CornersOfEdge.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfEdge.o_total) | Output socket: Total |
| [tree](#nodebpy.nodes.input.CornersOfEdge.tree) |  |
| [type](#nodebpy.nodes.input.CornersOfEdge.type) |  |

### CornersOfFace { #nodebpy.nodes.input.CornersOfFace }

```python
nodes.input.CornersOfFace(face_index=0, weights=0.0, sort_index=0)
```

Retrieve corners that make up a face

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_index](#nodebpy.nodes.input.CornersOfFace.i_face_index) | Input socket: Face Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfFace.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfFace.i_weights) | Input socket: Weights |
| [name](#nodebpy.nodes.input.CornersOfFace.name) |  |
| [node](#nodebpy.nodes.input.CornersOfFace.node) |  |
| [o_corner_index](#nodebpy.nodes.input.CornersOfFace.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfFace.o_total) | Output socket: Total |
| [tree](#nodebpy.nodes.input.CornersOfFace.tree) |  |
| [type](#nodebpy.nodes.input.CornersOfFace.type) |  |

### CornersOfVertex { #nodebpy.nodes.input.CornersOfVertex }

```python
nodes.input.CornersOfVertex(vertex_index=0, weights=0.0, sort_index=0)
```

Retrieve face corners connected to vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.input.CornersOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.input.CornersOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.input.CornersOfVertex.i_weights) | Input socket: Weights |
| [name](#nodebpy.nodes.input.CornersOfVertex.name) |  |
| [node](#nodebpy.nodes.input.CornersOfVertex.node) |  |
| [o_corner_index](#nodebpy.nodes.input.CornersOfVertex.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfVertex.o_total) | Output socket: Total |
| [tree](#nodebpy.nodes.input.CornersOfVertex.tree) |  |
| [type](#nodebpy.nodes.input.CornersOfVertex.type) |  |

### Cursor3D { #nodebpy.nodes.input.Cursor3D }

```python
nodes.input.Cursor3D()
```

The scene's 3D cursor location and rotation

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Cursor3D.name) |  |
| [node](#nodebpy.nodes.input.Cursor3D.node) |  |
| [o_location](#nodebpy.nodes.input.Cursor3D.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.input.Cursor3D.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.input.Cursor3D.tree) |  |
| [type](#nodebpy.nodes.input.Cursor3D.type) |  |

### CurveHandlePositions { #nodebpy.nodes.input.CurveHandlePositions }

```python
nodes.input.CurveHandlePositions(relative=False)
```

Retrieve the position of each Bézier control point's handles

#### Attributes

| Name | Description |
| --- | --- |
| [i_relative](#nodebpy.nodes.input.CurveHandlePositions.i_relative) | Input socket: Relative |
| [name](#nodebpy.nodes.input.CurveHandlePositions.name) |  |
| [node](#nodebpy.nodes.input.CurveHandlePositions.node) |  |
| [o_left](#nodebpy.nodes.input.CurveHandlePositions.o_left) | Output socket: Left |
| [o_right](#nodebpy.nodes.input.CurveHandlePositions.o_right) | Output socket: Right |
| [tree](#nodebpy.nodes.input.CurveHandlePositions.tree) |  |
| [type](#nodebpy.nodes.input.CurveHandlePositions.type) |  |

### CurveOfPoint { #nodebpy.nodes.input.CurveOfPoint }

```python
nodes.input.CurveOfPoint(point_index=0)
```

Retrieve the curve a control point is part of

#### Attributes

| Name | Description |
| --- | --- |
| [i_point_index](#nodebpy.nodes.input.CurveOfPoint.i_point_index) | Input socket: Point Index |
| [name](#nodebpy.nodes.input.CurveOfPoint.name) |  |
| [node](#nodebpy.nodes.input.CurveOfPoint.node) |  |
| [o_curve_index](#nodebpy.nodes.input.CurveOfPoint.o_curve_index) | Output socket: Curve Index |
| [o_index_in_curve](#nodebpy.nodes.input.CurveOfPoint.o_index_in_curve) | Output socket: Index in Curve |
| [tree](#nodebpy.nodes.input.CurveOfPoint.tree) |  |
| [type](#nodebpy.nodes.input.CurveOfPoint.type) |  |

### CurveTangent { #nodebpy.nodes.input.CurveTangent }

```python
nodes.input.CurveTangent()
```

Retrieve the direction of curves at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.CurveTangent.name) |  |
| [node](#nodebpy.nodes.input.CurveTangent.node) |  |
| [o_tangent](#nodebpy.nodes.input.CurveTangent.o_tangent) | Output socket: Tangent |
| [tree](#nodebpy.nodes.input.CurveTangent.tree) |  |
| [type](#nodebpy.nodes.input.CurveTangent.type) |  |

### CurveTilt { #nodebpy.nodes.input.CurveTilt }

```python
nodes.input.CurveTilt()
```

Retrieve the angle at each control point used to twist the curve's normal around its tangent

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.CurveTilt.name) |  |
| [node](#nodebpy.nodes.input.CurveTilt.node) |  |
| [o_tilt](#nodebpy.nodes.input.CurveTilt.o_tilt) | Output socket: Tilt |
| [tree](#nodebpy.nodes.input.CurveTilt.tree) |  |
| [type](#nodebpy.nodes.input.CurveTilt.type) |  |

### EdgeAngle { #nodebpy.nodes.input.EdgeAngle }

```python
nodes.input.EdgeAngle()
```

The angle between the normals of connected manifold faces

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.EdgeAngle.name) |  |
| [node](#nodebpy.nodes.input.EdgeAngle.node) |  |
| [o_signed_angle](#nodebpy.nodes.input.EdgeAngle.o_signed_angle) | Output socket: Signed Angle |
| [o_unsigned_angle](#nodebpy.nodes.input.EdgeAngle.o_unsigned_angle) | Output socket: Unsigned Angle |
| [tree](#nodebpy.nodes.input.EdgeAngle.tree) |  |
| [type](#nodebpy.nodes.input.EdgeAngle.type) |  |

### EdgeNeighbors { #nodebpy.nodes.input.EdgeNeighbors }

```python
nodes.input.EdgeNeighbors()
```

Retrieve the number of faces that use each edge as one of their sides

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.EdgeNeighbors.name) |  |
| [node](#nodebpy.nodes.input.EdgeNeighbors.node) |  |
| [o_face_count](#nodebpy.nodes.input.EdgeNeighbors.o_face_count) | Output socket: Face Count |
| [tree](#nodebpy.nodes.input.EdgeNeighbors.tree) |  |
| [type](#nodebpy.nodes.input.EdgeNeighbors.type) |  |

### EdgePathsToSelection { #nodebpy.nodes.input.EdgePathsToSelection }

```python
nodes.input.EdgePathsToSelection(start_vertices=True, next_vertex_index=-1)
```

Output a selection of edges by following paths across mesh edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_next_vertex_index](#nodebpy.nodes.input.EdgePathsToSelection.i_next_vertex_index) | Input socket: Next Vertex Index |
| [i_start_vertices](#nodebpy.nodes.input.EdgePathsToSelection.i_start_vertices) | Input socket: Start Vertices |
| [name](#nodebpy.nodes.input.EdgePathsToSelection.name) |  |
| [node](#nodebpy.nodes.input.EdgePathsToSelection.node) |  |
| [o_selection](#nodebpy.nodes.input.EdgePathsToSelection.o_selection) | Output socket: Selection |
| [tree](#nodebpy.nodes.input.EdgePathsToSelection.tree) |  |
| [type](#nodebpy.nodes.input.EdgePathsToSelection.type) |  |

### EdgeVertices { #nodebpy.nodes.input.EdgeVertices }

```python
nodes.input.EdgeVertices()
```

Retrieve topology information relating to each edge of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.EdgeVertices.name) |  |
| [node](#nodebpy.nodes.input.EdgeVertices.node) |  |
| [o_position_1](#nodebpy.nodes.input.EdgeVertices.o_position_1) | Output socket: Position 1 |
| [o_position_2](#nodebpy.nodes.input.EdgeVertices.o_position_2) | Output socket: Position 2 |
| [o_vertex_index_1](#nodebpy.nodes.input.EdgeVertices.o_vertex_index_1) | Output socket: Vertex Index 1 |
| [o_vertex_index_2](#nodebpy.nodes.input.EdgeVertices.o_vertex_index_2) | Output socket: Vertex Index 2 |
| [tree](#nodebpy.nodes.input.EdgeVertices.tree) |  |
| [type](#nodebpy.nodes.input.EdgeVertices.type) |  |

### EdgesOfCorner { #nodebpy.nodes.input.EdgesOfCorner }

```python
nodes.input.EdgesOfCorner(corner_index=0)
```

Retrieve the edges on both sides of a face corner

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.EdgesOfCorner.i_corner_index) | Input socket: Corner Index |
| [name](#nodebpy.nodes.input.EdgesOfCorner.name) |  |
| [node](#nodebpy.nodes.input.EdgesOfCorner.node) |  |
| [o_next_edge_index](#nodebpy.nodes.input.EdgesOfCorner.o_next_edge_index) | Output socket: Next Edge Index |
| [o_previous_edge_index](#nodebpy.nodes.input.EdgesOfCorner.o_previous_edge_index) | Output socket: Previous Edge Index |
| [tree](#nodebpy.nodes.input.EdgesOfCorner.tree) |  |
| [type](#nodebpy.nodes.input.EdgesOfCorner.type) |  |

### EdgesOfVertex { #nodebpy.nodes.input.EdgesOfVertex }

```python
nodes.input.EdgesOfVertex(vertex_index=0, weights=0.0, sort_index=0)
```

Retrieve the edges connected to each vertex

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.input.EdgesOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.input.EdgesOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.input.EdgesOfVertex.i_weights) | Input socket: Weights |
| [name](#nodebpy.nodes.input.EdgesOfVertex.name) |  |
| [node](#nodebpy.nodes.input.EdgesOfVertex.node) |  |
| [o_edge_index](#nodebpy.nodes.input.EdgesOfVertex.o_edge_index) | Output socket: Edge Index |
| [o_total](#nodebpy.nodes.input.EdgesOfVertex.o_total) | Output socket: Total |
| [tree](#nodebpy.nodes.input.EdgesOfVertex.tree) |  |
| [type](#nodebpy.nodes.input.EdgesOfVertex.type) |  |

### EdgesToFaceGroups { #nodebpy.nodes.input.EdgesToFaceGroups }

```python
nodes.input.EdgesToFaceGroups(boundary_edges=True)
```

Group faces into regions surrounded by the selected boundary edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_boundary_edges](#nodebpy.nodes.input.EdgesToFaceGroups.i_boundary_edges) | Input socket: Boundary Edges |
| [name](#nodebpy.nodes.input.EdgesToFaceGroups.name) |  |
| [node](#nodebpy.nodes.input.EdgesToFaceGroups.node) |  |
| [o_face_group_id](#nodebpy.nodes.input.EdgesToFaceGroups.o_face_group_id) | Output socket: Face Group ID |
| [tree](#nodebpy.nodes.input.EdgesToFaceGroups.tree) |  |
| [type](#nodebpy.nodes.input.EdgesToFaceGroups.type) |  |

### EndpointSelection { #nodebpy.nodes.input.EndpointSelection }

```python
nodes.input.EndpointSelection(start_size=1, end_size=1)
```

Provide a selection for an arbitrary number of endpoints in each spline

#### Attributes

| Name | Description |
| --- | --- |
| [i_end_size](#nodebpy.nodes.input.EndpointSelection.i_end_size) | Input socket: End Size |
| [i_start_size](#nodebpy.nodes.input.EndpointSelection.i_start_size) | Input socket: Start Size |
| [name](#nodebpy.nodes.input.EndpointSelection.name) |  |
| [node](#nodebpy.nodes.input.EndpointSelection.node) |  |
| [o_selection](#nodebpy.nodes.input.EndpointSelection.o_selection) | Output socket: Selection |
| [tree](#nodebpy.nodes.input.EndpointSelection.tree) |  |
| [type](#nodebpy.nodes.input.EndpointSelection.type) |  |

### FaceArea { #nodebpy.nodes.input.FaceArea }

```python
nodes.input.FaceArea()
```

Calculate the surface area of a mesh's faces

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.FaceArea.name) |  |
| [node](#nodebpy.nodes.input.FaceArea.node) |  |
| [o_area](#nodebpy.nodes.input.FaceArea.o_area) | Output socket: Area |
| [tree](#nodebpy.nodes.input.FaceArea.tree) |  |
| [type](#nodebpy.nodes.input.FaceArea.type) |  |

### FaceGroupBoundaries { #nodebpy.nodes.input.FaceGroupBoundaries }

```python
nodes.input.FaceGroupBoundaries(face_set=0)
```

Find edges on the boundaries between groups of faces with the same ID value

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_set](#nodebpy.nodes.input.FaceGroupBoundaries.i_face_set) | Input socket: Face Group ID |
| [name](#nodebpy.nodes.input.FaceGroupBoundaries.name) |  |
| [node](#nodebpy.nodes.input.FaceGroupBoundaries.node) |  |
| [o_boundary_edges](#nodebpy.nodes.input.FaceGroupBoundaries.o_boundary_edges) | Output socket: Boundary Edges |
| [tree](#nodebpy.nodes.input.FaceGroupBoundaries.tree) |  |
| [type](#nodebpy.nodes.input.FaceGroupBoundaries.type) |  |

### FaceNeighbors { #nodebpy.nodes.input.FaceNeighbors }

```python
nodes.input.FaceNeighbors()
```

Retrieve topology information relating to each face of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.FaceNeighbors.name) |  |
| [node](#nodebpy.nodes.input.FaceNeighbors.node) |  |
| [o_face_count](#nodebpy.nodes.input.FaceNeighbors.o_face_count) | Output socket: Face Count |
| [o_vertex_count](#nodebpy.nodes.input.FaceNeighbors.o_vertex_count) | Output socket: Vertex Count |
| [tree](#nodebpy.nodes.input.FaceNeighbors.tree) |  |
| [type](#nodebpy.nodes.input.FaceNeighbors.type) |  |

### FaceOfCorner { #nodebpy.nodes.input.FaceOfCorner }

```python
nodes.input.FaceOfCorner(corner_index=0)
```

Retrieve the face each face corner is part of

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.FaceOfCorner.i_corner_index) | Input socket: Corner Index |
| [name](#nodebpy.nodes.input.FaceOfCorner.name) |  |
| [node](#nodebpy.nodes.input.FaceOfCorner.node) |  |
| [o_face_index](#nodebpy.nodes.input.FaceOfCorner.o_face_index) | Output socket: Face Index |
| [o_index_in_face](#nodebpy.nodes.input.FaceOfCorner.o_index_in_face) | Output socket: Index in Face |
| [tree](#nodebpy.nodes.input.FaceOfCorner.tree) |  |
| [type](#nodebpy.nodes.input.FaceOfCorner.type) |  |

### FaceSet { #nodebpy.nodes.input.FaceSet }

```python
nodes.input.FaceSet()
```

Each face's sculpt face set value

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.FaceSet.name) |  |
| [node](#nodebpy.nodes.input.FaceSet.node) |  |
| [o_exists](#nodebpy.nodes.input.FaceSet.o_exists) | Output socket: Exists |
| [o_face_set](#nodebpy.nodes.input.FaceSet.o_face_set) | Output socket: Face Set |
| [tree](#nodebpy.nodes.input.FaceSet.tree) |  |
| [type](#nodebpy.nodes.input.FaceSet.type) |  |

### ID { #nodebpy.nodes.input.ID }

```python
nodes.input.ID()
```

Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.ID.name) |  |
| [node](#nodebpy.nodes.input.ID.node) |  |
| [o_id](#nodebpy.nodes.input.ID.o_id) | Output socket: ID |
| [tree](#nodebpy.nodes.input.ID.tree) |  |
| [type](#nodebpy.nodes.input.ID.type) |  |

### Image { #nodebpy.nodes.input.Image }

```python
nodes.input.Image()
```

Input an image data-block

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Image.name) |  |
| [node](#nodebpy.nodes.input.Image.node) |  |
| [o_image](#nodebpy.nodes.input.Image.o_image) | Output socket: Image |
| [tree](#nodebpy.nodes.input.Image.tree) |  |
| [type](#nodebpy.nodes.input.Image.type) |  |

### ImageInfo { #nodebpy.nodes.input.ImageInfo }

```python
nodes.input.ImageInfo(image=None, frame=0)
```

Retrieve information about an image

#### Attributes

| Name | Description |
| --- | --- |
| [i_frame](#nodebpy.nodes.input.ImageInfo.i_frame) | Input socket: Frame |
| [i_image](#nodebpy.nodes.input.ImageInfo.i_image) | Input socket: Image |
| [name](#nodebpy.nodes.input.ImageInfo.name) |  |
| [node](#nodebpy.nodes.input.ImageInfo.node) |  |
| [o_fps](#nodebpy.nodes.input.ImageInfo.o_fps) | Output socket: FPS |
| [o_frame_count](#nodebpy.nodes.input.ImageInfo.o_frame_count) | Output socket: Frame Count |
| [o_has_alpha](#nodebpy.nodes.input.ImageInfo.o_has_alpha) | Output socket: Has Alpha |
| [o_height](#nodebpy.nodes.input.ImageInfo.o_height) | Output socket: Height |
| [o_width](#nodebpy.nodes.input.ImageInfo.o_width) | Output socket: Width |
| [tree](#nodebpy.nodes.input.ImageInfo.tree) |  |
| [type](#nodebpy.nodes.input.ImageInfo.type) |  |

### ImportCSV { #nodebpy.nodes.input.ImportCSV }

```python
nodes.input.ImportCSV(path='', delimiter=',')
```

Import geometry from an CSV file

#### Attributes

| Name | Description |
| --- | --- |
| [i_delimiter](#nodebpy.nodes.input.ImportCSV.i_delimiter) | Input socket: Delimiter |
| [i_path](#nodebpy.nodes.input.ImportCSV.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportCSV.name) |  |
| [node](#nodebpy.nodes.input.ImportCSV.node) |  |
| [o_point_cloud](#nodebpy.nodes.input.ImportCSV.o_point_cloud) | Output socket: Point Cloud |
| [tree](#nodebpy.nodes.input.ImportCSV.tree) |  |
| [type](#nodebpy.nodes.input.ImportCSV.type) |  |

### ImportOBJ { #nodebpy.nodes.input.ImportOBJ }

```python
nodes.input.ImportOBJ(path='')
```

Import geometry from an OBJ file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportOBJ.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportOBJ.name) |  |
| [node](#nodebpy.nodes.input.ImportOBJ.node) |  |
| [o_instances](#nodebpy.nodes.input.ImportOBJ.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.input.ImportOBJ.tree) |  |
| [type](#nodebpy.nodes.input.ImportOBJ.type) |  |

### ImportPLY { #nodebpy.nodes.input.ImportPLY }

```python
nodes.input.ImportPLY(path='')
```

Import a point cloud from a PLY file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportPLY.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportPLY.name) |  |
| [node](#nodebpy.nodes.input.ImportPLY.node) |  |
| [o_mesh](#nodebpy.nodes.input.ImportPLY.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.input.ImportPLY.tree) |  |
| [type](#nodebpy.nodes.input.ImportPLY.type) |  |

### ImportSTL { #nodebpy.nodes.input.ImportSTL }

```python
nodes.input.ImportSTL(path='')
```

Import a mesh from an STL file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportSTL.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportSTL.name) |  |
| [node](#nodebpy.nodes.input.ImportSTL.node) |  |
| [o_mesh](#nodebpy.nodes.input.ImportSTL.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.input.ImportSTL.tree) |  |
| [type](#nodebpy.nodes.input.ImportSTL.type) |  |

### ImportText { #nodebpy.nodes.input.ImportText }

```python
nodes.input.ImportText(path='')
```

Import a string from a text file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportText.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportText.name) |  |
| [node](#nodebpy.nodes.input.ImportText.node) |  |
| [o_string](#nodebpy.nodes.input.ImportText.o_string) | Output socket: String |
| [tree](#nodebpy.nodes.input.ImportText.tree) |  |
| [type](#nodebpy.nodes.input.ImportText.type) |  |

### ImportVDB { #nodebpy.nodes.input.ImportVDB }

```python
nodes.input.ImportVDB(path='')
```

Import volume data from a .vdb file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportVDB.i_path) | Input socket: Path |
| [name](#nodebpy.nodes.input.ImportVDB.name) |  |
| [node](#nodebpy.nodes.input.ImportVDB.node) |  |
| [o_volume](#nodebpy.nodes.input.ImportVDB.o_volume) | Output socket: Volume |
| [tree](#nodebpy.nodes.input.ImportVDB.tree) |  |
| [type](#nodebpy.nodes.input.ImportVDB.type) |  |

### Index { #nodebpy.nodes.input.Index }

```python
nodes.input.Index()
```

Retrieve an integer value indicating the position of each element in the list, starting at zero

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Index.name) |  |
| [node](#nodebpy.nodes.input.Index.node) |  |
| [o_index](#nodebpy.nodes.input.Index.o_index) | Output socket: Index |
| [tree](#nodebpy.nodes.input.Index.tree) |  |
| [type](#nodebpy.nodes.input.Index.type) |  |

### InstanceBounds { #nodebpy.nodes.input.InstanceBounds }

```python
nodes.input.InstanceBounds(use_radius=True)
```

Calculate position bounds of each instance's geometry set

#### Attributes

| Name | Description |
| --- | --- |
| [i_use_radius](#nodebpy.nodes.input.InstanceBounds.i_use_radius) | Input socket: Use Radius |
| [name](#nodebpy.nodes.input.InstanceBounds.name) |  |
| [node](#nodebpy.nodes.input.InstanceBounds.node) |  |
| [o_max](#nodebpy.nodes.input.InstanceBounds.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.input.InstanceBounds.o_min) | Output socket: Min |
| [tree](#nodebpy.nodes.input.InstanceBounds.tree) |  |
| [type](#nodebpy.nodes.input.InstanceBounds.type) |  |

### InstanceRotation { #nodebpy.nodes.input.InstanceRotation }

```python
nodes.input.InstanceRotation()
```

Retrieve the rotation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.InstanceRotation.name) |  |
| [node](#nodebpy.nodes.input.InstanceRotation.node) |  |
| [o_rotation](#nodebpy.nodes.input.InstanceRotation.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.input.InstanceRotation.tree) |  |
| [type](#nodebpy.nodes.input.InstanceRotation.type) |  |

### InstanceScale { #nodebpy.nodes.input.InstanceScale }

```python
nodes.input.InstanceScale()
```

Retrieve the scale of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.InstanceScale.name) |  |
| [node](#nodebpy.nodes.input.InstanceScale.node) |  |
| [o_scale](#nodebpy.nodes.input.InstanceScale.o_scale) | Output socket: Scale |
| [tree](#nodebpy.nodes.input.InstanceScale.tree) |  |
| [type](#nodebpy.nodes.input.InstanceScale.type) |  |

### InstanceTransform { #nodebpy.nodes.input.InstanceTransform }

```python
nodes.input.InstanceTransform()
```

Retrieve the full transformation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.InstanceTransform.name) |  |
| [node](#nodebpy.nodes.input.InstanceTransform.node) |  |
| [o_transform](#nodebpy.nodes.input.InstanceTransform.o_transform) | Output socket: Transform |
| [tree](#nodebpy.nodes.input.InstanceTransform.tree) |  |
| [type](#nodebpy.nodes.input.InstanceTransform.type) |  |

### Integer { #nodebpy.nodes.input.Integer }

```python
nodes.input.Integer(integer=1)
```

Provide an integer value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [integer](#nodebpy.nodes.input.Integer.integer) |  |
| [name](#nodebpy.nodes.input.Integer.name) |  |
| [node](#nodebpy.nodes.input.Integer.node) |  |
| [o_integer](#nodebpy.nodes.input.Integer.o_integer) | Output socket: Integer |
| [tree](#nodebpy.nodes.input.Integer.tree) |  |
| [type](#nodebpy.nodes.input.Integer.type) |  |

### IsEdgeSmooth { #nodebpy.nodes.input.IsEdgeSmooth }

```python
nodes.input.IsEdgeSmooth()
```

Retrieve whether each edge is marked for smooth or split normals

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.IsEdgeSmooth.name) |  |
| [node](#nodebpy.nodes.input.IsEdgeSmooth.node) |  |
| [o_smooth](#nodebpy.nodes.input.IsEdgeSmooth.o_smooth) | Output socket: Smooth |
| [tree](#nodebpy.nodes.input.IsEdgeSmooth.tree) |  |
| [type](#nodebpy.nodes.input.IsEdgeSmooth.type) |  |

### IsFacePlanar { #nodebpy.nodes.input.IsFacePlanar }

```python
nodes.input.IsFacePlanar(threshold=0.01)
```

Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal

#### Attributes

| Name | Description |
| --- | --- |
| [i_threshold](#nodebpy.nodes.input.IsFacePlanar.i_threshold) | Input socket: Threshold |
| [name](#nodebpy.nodes.input.IsFacePlanar.name) |  |
| [node](#nodebpy.nodes.input.IsFacePlanar.node) |  |
| [o_planar](#nodebpy.nodes.input.IsFacePlanar.o_planar) | Output socket: Planar |
| [tree](#nodebpy.nodes.input.IsFacePlanar.tree) |  |
| [type](#nodebpy.nodes.input.IsFacePlanar.type) |  |

### IsFaceSmooth { #nodebpy.nodes.input.IsFaceSmooth }

```python
nodes.input.IsFaceSmooth()
```

Retrieve whether each face is marked for smooth or sharp normals

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.IsFaceSmooth.name) |  |
| [node](#nodebpy.nodes.input.IsFaceSmooth.node) |  |
| [o_smooth](#nodebpy.nodes.input.IsFaceSmooth.o_smooth) | Output socket: Smooth |
| [tree](#nodebpy.nodes.input.IsFaceSmooth.tree) |  |
| [type](#nodebpy.nodes.input.IsFaceSmooth.type) |  |

### IsSplineCyclic { #nodebpy.nodes.input.IsSplineCyclic }

```python
nodes.input.IsSplineCyclic()
```

Retrieve whether each spline endpoint connects to the beginning

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.IsSplineCyclic.name) |  |
| [node](#nodebpy.nodes.input.IsSplineCyclic.node) |  |
| [o_cyclic](#nodebpy.nodes.input.IsSplineCyclic.o_cyclic) | Output socket: Cyclic |
| [tree](#nodebpy.nodes.input.IsSplineCyclic.tree) |  |
| [type](#nodebpy.nodes.input.IsSplineCyclic.type) |  |

### IsViewport { #nodebpy.nodes.input.IsViewport }

```python
nodes.input.IsViewport()
```

Retrieve whether the nodes are being evaluated for the viewport rather than the final render

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.IsViewport.name) |  |
| [node](#nodebpy.nodes.input.IsViewport.node) |  |
| [o_is_viewport](#nodebpy.nodes.input.IsViewport.o_is_viewport) | Output socket: Is Viewport |
| [tree](#nodebpy.nodes.input.IsViewport.tree) |  |
| [type](#nodebpy.nodes.input.IsViewport.type) |  |

### Material { #nodebpy.nodes.input.Material }

```python
nodes.input.Material()
```

Output a single material

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Material.name) |  |
| [node](#nodebpy.nodes.input.Material.node) |  |
| [o_material](#nodebpy.nodes.input.Material.o_material) | Output socket: Material |
| [tree](#nodebpy.nodes.input.Material.tree) |  |
| [type](#nodebpy.nodes.input.Material.type) |  |

### MaterialIndex { #nodebpy.nodes.input.MaterialIndex }

```python
nodes.input.MaterialIndex()
```

Retrieve the index of the material used for each element in the geometry's list of materials

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.MaterialIndex.name) |  |
| [node](#nodebpy.nodes.input.MaterialIndex.node) |  |
| [o_material_index](#nodebpy.nodes.input.MaterialIndex.o_material_index) | Output socket: Material Index |
| [tree](#nodebpy.nodes.input.MaterialIndex.tree) |  |
| [type](#nodebpy.nodes.input.MaterialIndex.type) |  |

### MeshIsland { #nodebpy.nodes.input.MeshIsland }

```python
nodes.input.MeshIsland()
```

Retrieve information about separate connected regions in a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.MeshIsland.name) |  |
| [node](#nodebpy.nodes.input.MeshIsland.node) |  |
| [o_island_count](#nodebpy.nodes.input.MeshIsland.o_island_count) | Output socket: Island Count |
| [o_island_index](#nodebpy.nodes.input.MeshIsland.o_island_index) | Output socket: Island Index |
| [tree](#nodebpy.nodes.input.MeshIsland.tree) |  |
| [type](#nodebpy.nodes.input.MeshIsland.type) |  |

### MousePosition { #nodebpy.nodes.input.MousePosition }

```python
nodes.input.MousePosition()
```

Retrieve the position of the mouse cursor

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.MousePosition.name) |  |
| [node](#nodebpy.nodes.input.MousePosition.node) |  |
| [o_mouse_x](#nodebpy.nodes.input.MousePosition.o_mouse_x) | Output socket: Mouse X |
| [o_mouse_y](#nodebpy.nodes.input.MousePosition.o_mouse_y) | Output socket: Mouse Y |
| [o_region_height](#nodebpy.nodes.input.MousePosition.o_region_height) | Output socket: Region Height |
| [o_region_width](#nodebpy.nodes.input.MousePosition.o_region_width) | Output socket: Region Width |
| [tree](#nodebpy.nodes.input.MousePosition.tree) |  |
| [type](#nodebpy.nodes.input.MousePosition.type) |  |

### NamedAttribute { #nodebpy.nodes.input.NamedAttribute }

```python
nodes.input.NamedAttribute(name='', *, data_type='FLOAT')
```

Retrieve the data of a specified attribute

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.input.NamedAttribute.data_type) |  |
| [i_name](#nodebpy.nodes.input.NamedAttribute.i_name) | Input socket: Name |
| [name](#nodebpy.nodes.input.NamedAttribute.name) |  |
| [node](#nodebpy.nodes.input.NamedAttribute.node) |  |
| [o_attribute](#nodebpy.nodes.input.NamedAttribute.o_attribute) | Output socket: Attribute |
| [o_exists](#nodebpy.nodes.input.NamedAttribute.o_exists) | Output socket: Exists |
| [tree](#nodebpy.nodes.input.NamedAttribute.tree) |  |
| [type](#nodebpy.nodes.input.NamedAttribute.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.input.NamedAttribute.boolean) | Create Named Attribute with operation 'Boolean'. |
| [color](#nodebpy.nodes.input.NamedAttribute.color) | Create Named Attribute with operation 'Color'. |
| [float](#nodebpy.nodes.input.NamedAttribute.float) | Create Named Attribute with operation 'Float'. |
| [integer](#nodebpy.nodes.input.NamedAttribute.integer) | Create Named Attribute with operation 'Integer'. |
| [matrix](#nodebpy.nodes.input.NamedAttribute.matrix) | Create Named Attribute with operation '4x4 Matrix'. |
| [quaternion](#nodebpy.nodes.input.NamedAttribute.quaternion) | Create Named Attribute with operation 'Quaternion'. |
| [vector](#nodebpy.nodes.input.NamedAttribute.vector) | Create Named Attribute with operation 'Vector'. |

##### boolean { #nodebpy.nodes.input.NamedAttribute.boolean }

```python
nodes.input.NamedAttribute.boolean(name='')
```

Create Named Attribute with operation 'Boolean'.

##### color { #nodebpy.nodes.input.NamedAttribute.color }

```python
nodes.input.NamedAttribute.color(name='')
```

Create Named Attribute with operation 'Color'.

##### float { #nodebpy.nodes.input.NamedAttribute.float }

```python
nodes.input.NamedAttribute.float(name='')
```

Create Named Attribute with operation 'Float'.

##### integer { #nodebpy.nodes.input.NamedAttribute.integer }

```python
nodes.input.NamedAttribute.integer(name='')
```

Create Named Attribute with operation 'Integer'.

##### matrix { #nodebpy.nodes.input.NamedAttribute.matrix }

```python
nodes.input.NamedAttribute.matrix(name='')
```

Create Named Attribute with operation '4x4 Matrix'.

##### quaternion { #nodebpy.nodes.input.NamedAttribute.quaternion }

```python
nodes.input.NamedAttribute.quaternion(name='')
```

Create Named Attribute with operation 'Quaternion'.

##### vector { #nodebpy.nodes.input.NamedAttribute.vector }

```python
nodes.input.NamedAttribute.vector(name='')
```

Create Named Attribute with operation 'Vector'.

### NamedLayerSelection { #nodebpy.nodes.input.NamedLayerSelection }

```python
nodes.input.NamedLayerSelection(name='')
```

Output a selection of a Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_name](#nodebpy.nodes.input.NamedLayerSelection.i_name) | Input socket: Name |
| [name](#nodebpy.nodes.input.NamedLayerSelection.name) |  |
| [node](#nodebpy.nodes.input.NamedLayerSelection.node) |  |
| [o_selection](#nodebpy.nodes.input.NamedLayerSelection.o_selection) | Output socket: Selection |
| [tree](#nodebpy.nodes.input.NamedLayerSelection.tree) |  |
| [type](#nodebpy.nodes.input.NamedLayerSelection.type) |  |

### Normal { #nodebpy.nodes.input.Normal }

```python
nodes.input.Normal(legacy_corner_normals=False)
```

Retrieve a unit length vector indicating the direction pointing away from the geometry at each element

#### Attributes

| Name | Description |
| --- | --- |
| [legacy_corner_normals](#nodebpy.nodes.input.Normal.legacy_corner_normals) |  |
| [name](#nodebpy.nodes.input.Normal.name) |  |
| [node](#nodebpy.nodes.input.Normal.node) |  |
| [o_normal](#nodebpy.nodes.input.Normal.o_normal) | Output socket: Normal |
| [o_true_normal](#nodebpy.nodes.input.Normal.o_true_normal) | Output socket: True Normal |
| [tree](#nodebpy.nodes.input.Normal.tree) |  |
| [type](#nodebpy.nodes.input.Normal.type) |  |

### Object { #nodebpy.nodes.input.Object }

```python
nodes.input.Object()
```

Output a single object

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Object.name) |  |
| [node](#nodebpy.nodes.input.Object.node) |  |
| [o_object](#nodebpy.nodes.input.Object.o_object) | Output socket: Object |
| [tree](#nodebpy.nodes.input.Object.tree) |  |
| [type](#nodebpy.nodes.input.Object.type) |  |

### ObjectInfo { #nodebpy.nodes.input.ObjectInfo }

```python
nodes.input.ObjectInfo(
    object=None,
    as_instance=False,
    *,
    transform_space='ORIGINAL',
)
```

Retrieve information from an object

#### Attributes

| Name | Description |
| --- | --- |
| [i_as_instance](#nodebpy.nodes.input.ObjectInfo.i_as_instance) | Input socket: As Instance |
| [i_object](#nodebpy.nodes.input.ObjectInfo.i_object) | Input socket: Object |
| [name](#nodebpy.nodes.input.ObjectInfo.name) |  |
| [node](#nodebpy.nodes.input.ObjectInfo.node) |  |
| [o_geometry](#nodebpy.nodes.input.ObjectInfo.o_geometry) | Output socket: Geometry |
| [o_location](#nodebpy.nodes.input.ObjectInfo.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.input.ObjectInfo.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.input.ObjectInfo.o_scale) | Output socket: Scale |
| [o_transform](#nodebpy.nodes.input.ObjectInfo.o_transform) | Output socket: Transform |
| [transform_space](#nodebpy.nodes.input.ObjectInfo.transform_space) |  |
| [tree](#nodebpy.nodes.input.ObjectInfo.tree) |  |
| [type](#nodebpy.nodes.input.ObjectInfo.type) |  |

### OffsetCornerInFace { #nodebpy.nodes.input.OffsetCornerInFace }

```python
nodes.input.OffsetCornerInFace(corner_index=0, offset=0)
```

Retrieve corners in the same face as another

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.OffsetCornerInFace.i_corner_index) | Input socket: Corner Index |
| [i_offset](#nodebpy.nodes.input.OffsetCornerInFace.i_offset) | Input socket: Offset |
| [name](#nodebpy.nodes.input.OffsetCornerInFace.name) |  |
| [node](#nodebpy.nodes.input.OffsetCornerInFace.node) |  |
| [o_corner_index](#nodebpy.nodes.input.OffsetCornerInFace.o_corner_index) | Output socket: Corner Index |
| [tree](#nodebpy.nodes.input.OffsetCornerInFace.tree) |  |
| [type](#nodebpy.nodes.input.OffsetCornerInFace.type) |  |

### OffsetPointInCurve { #nodebpy.nodes.input.OffsetPointInCurve }

```python
nodes.input.OffsetPointInCurve(point_index=0, offset=0)
```

Offset a control point index within its curve

#### Attributes

| Name | Description |
| --- | --- |
| [i_offset](#nodebpy.nodes.input.OffsetPointInCurve.i_offset) | Input socket: Offset |
| [i_point_index](#nodebpy.nodes.input.OffsetPointInCurve.i_point_index) | Input socket: Point Index |
| [name](#nodebpy.nodes.input.OffsetPointInCurve.name) |  |
| [node](#nodebpy.nodes.input.OffsetPointInCurve.node) |  |
| [o_is_valid_offset](#nodebpy.nodes.input.OffsetPointInCurve.o_is_valid_offset) | Output socket: Is Valid Offset |
| [o_point_index](#nodebpy.nodes.input.OffsetPointInCurve.o_point_index) | Output socket: Point Index |
| [tree](#nodebpy.nodes.input.OffsetPointInCurve.tree) |  |
| [type](#nodebpy.nodes.input.OffsetPointInCurve.type) |  |

### PointsOfCurve { #nodebpy.nodes.input.PointsOfCurve }

```python
nodes.input.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0)
```

Retrieve a point index within a curve

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve_index](#nodebpy.nodes.input.PointsOfCurve.i_curve_index) | Input socket: Curve Index |
| [i_sort_index](#nodebpy.nodes.input.PointsOfCurve.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.PointsOfCurve.i_weights) | Input socket: Weights |
| [name](#nodebpy.nodes.input.PointsOfCurve.name) |  |
| [node](#nodebpy.nodes.input.PointsOfCurve.node) |  |
| [o_point_index](#nodebpy.nodes.input.PointsOfCurve.o_point_index) | Output socket: Point Index |
| [o_total](#nodebpy.nodes.input.PointsOfCurve.o_total) | Output socket: Total |
| [tree](#nodebpy.nodes.input.PointsOfCurve.tree) |  |
| [type](#nodebpy.nodes.input.PointsOfCurve.type) |  |

### Position { #nodebpy.nodes.input.Position }

```python
nodes.input.Position()
```

Retrieve a vector indicating the location of each element

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Position.name) |  |
| [node](#nodebpy.nodes.input.Position.node) |  |
| [o_position](#nodebpy.nodes.input.Position.o_position) | Output socket: Position |
| [tree](#nodebpy.nodes.input.Position.tree) |  |
| [type](#nodebpy.nodes.input.Position.type) |  |

### Radius { #nodebpy.nodes.input.Radius }

```python
nodes.input.Radius()
```

Retrieve the radius at each point on curve or point cloud geometry

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Radius.name) |  |
| [node](#nodebpy.nodes.input.Radius.node) |  |
| [o_radius](#nodebpy.nodes.input.Radius.o_radius) | Output socket: Radius |
| [tree](#nodebpy.nodes.input.Radius.tree) |  |
| [type](#nodebpy.nodes.input.Radius.type) |  |

### Rotation { #nodebpy.nodes.input.Rotation }

```python
nodes.input.Rotation(rotation_euler=(0.0, 0.0, 0.0))
```

Provide a rotation value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Rotation.name) |  |
| [node](#nodebpy.nodes.input.Rotation.node) |  |
| [o_rotation](#nodebpy.nodes.input.Rotation.o_rotation) | Output socket: Rotation |
| [rotation_euler](#nodebpy.nodes.input.Rotation.rotation_euler) |  |
| [tree](#nodebpy.nodes.input.Rotation.tree) |  |
| [type](#nodebpy.nodes.input.Rotation.type) |  |

### SceneTime { #nodebpy.nodes.input.SceneTime }

```python
nodes.input.SceneTime()
```

Retrieve the current time in the scene's animation in units of seconds or frames

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SceneTime.name) |  |
| [node](#nodebpy.nodes.input.SceneTime.node) |  |
| [o_frame](#nodebpy.nodes.input.SceneTime.o_frame) | Output socket: Frame |
| [o_seconds](#nodebpy.nodes.input.SceneTime.o_seconds) | Output socket: Seconds |
| [tree](#nodebpy.nodes.input.SceneTime.tree) |  |
| [type](#nodebpy.nodes.input.SceneTime.type) |  |

### Selection { #nodebpy.nodes.input.Selection }

```python
nodes.input.Selection()
```

User selection of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Selection.name) |  |
| [node](#nodebpy.nodes.input.Selection.node) |  |
| [o_float](#nodebpy.nodes.input.Selection.o_float) | Output socket: Float |
| [o_selection](#nodebpy.nodes.input.Selection.o_selection) | Output socket: Boolean |
| [tree](#nodebpy.nodes.input.Selection.tree) |  |
| [type](#nodebpy.nodes.input.Selection.type) |  |

### SelfObject { #nodebpy.nodes.input.SelfObject }

```python
nodes.input.SelfObject()
```

Retrieve the object that contains the geometry nodes modifier currently being executed

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SelfObject.name) |  |
| [node](#nodebpy.nodes.input.SelfObject.node) |  |
| [o_self_object](#nodebpy.nodes.input.SelfObject.o_self_object) | Output socket: Self Object |
| [tree](#nodebpy.nodes.input.SelfObject.tree) |  |
| [type](#nodebpy.nodes.input.SelfObject.type) |  |

### ShortestEdgePaths { #nodebpy.nodes.input.ShortestEdgePaths }

```python
nodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0)
```

Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_cost](#nodebpy.nodes.input.ShortestEdgePaths.i_edge_cost) | Input socket: Edge Cost |
| [i_end_vertex](#nodebpy.nodes.input.ShortestEdgePaths.i_end_vertex) | Input socket: End Vertex |
| [name](#nodebpy.nodes.input.ShortestEdgePaths.name) |  |
| [node](#nodebpy.nodes.input.ShortestEdgePaths.node) |  |
| [o_next_vertex_index](#nodebpy.nodes.input.ShortestEdgePaths.o_next_vertex_index) | Output socket: Next Vertex Index |
| [o_total_cost](#nodebpy.nodes.input.ShortestEdgePaths.o_total_cost) | Output socket: Total Cost |
| [tree](#nodebpy.nodes.input.ShortestEdgePaths.tree) |  |
| [type](#nodebpy.nodes.input.ShortestEdgePaths.type) |  |

### SpecialCharacters { #nodebpy.nodes.input.SpecialCharacters }

```python
nodes.input.SpecialCharacters()
```

Output string characters that cannot be typed directly with the keyboard

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SpecialCharacters.name) |  |
| [node](#nodebpy.nodes.input.SpecialCharacters.node) |  |
| [o_line_break](#nodebpy.nodes.input.SpecialCharacters.o_line_break) | Output socket: Line Break |
| [o_tab](#nodebpy.nodes.input.SpecialCharacters.o_tab) | Output socket: Tab |
| [tree](#nodebpy.nodes.input.SpecialCharacters.tree) |  |
| [type](#nodebpy.nodes.input.SpecialCharacters.type) |  |

### SplineLength { #nodebpy.nodes.input.SplineLength }

```python
nodes.input.SplineLength()
```

Retrieve the total length of each spline, as a distance or as a number of points

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SplineLength.name) |  |
| [node](#nodebpy.nodes.input.SplineLength.node) |  |
| [o_length](#nodebpy.nodes.input.SplineLength.o_length) | Output socket: Length |
| [o_point_count](#nodebpy.nodes.input.SplineLength.o_point_count) | Output socket: Point Count |
| [tree](#nodebpy.nodes.input.SplineLength.tree) |  |
| [type](#nodebpy.nodes.input.SplineLength.type) |  |

### SplineParameter { #nodebpy.nodes.input.SplineParameter }

```python
nodes.input.SplineParameter()
```

Retrieve how far along each spline a control point is

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SplineParameter.name) |  |
| [node](#nodebpy.nodes.input.SplineParameter.node) |  |
| [o_factor](#nodebpy.nodes.input.SplineParameter.o_factor) | Output socket: Factor |
| [o_index](#nodebpy.nodes.input.SplineParameter.o_index) | Output socket: Index |
| [o_length](#nodebpy.nodes.input.SplineParameter.o_length) | Output socket: Length |
| [tree](#nodebpy.nodes.input.SplineParameter.tree) |  |
| [type](#nodebpy.nodes.input.SplineParameter.type) |  |

### SplineResolution { #nodebpy.nodes.input.SplineResolution }

```python
nodes.input.SplineResolution()
```

Retrieve the number of evaluated points that will be generated for every control point on curves

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.SplineResolution.name) |  |
| [node](#nodebpy.nodes.input.SplineResolution.node) |  |
| [o_resolution](#nodebpy.nodes.input.SplineResolution.o_resolution) | Output socket: Resolution |
| [tree](#nodebpy.nodes.input.SplineResolution.tree) |  |
| [type](#nodebpy.nodes.input.SplineResolution.type) |  |

### String { #nodebpy.nodes.input.String }

```python
nodes.input.String(string='')
```

Provide a string value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.String.name) |  |
| [node](#nodebpy.nodes.input.String.node) |  |
| [o_string](#nodebpy.nodes.input.String.o_string) | Output socket: String |
| [string](#nodebpy.nodes.input.String.string) |  |
| [tree](#nodebpy.nodes.input.String.tree) |  |
| [type](#nodebpy.nodes.input.String.type) |  |

### UVTangent { #nodebpy.nodes.input.UVTangent }

```python
nodes.input.UVTangent(method='Exact', uv=None)
```

Generate tangent directions based on a UV map

#### Attributes

| Name | Description |
| --- | --- |
| [i_method](#nodebpy.nodes.input.UVTangent.i_method) | Input socket: Method |
| [i_uv](#nodebpy.nodes.input.UVTangent.i_uv) | Input socket: UV |
| [name](#nodebpy.nodes.input.UVTangent.name) |  |
| [node](#nodebpy.nodes.input.UVTangent.node) |  |
| [o_tangent](#nodebpy.nodes.input.UVTangent.o_tangent) | Output socket: Tangent |
| [tree](#nodebpy.nodes.input.UVTangent.tree) |  |
| [type](#nodebpy.nodes.input.UVTangent.type) |  |

### Vector { #nodebpy.nodes.input.Vector }

```python
nodes.input.Vector(vector=(0.0, 0.0, 0.0))
```

Provide a vector value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.Vector.name) |  |
| [node](#nodebpy.nodes.input.Vector.node) |  |
| [o_vector](#nodebpy.nodes.input.Vector.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.input.Vector.tree) |  |
| [type](#nodebpy.nodes.input.Vector.type) |  |
| [vector](#nodebpy.nodes.input.Vector.vector) |  |

### VertexNeighbors { #nodebpy.nodes.input.VertexNeighbors }

```python
nodes.input.VertexNeighbors()
```

Retrieve topology information relating to each vertex of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.VertexNeighbors.name) |  |
| [node](#nodebpy.nodes.input.VertexNeighbors.node) |  |
| [o_face_count](#nodebpy.nodes.input.VertexNeighbors.o_face_count) | Output socket: Face Count |
| [o_vertex_count](#nodebpy.nodes.input.VertexNeighbors.o_vertex_count) | Output socket: Vertex Count |
| [tree](#nodebpy.nodes.input.VertexNeighbors.tree) |  |
| [type](#nodebpy.nodes.input.VertexNeighbors.type) |  |

### VertexOfCorner { #nodebpy.nodes.input.VertexOfCorner }

```python
nodes.input.VertexOfCorner(corner_index=0)
```

Retrieve the vertex each face corner is attached to

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.VertexOfCorner.i_corner_index) | Input socket: Corner Index |
| [name](#nodebpy.nodes.input.VertexOfCorner.name) |  |
| [node](#nodebpy.nodes.input.VertexOfCorner.node) |  |
| [o_vertex_index](#nodebpy.nodes.input.VertexOfCorner.o_vertex_index) | Output socket: Vertex Index |
| [tree](#nodebpy.nodes.input.VertexOfCorner.tree) |  |
| [type](#nodebpy.nodes.input.VertexOfCorner.type) |  |

### ViewportTransform { #nodebpy.nodes.input.ViewportTransform }

```python
nodes.input.ViewportTransform()
```

Retrieve the view direction and location of the 3D viewport

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.ViewportTransform.name) |  |
| [node](#nodebpy.nodes.input.ViewportTransform.node) |  |
| [o_is_orthographic](#nodebpy.nodes.input.ViewportTransform.o_is_orthographic) | Output socket: Is Orthographic |
| [o_projection](#nodebpy.nodes.input.ViewportTransform.o_projection) | Output socket: Projection |
| [o_view](#nodebpy.nodes.input.ViewportTransform.o_view) | Output socket: View |
| [tree](#nodebpy.nodes.input.ViewportTransform.tree) |  |
| [type](#nodebpy.nodes.input.ViewportTransform.type) |  |

### VoxelIndex { #nodebpy.nodes.input.VoxelIndex }

```python
nodes.input.VoxelIndex()
```

Retrieve the integer coordinates of the voxel that the field is evaluated on

#### Attributes

| Name | Description |
| --- | --- |
| [name](#nodebpy.nodes.input.VoxelIndex.name) |  |
| [node](#nodebpy.nodes.input.VoxelIndex.node) |  |
| [o_extent_x](#nodebpy.nodes.input.VoxelIndex.o_extent_x) | Output socket: Extent X |
| [o_extent_y](#nodebpy.nodes.input.VoxelIndex.o_extent_y) | Output socket: Extent Y |
| [o_extent_z](#nodebpy.nodes.input.VoxelIndex.o_extent_z) | Output socket: Extent Z |
| [o_is_tile](#nodebpy.nodes.input.VoxelIndex.o_is_tile) | Output socket: Is Tile |
| [o_x](#nodebpy.nodes.input.VoxelIndex.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.input.VoxelIndex.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.input.VoxelIndex.o_z) | Output socket: Z |
| [tree](#nodebpy.nodes.input.VoxelIndex.tree) |  |
| [type](#nodebpy.nodes.input.VoxelIndex.type) |  |