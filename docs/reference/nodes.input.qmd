# nodes.input { #nodebpy.nodes.input }

`nodes.input`



## Classes

| Name | Description |
| --- | --- |
| [ActiveCamera](#nodebpy.nodes.input.ActiveCamera) | Retrieve the scene's active camera |
| [ActiveElement](#nodebpy.nodes.input.ActiveElement) | Active element indices of the edited geometry, for tool execution |
| [Boolean](#nodebpy.nodes.input.Boolean) | Provide a True/False value that can be connected to other nodes in the tree |
| [CameraInfo](#nodebpy.nodes.input.CameraInfo) | Retrieve information from a camera object |
| [Collection](#nodebpy.nodes.input.Collection) | Output a single collection |
| [CollectionInfo](#nodebpy.nodes.input.CollectionInfo) | Retrieve geometry instances from a collection |
| [Color](#nodebpy.nodes.input.Color) | Output a color value chosen with the color picker widget |
| [CornersOfEdge](#nodebpy.nodes.input.CornersOfEdge) | Retrieve face corners connected to edges |
| [CornersOfFace](#nodebpy.nodes.input.CornersOfFace) | Retrieve corners that make up a face |
| [CornersOfVertex](#nodebpy.nodes.input.CornersOfVertex) | Retrieve face corners connected to vertices |
| [Cursor3D](#nodebpy.nodes.input.Cursor3D) | The scene's 3D cursor location and rotation |
| [CurveTangent](#nodebpy.nodes.input.CurveTangent) | Retrieve the direction of curves at each control point |
| [EdgePathsToSelection](#nodebpy.nodes.input.EdgePathsToSelection) | Output a selection of edges by following paths across mesh edges |
| [EdgesOfCorner](#nodebpy.nodes.input.EdgesOfCorner) | Retrieve the edges on both sides of a face corner |
| [EdgesOfVertex](#nodebpy.nodes.input.EdgesOfVertex) | Retrieve the edges connected to each vertex |
| [EdgesToFaceGroups](#nodebpy.nodes.input.EdgesToFaceGroups) | Group faces into regions surrounded by the selected boundary edges |
| [FaceOfCorner](#nodebpy.nodes.input.FaceOfCorner) | Retrieve the face each face corner is part of |
| [FaceSet](#nodebpy.nodes.input.FaceSet) | Each face's sculpt face set value |
| [ID](#nodebpy.nodes.input.ID) | Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist |
| [Image](#nodebpy.nodes.input.Image) | Input an image data-block |
| [ImageInfo](#nodebpy.nodes.input.ImageInfo) | Retrieve information about an image |
| [ImportCSV](#nodebpy.nodes.input.ImportCSV) | Import geometry from an CSV file |
| [ImportOBJ](#nodebpy.nodes.input.ImportOBJ) | Import geometry from an OBJ file |
| [ImportPLY](#nodebpy.nodes.input.ImportPLY) | Import a point cloud from a PLY file |
| [ImportSTL](#nodebpy.nodes.input.ImportSTL) | Import a mesh from an STL file |
| [ImportText](#nodebpy.nodes.input.ImportText) | Import a string from a text file |
| [ImportVDB](#nodebpy.nodes.input.ImportVDB) | Import volume data from a .vdb file |
| [Index](#nodebpy.nodes.input.Index) | Retrieve an integer value indicating the position of each element in the list, starting at zero |
| [InstanceBounds](#nodebpy.nodes.input.InstanceBounds) | Calculate position bounds of each instance's geometry set |
| [InstanceRotation](#nodebpy.nodes.input.InstanceRotation) | Retrieve the rotation of each instance in the geometry |
| [InstanceScale](#nodebpy.nodes.input.InstanceScale) | Retrieve the scale of each instance in the geometry |
| [InstanceTransform](#nodebpy.nodes.input.InstanceTransform) | Retrieve the full transformation of each instance in the geometry |
| [Integer](#nodebpy.nodes.input.Integer) | Provide an integer value that can be connected to other nodes in the tree |
| [IsEdgeSmooth](#nodebpy.nodes.input.IsEdgeSmooth) | Retrieve whether each edge is marked for smooth or split normals |
| [IsFaceSmooth](#nodebpy.nodes.input.IsFaceSmooth) | Retrieve whether each face is marked for smooth or sharp normals |
| [IsSplineCyclic](#nodebpy.nodes.input.IsSplineCyclic) | Retrieve whether each spline endpoint connects to the beginning |
| [IsViewport](#nodebpy.nodes.input.IsViewport) | Retrieve whether the nodes are being evaluated for the viewport rather than the final render |
| [Material](#nodebpy.nodes.input.Material) | Output a single material |
| [MaterialIndex](#nodebpy.nodes.input.MaterialIndex) | Retrieve the index of the material used for each element in the geometry's list of materials |
| [MousePosition](#nodebpy.nodes.input.MousePosition) | Retrieve the position of the mouse cursor |
| [NamedLayerSelection](#nodebpy.nodes.input.NamedLayerSelection) | Output a selection of a Grease Pencil layer |
| [Normal](#nodebpy.nodes.input.Normal) | Retrieve a unit length vector indicating the direction pointing away from the geometry at each element |
| [Object](#nodebpy.nodes.input.Object) | Output a single object |
| [ObjectInfo](#nodebpy.nodes.input.ObjectInfo) | Retrieve information from an object |
| [OffsetCornerInFace](#nodebpy.nodes.input.OffsetCornerInFace) | Retrieve corners in the same face as another |
| [Position](#nodebpy.nodes.input.Position) | Retrieve a vector indicating the location of each element |
| [Radius](#nodebpy.nodes.input.Radius) | Retrieve the radius at each point on curve or point cloud geometry |
| [Rotation](#nodebpy.nodes.input.Rotation) | Provide a rotation value that can be connected to other nodes in the tree |
| [SceneTime](#nodebpy.nodes.input.SceneTime) | Retrieve the current time in the scene's animation in units of seconds or frames |
| [Selection](#nodebpy.nodes.input.Selection) | User selection of the edited geometry, for tool execution |
| [SelfObject](#nodebpy.nodes.input.SelfObject) | Retrieve the object that contains the geometry nodes modifier currently being executed |
| [ShortestEdgePaths](#nodebpy.nodes.input.ShortestEdgePaths) | Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge |
| [SpecialCharacters](#nodebpy.nodes.input.SpecialCharacters) | Output string characters that cannot be typed directly with the keyboard |
| [SplineLength](#nodebpy.nodes.input.SplineLength) | Retrieve the total length of each spline, as a distance or as a number of points |
| [SplineParameter](#nodebpy.nodes.input.SplineParameter) | Retrieve how far along each spline a control point is |
| [SplineResolution](#nodebpy.nodes.input.SplineResolution) | Retrieve the number of evaluated points that will be generated for every control point on curves |
| [String](#nodebpy.nodes.input.String) | Provide a string value that can be connected to other nodes in the tree |
| [UVTangent](#nodebpy.nodes.input.UVTangent) | Generate tangent directions based on a UV map |
| [Value](#nodebpy.nodes.input.Value) | Input numerical values to other nodes in the tree |
| [Vector](#nodebpy.nodes.input.Vector) | Provide a vector value that can be connected to other nodes in the tree |
| [VertexOfCorner](#nodebpy.nodes.input.VertexOfCorner) | Retrieve the vertex each face corner is attached to |
| [ViewportTransform](#nodebpy.nodes.input.ViewportTransform) | Retrieve the view direction and location of the 3D viewport |
| [VoxelIndex](#nodebpy.nodes.input.VoxelIndex) | Retrieve the integer coordinates of the voxel that the field is evaluated on |

### ActiveCamera { #nodebpy.nodes.input.ActiveCamera }

```python
nodes.input.ActiveCamera()
```

Retrieve the scene's active camera

#### Attributes

| Name | Description |
| --- | --- |
| [o_active_camera](#nodebpy.nodes.input.ActiveCamera.o_active_camera) | Output socket: Active Camera |

### ActiveElement { #nodebpy.nodes.input.ActiveElement }

```python
nodes.input.ActiveElement(domain='POINT')
```

Active element indices of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [o_exists](#nodebpy.nodes.input.ActiveElement.o_exists) | Output socket: Exists |
| [o_index](#nodebpy.nodes.input.ActiveElement.o_index) | Output socket: Index |

### Boolean { #nodebpy.nodes.input.Boolean }

```python
nodes.input.Boolean(boolean=False)
```

Provide a True/False value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_boolean](#nodebpy.nodes.input.Boolean.o_boolean) | Output socket: Boolean |

### CameraInfo { #nodebpy.nodes.input.CameraInfo }

```python
nodes.input.CameraInfo(camera=None)
```

Retrieve information from a camera object

#### Attributes

| Name | Description |
| --- | --- |
| [i_camera](#nodebpy.nodes.input.CameraInfo.i_camera) | Input socket: Camera |
| [o_clip_end](#nodebpy.nodes.input.CameraInfo.o_clip_end) | Output socket: Clip End |
| [o_clip_start](#nodebpy.nodes.input.CameraInfo.o_clip_start) | Output socket: Clip Start |
| [o_focal_length](#nodebpy.nodes.input.CameraInfo.o_focal_length) | Output socket: Focal Length |
| [o_focus_distance](#nodebpy.nodes.input.CameraInfo.o_focus_distance) | Output socket: Focus Distance |
| [o_is_orthographic](#nodebpy.nodes.input.CameraInfo.o_is_orthographic) | Output socket: Is Orthographic |
| [o_orthographic_scale](#nodebpy.nodes.input.CameraInfo.o_orthographic_scale) | Output socket: Orthographic Scale |
| [o_projection_matrix](#nodebpy.nodes.input.CameraInfo.o_projection_matrix) | Output socket: Projection Matrix |
| [o_sensor](#nodebpy.nodes.input.CameraInfo.o_sensor) | Output socket: Sensor |
| [o_shift](#nodebpy.nodes.input.CameraInfo.o_shift) | Output socket: Shift |

### Collection { #nodebpy.nodes.input.Collection }

```python
nodes.input.Collection(collection=None)
```

Output a single collection

#### Attributes

| Name | Description |
| --- | --- |
| [o_collection](#nodebpy.nodes.input.Collection.o_collection) | Output socket: Collection |

### CollectionInfo { #nodebpy.nodes.input.CollectionInfo }

```python
nodes.input.CollectionInfo(
    collection=None,
    separate_children=False,
    reset_children=False,
    transform_space='ORIGINAL',
)
```

Retrieve geometry instances from a collection

#### Attributes

| Name | Description |
| --- | --- |
| [i_collection](#nodebpy.nodes.input.CollectionInfo.i_collection) | Input socket: Collection |
| [i_reset_children](#nodebpy.nodes.input.CollectionInfo.i_reset_children) | Input socket: Reset Children |
| [i_separate_children](#nodebpy.nodes.input.CollectionInfo.i_separate_children) | Input socket: Separate Children |
| [o_instances](#nodebpy.nodes.input.CollectionInfo.o_instances) | Output socket: Instances |

### Color { #nodebpy.nodes.input.Color }

```python
nodes.input.Color(value=(1.0, 0.0, 1.0, 1.0), **kwargs)
```

Output a color value chosen with the color picker widget

#### Attributes

| Name | Description |
| --- | --- |
| [o_color](#nodebpy.nodes.input.Color.o_color) | Output socket: Color |

### CornersOfEdge { #nodebpy.nodes.input.CornersOfEdge }

```python
nodes.input.CornersOfEdge(edge_index=None, weights=None, sort_index=0)
```

Retrieve face corners connected to edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_index](#nodebpy.nodes.input.CornersOfEdge.i_edge_index) | Input socket: Edge Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfEdge.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfEdge.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfEdge.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfEdge.o_total) | Output socket: Total |

### CornersOfFace { #nodebpy.nodes.input.CornersOfFace }

```python
nodes.input.CornersOfFace(face_index=None, weights=None, sort_index=0)
```

Retrieve corners that make up a face

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_index](#nodebpy.nodes.input.CornersOfFace.i_face_index) | Input socket: Face Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfFace.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfFace.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfFace.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfFace.o_total) | Output socket: Total |

### CornersOfVertex { #nodebpy.nodes.input.CornersOfVertex }

```python
nodes.input.CornersOfVertex(vertex_index=None, weights=None, sort_index=0)
```

Retrieve face corners connected to vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.input.CornersOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.input.CornersOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.input.CornersOfVertex.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfVertex.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfVertex.o_total) | Output socket: Total |

### Cursor3D { #nodebpy.nodes.input.Cursor3D }

```python
nodes.input.Cursor3D()
```

The scene's 3D cursor location and rotation

#### Attributes

| Name | Description |
| --- | --- |
| [o_location](#nodebpy.nodes.input.Cursor3D.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.input.Cursor3D.o_rotation) | Output socket: Rotation |

### CurveTangent { #nodebpy.nodes.input.CurveTangent }

```python
nodes.input.CurveTangent()
```

Retrieve the direction of curves at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [o_tangent](#nodebpy.nodes.input.CurveTangent.o_tangent) | Output socket: Tangent |

### EdgePathsToSelection { #nodebpy.nodes.input.EdgePathsToSelection }

```python
nodes.input.EdgePathsToSelection(start_vertices=None, next_vertex_index=None)
```

Output a selection of edges by following paths across mesh edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_next_vertex_index](#nodebpy.nodes.input.EdgePathsToSelection.i_next_vertex_index) | Input socket: Next Vertex Index |
| [i_start_vertices](#nodebpy.nodes.input.EdgePathsToSelection.i_start_vertices) | Input socket: Start Vertices |
| [o_selection](#nodebpy.nodes.input.EdgePathsToSelection.o_selection) | Output socket: Selection |

### EdgesOfCorner { #nodebpy.nodes.input.EdgesOfCorner }

```python
nodes.input.EdgesOfCorner(corner_index=None)
```

Retrieve the edges on both sides of a face corner

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.EdgesOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_next_edge_index](#nodebpy.nodes.input.EdgesOfCorner.o_next_edge_index) | Output socket: Next Edge Index |
| [o_previous_edge_index](#nodebpy.nodes.input.EdgesOfCorner.o_previous_edge_index) | Output socket: Previous Edge Index |

### EdgesOfVertex { #nodebpy.nodes.input.EdgesOfVertex }

```python
nodes.input.EdgesOfVertex(vertex_index=None, weights=None, sort_index=0)
```

Retrieve the edges connected to each vertex

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.input.EdgesOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.input.EdgesOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.input.EdgesOfVertex.i_weights) | Input socket: Weights |
| [o_edge_index](#nodebpy.nodes.input.EdgesOfVertex.o_edge_index) | Output socket: Edge Index |
| [o_total](#nodebpy.nodes.input.EdgesOfVertex.o_total) | Output socket: Total |

### EdgesToFaceGroups { #nodebpy.nodes.input.EdgesToFaceGroups }

```python
nodes.input.EdgesToFaceGroups(boundary_edges=None)
```

Group faces into regions surrounded by the selected boundary edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_boundary_edges](#nodebpy.nodes.input.EdgesToFaceGroups.i_boundary_edges) | Input socket: Boundary Edges |
| [o_face_group_id](#nodebpy.nodes.input.EdgesToFaceGroups.o_face_group_id) | Output socket: Face Group ID |

### FaceOfCorner { #nodebpy.nodes.input.FaceOfCorner }

```python
nodes.input.FaceOfCorner(corner_index=None)
```

Retrieve the face each face corner is part of

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.FaceOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_face_index](#nodebpy.nodes.input.FaceOfCorner.o_face_index) | Output socket: Face Index |
| [o_index_in_face](#nodebpy.nodes.input.FaceOfCorner.o_index_in_face) | Output socket: Index in Face |

### FaceSet { #nodebpy.nodes.input.FaceSet }

```python
nodes.input.FaceSet()
```

Each face's sculpt face set value

#### Attributes

| Name | Description |
| --- | --- |
| [o_exists](#nodebpy.nodes.input.FaceSet.o_exists) | Output socket: Exists |
| [o_face_set](#nodebpy.nodes.input.FaceSet.o_face_set) | Output socket: Face Set |

### ID { #nodebpy.nodes.input.ID }

```python
nodes.input.ID()
```

Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist

#### Attributes

| Name | Description |
| --- | --- |
| [o_id](#nodebpy.nodes.input.ID.o_id) | Output socket: ID |

### Image { #nodebpy.nodes.input.Image }

```python
nodes.input.Image(image=None)
```

Input an image data-block

#### Attributes

| Name | Description |
| --- | --- |
| [image](#nodebpy.nodes.input.Image.image) | Input socket: Image |
| [o_image](#nodebpy.nodes.input.Image.o_image) | Output socket: Image |

### ImageInfo { #nodebpy.nodes.input.ImageInfo }

```python
nodes.input.ImageInfo(image=None, frame=0)
```

Retrieve information about an image

#### Attributes

| Name | Description |
| --- | --- |
| [i_frame](#nodebpy.nodes.input.ImageInfo.i_frame) | Input socket: Frame |
| [i_image](#nodebpy.nodes.input.ImageInfo.i_image) | Input socket: Image |
| [o_fps](#nodebpy.nodes.input.ImageInfo.o_fps) | Output socket: FPS |
| [o_frame_count](#nodebpy.nodes.input.ImageInfo.o_frame_count) | Output socket: Frame Count |
| [o_has_alpha](#nodebpy.nodes.input.ImageInfo.o_has_alpha) | Output socket: Has Alpha |
| [o_height](#nodebpy.nodes.input.ImageInfo.o_height) | Output socket: Height |
| [o_width](#nodebpy.nodes.input.ImageInfo.o_width) | Output socket: Width |

### ImportCSV { #nodebpy.nodes.input.ImportCSV }

```python
nodes.input.ImportCSV(path='', delimiter=',')
```

Import geometry from an CSV file

#### Attributes

| Name | Description |
| --- | --- |
| [i_delimiter](#nodebpy.nodes.input.ImportCSV.i_delimiter) | Input socket: Delimiter |
| [i_path](#nodebpy.nodes.input.ImportCSV.i_path) | Input socket: Path |
| [o_point_cloud](#nodebpy.nodes.input.ImportCSV.o_point_cloud) | Output socket: Point Cloud |

### ImportOBJ { #nodebpy.nodes.input.ImportOBJ }

```python
nodes.input.ImportOBJ(path='')
```

Import geometry from an OBJ file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportOBJ.i_path) | Input socket: Path |
| [o_instances](#nodebpy.nodes.input.ImportOBJ.o_instances) | Output socket: Instances |

### ImportPLY { #nodebpy.nodes.input.ImportPLY }

```python
nodes.input.ImportPLY(path='')
```

Import a point cloud from a PLY file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportPLY.i_path) | Input socket: Path |
| [o_mesh](#nodebpy.nodes.input.ImportPLY.o_mesh) | Output socket: Mesh |

### ImportSTL { #nodebpy.nodes.input.ImportSTL }

```python
nodes.input.ImportSTL(path='')
```

Import a mesh from an STL file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportSTL.i_path) | Input socket: Path |
| [o_mesh](#nodebpy.nodes.input.ImportSTL.o_mesh) | Output socket: Mesh |

### ImportText { #nodebpy.nodes.input.ImportText }

```python
nodes.input.ImportText(path='')
```

Import a string from a text file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportText.i_path) | Input socket: Path |
| [o_string](#nodebpy.nodes.input.ImportText.o_string) | Output socket: String |

### ImportVDB { #nodebpy.nodes.input.ImportVDB }

```python
nodes.input.ImportVDB(path='')
```

Import volume data from a .vdb file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.input.ImportVDB.i_path) | Input socket: Path |
| [o_volume](#nodebpy.nodes.input.ImportVDB.o_volume) | Output socket: Volume |

### Index { #nodebpy.nodes.input.Index }

```python
nodes.input.Index()
```

Retrieve an integer value indicating the position of each element in the list, starting at zero

#### Attributes

| Name | Description |
| --- | --- |
| [o_index](#nodebpy.nodes.input.Index.o_index) | Output socket: Index |

### InstanceBounds { #nodebpy.nodes.input.InstanceBounds }

```python
nodes.input.InstanceBounds(use_radius=True)
```

Calculate position bounds of each instance's geometry set

#### Attributes

| Name | Description |
| --- | --- |
| [i_use_radius](#nodebpy.nodes.input.InstanceBounds.i_use_radius) | Input socket: Use Radius |
| [o_max](#nodebpy.nodes.input.InstanceBounds.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.input.InstanceBounds.o_min) | Output socket: Min |

### InstanceRotation { #nodebpy.nodes.input.InstanceRotation }

```python
nodes.input.InstanceRotation()
```

Retrieve the rotation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.InstanceRotation.o_rotation) | Output socket: Rotation |

### InstanceScale { #nodebpy.nodes.input.InstanceScale }

```python
nodes.input.InstanceScale()
```

Retrieve the scale of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_scale](#nodebpy.nodes.input.InstanceScale.o_scale) | Output socket: Scale |

### InstanceTransform { #nodebpy.nodes.input.InstanceTransform }

```python
nodes.input.InstanceTransform()
```

Retrieve the full transformation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_transform](#nodebpy.nodes.input.InstanceTransform.o_transform) | Output socket: Transform |

### Integer { #nodebpy.nodes.input.Integer }

```python
nodes.input.Integer(integer=1)
```

Provide an integer value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_integer](#nodebpy.nodes.input.Integer.o_integer) | Output socket: Integer |

### IsEdgeSmooth { #nodebpy.nodes.input.IsEdgeSmooth }

```python
nodes.input.IsEdgeSmooth()
```

Retrieve whether each edge is marked for smooth or split normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsEdgeSmooth.o_smooth) | Output socket: Smooth |

### IsFaceSmooth { #nodebpy.nodes.input.IsFaceSmooth }

```python
nodes.input.IsFaceSmooth()
```

Retrieve whether each face is marked for smooth or sharp normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsFaceSmooth.o_smooth) | Output socket: Smooth |

### IsSplineCyclic { #nodebpy.nodes.input.IsSplineCyclic }

```python
nodes.input.IsSplineCyclic()
```

Retrieve whether each spline endpoint connects to the beginning

#### Attributes

| Name | Description |
| --- | --- |
| [o_cyclic](#nodebpy.nodes.input.IsSplineCyclic.o_cyclic) | Output socket: Cyclic |

### IsViewport { #nodebpy.nodes.input.IsViewport }

```python
nodes.input.IsViewport()
```

Retrieve whether the nodes are being evaluated for the viewport rather than the final render

#### Attributes

| Name | Description |
| --- | --- |
| [o_is_viewport](#nodebpy.nodes.input.IsViewport.o_is_viewport) | Output socket: Is Viewport |

### Material { #nodebpy.nodes.input.Material }

```python
nodes.input.Material(material=None)
```

Output a single material

#### Attributes

| Name | Description |
| --- | --- |
| [material](#nodebpy.nodes.input.Material.material) | Input socket: Material |
| [o_material](#nodebpy.nodes.input.Material.o_material) | Output socket: Material |

### MaterialIndex { #nodebpy.nodes.input.MaterialIndex }

```python
nodes.input.MaterialIndex()
```

Retrieve the index of the material used for each element in the geometry's list of materials

#### Attributes

| Name | Description |
| --- | --- |
| [o_material_index](#nodebpy.nodes.input.MaterialIndex.o_material_index) | Output socket: Material Index |

### MousePosition { #nodebpy.nodes.input.MousePosition }

```python
nodes.input.MousePosition()
```

Retrieve the position of the mouse cursor

#### Attributes

| Name | Description |
| --- | --- |
| [o_mouse_x](#nodebpy.nodes.input.MousePosition.o_mouse_x) | Output socket: Mouse X |
| [o_mouse_y](#nodebpy.nodes.input.MousePosition.o_mouse_y) | Output socket: Mouse Y |
| [o_region_height](#nodebpy.nodes.input.MousePosition.o_region_height) | Output socket: Region Height |
| [o_region_width](#nodebpy.nodes.input.MousePosition.o_region_width) | Output socket: Region Width |

### NamedLayerSelection { #nodebpy.nodes.input.NamedLayerSelection }

```python
nodes.input.NamedLayerSelection(name='')
```

Output a selection of a Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_name](#nodebpy.nodes.input.NamedLayerSelection.i_name) | Input socket: Name |
| [o_selection](#nodebpy.nodes.input.NamedLayerSelection.o_selection) | Output socket: Selection |

### Normal { #nodebpy.nodes.input.Normal }

```python
nodes.input.Normal()
```

Retrieve a unit length vector indicating the direction pointing away from the geometry at each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_normal](#nodebpy.nodes.input.Normal.o_normal) | Output socket: Normal |
| [o_true_normal](#nodebpy.nodes.input.Normal.o_true_normal) | Output socket: True Normal |

### Object { #nodebpy.nodes.input.Object }

```python
nodes.input.Object(object=None)
```

Output a single object

#### Attributes

| Name | Description |
| --- | --- |
| [o_object](#nodebpy.nodes.input.Object.o_object) | Output socket: Object |

### ObjectInfo { #nodebpy.nodes.input.ObjectInfo }

```python
nodes.input.ObjectInfo(
    object=None,
    as_instance=False,
    *,
    transform_space='ORIGINAL',
)
```

Retrieve information from an object

#### Attributes

| Name | Description |
| --- | --- |
| [i_as_instance](#nodebpy.nodes.input.ObjectInfo.i_as_instance) | Input socket: As Instance |
| [i_object](#nodebpy.nodes.input.ObjectInfo.i_object) | Input socket: Object |
| [o_geometry](#nodebpy.nodes.input.ObjectInfo.o_geometry) | Output socket: Geometry |
| [o_location](#nodebpy.nodes.input.ObjectInfo.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.input.ObjectInfo.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.input.ObjectInfo.o_scale) | Output socket: Scale |
| [o_transform](#nodebpy.nodes.input.ObjectInfo.o_transform) | Output socket: Transform |

### OffsetCornerInFace { #nodebpy.nodes.input.OffsetCornerInFace }

```python
nodes.input.OffsetCornerInFace(corner_index=None, offset=0)
```

Retrieve corners in the same face as another

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.OffsetCornerInFace.i_corner_index) | Input socket: Corner Index |
| [i_offset](#nodebpy.nodes.input.OffsetCornerInFace.i_offset) | Input socket: Offset |
| [o_corner_index](#nodebpy.nodes.input.OffsetCornerInFace.o_corner_index) | Output socket: Corner Index |

### Position { #nodebpy.nodes.input.Position }

```python
nodes.input.Position()
```

Retrieve a vector indicating the location of each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_position](#nodebpy.nodes.input.Position.o_position) | Output socket: Position |

### Radius { #nodebpy.nodes.input.Radius }

```python
nodes.input.Radius()
```

Retrieve the radius at each point on curve or point cloud geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_radius](#nodebpy.nodes.input.Radius.o_radius) | Output socket: Radius |

### Rotation { #nodebpy.nodes.input.Rotation }

```python
nodes.input.Rotation(rotation_euler=(0, 0, 0))
```

Provide a rotation value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.Rotation.o_rotation) | Output socket: Rotation |

### SceneTime { #nodebpy.nodes.input.SceneTime }

```python
nodes.input.SceneTime()
```

Retrieve the current time in the scene's animation in units of seconds or frames

#### Attributes

| Name | Description |
| --- | --- |
| [o_frame](#nodebpy.nodes.input.SceneTime.o_frame) | Output socket: Frame |
| [o_seconds](#nodebpy.nodes.input.SceneTime.o_seconds) | Output socket: Seconds |

### Selection { #nodebpy.nodes.input.Selection }

```python
nodes.input.Selection()
```

User selection of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [o_boolean](#nodebpy.nodes.input.Selection.o_boolean) | Output socket: Boolean |
| [o_float](#nodebpy.nodes.input.Selection.o_float) | Output socket: Float |

### SelfObject { #nodebpy.nodes.input.SelfObject }

```python
nodes.input.SelfObject()
```

Retrieve the object that contains the geometry nodes modifier currently being executed

#### Attributes

| Name | Description |
| --- | --- |
| [o_self_object](#nodebpy.nodes.input.SelfObject.o_self_object) | Output socket: Self Object |

### ShortestEdgePaths { #nodebpy.nodes.input.ShortestEdgePaths }

```python
nodes.input.ShortestEdgePaths(end_vertex=None, edge_cost=None, **kwargs)
```

Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_cost](#nodebpy.nodes.input.ShortestEdgePaths.i_edge_cost) | Input socket: Edge Cost |
| [i_end_vertex](#nodebpy.nodes.input.ShortestEdgePaths.i_end_vertex) | Input socket: End Vertex |
| [o_next_vertex_index](#nodebpy.nodes.input.ShortestEdgePaths.o_next_vertex_index) | Output socket: Next Vertex Index |
| [o_total_cost](#nodebpy.nodes.input.ShortestEdgePaths.o_total_cost) | Output socket: Total Cost |

### SpecialCharacters { #nodebpy.nodes.input.SpecialCharacters }

```python
nodes.input.SpecialCharacters()
```

Output string characters that cannot be typed directly with the keyboard

#### Attributes

| Name | Description |
| --- | --- |
| [o_line_break](#nodebpy.nodes.input.SpecialCharacters.o_line_break) | Output socket: Line Break |
| [o_tab](#nodebpy.nodes.input.SpecialCharacters.o_tab) | Output socket: Tab |

### SplineLength { #nodebpy.nodes.input.SplineLength }

```python
nodes.input.SplineLength()
```

Retrieve the total length of each spline, as a distance or as a number of points

#### Attributes

| Name | Description |
| --- | --- |
| [o_length](#nodebpy.nodes.input.SplineLength.o_length) | Output socket: Length |
| [o_point_count](#nodebpy.nodes.input.SplineLength.o_point_count) | Output socket: Point Count |

### SplineParameter { #nodebpy.nodes.input.SplineParameter }

```python
nodes.input.SplineParameter()
```

Retrieve how far along each spline a control point is

#### Attributes

| Name | Description |
| --- | --- |
| [o_factor](#nodebpy.nodes.input.SplineParameter.o_factor) | Output socket: Factor |
| [o_index](#nodebpy.nodes.input.SplineParameter.o_index) | Output socket: Index |
| [o_length](#nodebpy.nodes.input.SplineParameter.o_length) | Output socket: Length |

### SplineResolution { #nodebpy.nodes.input.SplineResolution }

```python
nodes.input.SplineResolution()
```

Retrieve the number of evaluated points that will be generated for every control point on curves

#### Attributes

| Name | Description |
| --- | --- |
| [o_resolution](#nodebpy.nodes.input.SplineResolution.o_resolution) | Output socket: Resolution |

### String { #nodebpy.nodes.input.String }

```python
nodes.input.String(string='')
```

Provide a string value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_string](#nodebpy.nodes.input.String.o_string) | Output socket: String |

### UVTangent { #nodebpy.nodes.input.UVTangent }

```python
nodes.input.UVTangent(method='Exact', uv=(0.0, 0.0))
```

Generate tangent directions based on a UV map

#### Attributes

| Name | Description |
| --- | --- |
| [i_method](#nodebpy.nodes.input.UVTangent.i_method) | Input socket: Method |
| [i_uv](#nodebpy.nodes.input.UVTangent.i_uv) | Input socket: UV |
| [o_tangent](#nodebpy.nodes.input.UVTangent.o_tangent) | Output socket: Tangent |

### Value { #nodebpy.nodes.input.Value }

```python
nodes.input.Value(value=0.0)
```

Input numerical values to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_value](#nodebpy.nodes.input.Value.o_value) | Output socket: Value |
| [value](#nodebpy.nodes.input.Value.value) | Input socket: Value |

### Vector { #nodebpy.nodes.input.Vector }

```python
nodes.input.Vector(vector=(0, 0, 0))
```

Provide a vector value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_vector](#nodebpy.nodes.input.Vector.o_vector) | Output socket: Vector |

### VertexOfCorner { #nodebpy.nodes.input.VertexOfCorner }

```python
nodes.input.VertexOfCorner(corner_index=0)
```

Retrieve the vertex each face corner is attached to

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.input.VertexOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_vertex_index](#nodebpy.nodes.input.VertexOfCorner.o_vertex_index) | Output socket: Vertex Index |

### ViewportTransform { #nodebpy.nodes.input.ViewportTransform }

```python
nodes.input.ViewportTransform()
```

Retrieve the view direction and location of the 3D viewport

#### Attributes

| Name | Description |
| --- | --- |
| [o_is_orthographic](#nodebpy.nodes.input.ViewportTransform.o_is_orthographic) | Output socket: Is Orthographic |
| [o_projection](#nodebpy.nodes.input.ViewportTransform.o_projection) | Output socket: Projection |
| [o_view](#nodebpy.nodes.input.ViewportTransform.o_view) | Output socket: View |

### VoxelIndex { #nodebpy.nodes.input.VoxelIndex }

```python
nodes.input.VoxelIndex()
```

Retrieve the integer coordinates of the voxel that the field is evaluated on

#### Attributes

| Name | Description |
| --- | --- |
| [o_extent_x](#nodebpy.nodes.input.VoxelIndex.o_extent_x) | Output socket: Extent X |
| [o_extent_y](#nodebpy.nodes.input.VoxelIndex.o_extent_y) | Output socket: Extent Y |
| [o_extent_z](#nodebpy.nodes.input.VoxelIndex.o_extent_z) | Output socket: Extent Z |
| [o_is_tile](#nodebpy.nodes.input.VoxelIndex.o_is_tile) | Output socket: Is Tile |
| [o_x](#nodebpy.nodes.input.VoxelIndex.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.input.VoxelIndex.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.input.VoxelIndex.o_z) | Output socket: Z |