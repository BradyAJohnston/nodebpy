# nodes.input { #nodebpy.nodes.input }

`nodes.input`



## Classes

| Name | Description |
| --- | --- |
| [ActiveCamera](#nodebpy.nodes.input.ActiveCamera) | Retrieve the scene's active camera |
| [Boolean](#nodebpy.nodes.input.Boolean) | Provide a True/False value that can be connected to other nodes in the tree |
| [CameraInfo](#nodebpy.nodes.input.CameraInfo) | Retrieve information from a camera object |
| [Collection](#nodebpy.nodes.input.Collection) | Output a single collection |
| [CollectionInfo](#nodebpy.nodes.input.CollectionInfo) | Retrieve geometry instances from a collection |
| [Color](#nodebpy.nodes.input.Color) | Output a color value chosen with the color picker widget |
| [CornersOfEdge](#nodebpy.nodes.input.CornersOfEdge) | Retrieve face corners connected to edges |
| [CornersOfFace](#nodebpy.nodes.input.CornersOfFace) | Retrieve corners that make up a face |
| [CornersOfVertex](#nodebpy.nodes.input.CornersOfVertex) | Retrieve face corners connected to vertices |
| [CurveTangent](#nodebpy.nodes.input.CurveTangent) | Retrieve the direction of curves at each control point |
| [ID](#nodebpy.nodes.input.ID) | Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist |
| [Image](#nodebpy.nodes.input.Image) | Input an image data-block |
| [Index](#nodebpy.nodes.input.Index) | Retrieve an integer value indicating the position of each element in the list, starting at zero |
| [InstanceBounds](#nodebpy.nodes.input.InstanceBounds) | Calculate position bounds of each instance's geometry set |
| [InstanceRotation](#nodebpy.nodes.input.InstanceRotation) | Retrieve the rotation of each instance in the geometry |
| [InstanceScale](#nodebpy.nodes.input.InstanceScale) | Retrieve the scale of each instance in the geometry |
| [Integer](#nodebpy.nodes.input.Integer) | Provide an integer value that can be connected to other nodes in the tree |
| [IsEdgeSmooth](#nodebpy.nodes.input.IsEdgeSmooth) | Retrieve whether each edge is marked for smooth or split normals |
| [IsFaceSmooth](#nodebpy.nodes.input.IsFaceSmooth) | Retrieve whether each face is marked for smooth or sharp normals |
| [IsSplineCyclic](#nodebpy.nodes.input.IsSplineCyclic) | Retrieve whether each spline endpoint connects to the beginning |
| [Material](#nodebpy.nodes.input.Material) | Output a single material |
| [MaterialIndex](#nodebpy.nodes.input.MaterialIndex) | Retrieve the index of the material used for each element in the geometry's list of materials |
| [NamedLayerSelection](#nodebpy.nodes.input.NamedLayerSelection) | Output a selection of a Grease Pencil layer |
| [Normal](#nodebpy.nodes.input.Normal) | Retrieve a unit length vector indicating the direction pointing away from the geometry at each element |
| [Object](#nodebpy.nodes.input.Object) | Output a single object |
| [Position](#nodebpy.nodes.input.Position) | Retrieve a vector indicating the location of each element |
| [Radius](#nodebpy.nodes.input.Radius) | Retrieve the radius at each point on curve or point cloud geometry |
| [Rotation](#nodebpy.nodes.input.Rotation) | Provide a rotation value that can be connected to other nodes in the tree |
| [SceneTime](#nodebpy.nodes.input.SceneTime) | Retrieve the current time in the scene's animation in units of seconds or frames |
| [ShortestEdgePaths](#nodebpy.nodes.input.ShortestEdgePaths) | Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge |
| [SpecialCharacters](#nodebpy.nodes.input.SpecialCharacters) | Output string characters that cannot be typed directly with the keyboard |
| [SplineResolution](#nodebpy.nodes.input.SplineResolution) | Retrieve the number of evaluated points that will be generated for every control point on curves |
| [String](#nodebpy.nodes.input.String) | Provide a string value that can be connected to other nodes in the tree |
| [Value](#nodebpy.nodes.input.Value) | Input numerical values to other nodes in the tree |
| [Vector](#nodebpy.nodes.input.Vector) | Provide a vector value that can be connected to other nodes in the tree |
| [VoxelIndex](#nodebpy.nodes.input.VoxelIndex) | Retrieve the integer coordinates of the voxel that the field is evaluated on |

### ActiveCamera { #nodebpy.nodes.input.ActiveCamera }

```python
nodes.input.ActiveCamera()
```

Retrieve the scene's active camera

#### Attributes

| Name | Description |
| --- | --- |
| [o_active_camera](#nodebpy.nodes.input.ActiveCamera.o_active_camera) | Output socket: Active Camera |

### Boolean { #nodebpy.nodes.input.Boolean }

```python
nodes.input.Boolean(boolean=False)
```

Provide a True/False value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_boolean](#nodebpy.nodes.input.Boolean.o_boolean) | Output socket: Boolean |

### CameraInfo { #nodebpy.nodes.input.CameraInfo }

```python
nodes.input.CameraInfo(camera=None)
```

Retrieve information from a camera object

#### Attributes

| Name | Description |
| --- | --- |
| [i_camera](#nodebpy.nodes.input.CameraInfo.i_camera) | Input socket: Camera |
| [o_clip_end](#nodebpy.nodes.input.CameraInfo.o_clip_end) | Output socket: Clip End |
| [o_clip_start](#nodebpy.nodes.input.CameraInfo.o_clip_start) | Output socket: Clip Start |
| [o_focal_length](#nodebpy.nodes.input.CameraInfo.o_focal_length) | Output socket: Focal Length |
| [o_focus_distance](#nodebpy.nodes.input.CameraInfo.o_focus_distance) | Output socket: Focus Distance |
| [o_is_orthographic](#nodebpy.nodes.input.CameraInfo.o_is_orthographic) | Output socket: Is Orthographic |
| [o_orthographic_scale](#nodebpy.nodes.input.CameraInfo.o_orthographic_scale) | Output socket: Orthographic Scale |
| [o_projection_matrix](#nodebpy.nodes.input.CameraInfo.o_projection_matrix) | Output socket: Projection Matrix |
| [o_sensor](#nodebpy.nodes.input.CameraInfo.o_sensor) | Output socket: Sensor |
| [o_shift](#nodebpy.nodes.input.CameraInfo.o_shift) | Output socket: Shift |

### Collection { #nodebpy.nodes.input.Collection }

```python
nodes.input.Collection(collection=None)
```

Output a single collection

#### Attributes

| Name | Description |
| --- | --- |
| [o_collection](#nodebpy.nodes.input.Collection.o_collection) | Output socket: Collection |

### CollectionInfo { #nodebpy.nodes.input.CollectionInfo }

```python
nodes.input.CollectionInfo(
    collection=None,
    separate_children=False,
    reset_children=False,
    transform_space='ORIGINAL',
)
```

Retrieve geometry instances from a collection

#### Attributes

| Name | Description |
| --- | --- |
| [i_collection](#nodebpy.nodes.input.CollectionInfo.i_collection) | Input socket: Collection |
| [i_reset_children](#nodebpy.nodes.input.CollectionInfo.i_reset_children) | Input socket: Reset Children |
| [i_separate_children](#nodebpy.nodes.input.CollectionInfo.i_separate_children) | Input socket: Separate Children |
| [o_instances](#nodebpy.nodes.input.CollectionInfo.o_instances) | Output socket: Instances |

### Color { #nodebpy.nodes.input.Color }

```python
nodes.input.Color(value=(1.0, 0.0, 1.0, 1.0), **kwargs)
```

Output a color value chosen with the color picker widget

#### Attributes

| Name | Description |
| --- | --- |
| [o_color](#nodebpy.nodes.input.Color.o_color) | Output socket: Color |

### CornersOfEdge { #nodebpy.nodes.input.CornersOfEdge }

```python
nodes.input.CornersOfEdge(edge_index=None, weights=None, sort_index=0)
```

Retrieve face corners connected to edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_index](#nodebpy.nodes.input.CornersOfEdge.i_edge_index) | Input socket: Edge Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfEdge.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfEdge.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfEdge.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfEdge.o_total) | Output socket: Total |

### CornersOfFace { #nodebpy.nodes.input.CornersOfFace }

```python
nodes.input.CornersOfFace(face_index=None, weights=None, sort_index=0)
```

Retrieve corners that make up a face

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_index](#nodebpy.nodes.input.CornersOfFace.i_face_index) | Input socket: Face Index |
| [i_sort_index](#nodebpy.nodes.input.CornersOfFace.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.input.CornersOfFace.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfFace.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfFace.o_total) | Output socket: Total |

### CornersOfVertex { #nodebpy.nodes.input.CornersOfVertex }

```python
nodes.input.CornersOfVertex(vertex_index=None, weights=None, sort_index=0)
```

Retrieve face corners connected to vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.input.CornersOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.input.CornersOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.input.CornersOfVertex.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.input.CornersOfVertex.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.input.CornersOfVertex.o_total) | Output socket: Total |

### CurveTangent { #nodebpy.nodes.input.CurveTangent }

```python
nodes.input.CurveTangent()
```

Retrieve the direction of curves at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [o_tangent](#nodebpy.nodes.input.CurveTangent.o_tangent) | Output socket: Tangent |

### ID { #nodebpy.nodes.input.ID }

```python
nodes.input.ID()
```

Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist

#### Attributes

| Name | Description |
| --- | --- |
| [o_id](#nodebpy.nodes.input.ID.o_id) | Output socket: ID |

### Image { #nodebpy.nodes.input.Image }

```python
nodes.input.Image(image=None)
```

Input an image data-block

#### Attributes

| Name | Description |
| --- | --- |
| [image](#nodebpy.nodes.input.Image.image) | Input socket: Image |
| [o_image](#nodebpy.nodes.input.Image.o_image) | Output socket: Image |

### Index { #nodebpy.nodes.input.Index }

```python
nodes.input.Index()
```

Retrieve an integer value indicating the position of each element in the list, starting at zero

#### Attributes

| Name | Description |
| --- | --- |
| [o_index](#nodebpy.nodes.input.Index.o_index) | Output socket: Index |

### InstanceBounds { #nodebpy.nodes.input.InstanceBounds }

```python
nodes.input.InstanceBounds(use_radius=True)
```

Calculate position bounds of each instance's geometry set

#### Attributes

| Name | Description |
| --- | --- |
| [i_use_radius](#nodebpy.nodes.input.InstanceBounds.i_use_radius) | Input socket: Use Radius |
| [o_max](#nodebpy.nodes.input.InstanceBounds.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.input.InstanceBounds.o_min) | Output socket: Min |

### InstanceRotation { #nodebpy.nodes.input.InstanceRotation }

```python
nodes.input.InstanceRotation()
```

Retrieve the rotation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.InstanceRotation.o_rotation) | Output socket: Rotation |

### InstanceScale { #nodebpy.nodes.input.InstanceScale }

```python
nodes.input.InstanceScale()
```

Retrieve the scale of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_scale](#nodebpy.nodes.input.InstanceScale.o_scale) | Output socket: Scale |

### Integer { #nodebpy.nodes.input.Integer }

```python
nodes.input.Integer(integer=1)
```

Provide an integer value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_integer](#nodebpy.nodes.input.Integer.o_integer) | Output socket: Integer |

### IsEdgeSmooth { #nodebpy.nodes.input.IsEdgeSmooth }

```python
nodes.input.IsEdgeSmooth()
```

Retrieve whether each edge is marked for smooth or split normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsEdgeSmooth.o_smooth) | Output socket: Smooth |

### IsFaceSmooth { #nodebpy.nodes.input.IsFaceSmooth }

```python
nodes.input.IsFaceSmooth()
```

Retrieve whether each face is marked for smooth or sharp normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsFaceSmooth.o_smooth) | Output socket: Smooth |

### IsSplineCyclic { #nodebpy.nodes.input.IsSplineCyclic }

```python
nodes.input.IsSplineCyclic()
```

Retrieve whether each spline endpoint connects to the beginning

#### Attributes

| Name | Description |
| --- | --- |
| [o_cyclic](#nodebpy.nodes.input.IsSplineCyclic.o_cyclic) | Output socket: Cyclic |

### Material { #nodebpy.nodes.input.Material }

```python
nodes.input.Material(material=None)
```

Output a single material

#### Attributes

| Name | Description |
| --- | --- |
| [material](#nodebpy.nodes.input.Material.material) | Input socket: Material |
| [o_material](#nodebpy.nodes.input.Material.o_material) | Output socket: Material |

### MaterialIndex { #nodebpy.nodes.input.MaterialIndex }

```python
nodes.input.MaterialIndex()
```

Retrieve the index of the material used for each element in the geometry's list of materials

#### Attributes

| Name | Description |
| --- | --- |
| [o_material_index](#nodebpy.nodes.input.MaterialIndex.o_material_index) | Output socket: Material Index |

### NamedLayerSelection { #nodebpy.nodes.input.NamedLayerSelection }

```python
nodes.input.NamedLayerSelection(name='')
```

Output a selection of a Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_name](#nodebpy.nodes.input.NamedLayerSelection.i_name) | Input socket: Name |
| [o_selection](#nodebpy.nodes.input.NamedLayerSelection.o_selection) | Output socket: Selection |

### Normal { #nodebpy.nodes.input.Normal }

```python
nodes.input.Normal()
```

Retrieve a unit length vector indicating the direction pointing away from the geometry at each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_normal](#nodebpy.nodes.input.Normal.o_normal) | Output socket: Normal |
| [o_true_normal](#nodebpy.nodes.input.Normal.o_true_normal) | Output socket: True Normal |

### Object { #nodebpy.nodes.input.Object }

```python
nodes.input.Object(object=None)
```

Output a single object

#### Attributes

| Name | Description |
| --- | --- |
| [o_object](#nodebpy.nodes.input.Object.o_object) | Output socket: Object |

### Position { #nodebpy.nodes.input.Position }

```python
nodes.input.Position()
```

Retrieve a vector indicating the location of each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_position](#nodebpy.nodes.input.Position.o_position) | Output socket: Position |

### Radius { #nodebpy.nodes.input.Radius }

```python
nodes.input.Radius()
```

Retrieve the radius at each point on curve or point cloud geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_radius](#nodebpy.nodes.input.Radius.o_radius) | Output socket: Radius |

### Rotation { #nodebpy.nodes.input.Rotation }

```python
nodes.input.Rotation(rotation_euler=(0, 0, 0))
```

Provide a rotation value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.Rotation.o_rotation) | Output socket: Rotation |

### SceneTime { #nodebpy.nodes.input.SceneTime }

```python
nodes.input.SceneTime()
```

Retrieve the current time in the scene's animation in units of seconds or frames

#### Attributes

| Name | Description |
| --- | --- |
| [o_frame](#nodebpy.nodes.input.SceneTime.o_frame) | Output socket: Frame |
| [o_seconds](#nodebpy.nodes.input.SceneTime.o_seconds) | Output socket: Seconds |

### ShortestEdgePaths { #nodebpy.nodes.input.ShortestEdgePaths }

```python
nodes.input.ShortestEdgePaths(end_vertex=None, edge_cost=None, **kwargs)
```

Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_cost](#nodebpy.nodes.input.ShortestEdgePaths.i_edge_cost) | Input socket: Edge Cost |
| [i_end_vertex](#nodebpy.nodes.input.ShortestEdgePaths.i_end_vertex) | Input socket: End Vertex |
| [o_next_vertex_index](#nodebpy.nodes.input.ShortestEdgePaths.o_next_vertex_index) | Output socket: Next Vertex Index |
| [o_total_cost](#nodebpy.nodes.input.ShortestEdgePaths.o_total_cost) | Output socket: Total Cost |

### SpecialCharacters { #nodebpy.nodes.input.SpecialCharacters }

```python
nodes.input.SpecialCharacters()
```

Output string characters that cannot be typed directly with the keyboard

#### Attributes

| Name | Description |
| --- | --- |
| [o_line_break](#nodebpy.nodes.input.SpecialCharacters.o_line_break) | Output socket: Line Break |
| [o_tab](#nodebpy.nodes.input.SpecialCharacters.o_tab) | Output socket: Tab |

### SplineResolution { #nodebpy.nodes.input.SplineResolution }

```python
nodes.input.SplineResolution()
```

Retrieve the number of evaluated points that will be generated for every control point on curves

#### Attributes

| Name | Description |
| --- | --- |
| [o_resolution](#nodebpy.nodes.input.SplineResolution.o_resolution) | Output socket: Resolution |

### String { #nodebpy.nodes.input.String }

```python
nodes.input.String(string='')
```

Provide a string value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_string](#nodebpy.nodes.input.String.o_string) | Output socket: String |

### Value { #nodebpy.nodes.input.Value }

```python
nodes.input.Value(value=0.0)
```

Input numerical values to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_value](#nodebpy.nodes.input.Value.o_value) | Output socket: Value |
| [value](#nodebpy.nodes.input.Value.value) | Input socket: Value |

### Vector { #nodebpy.nodes.input.Vector }

```python
nodes.input.Vector(vector=(0, 0, 0))
```

Provide a vector value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_vector](#nodebpy.nodes.input.Vector.o_vector) | Output socket: Vector |

### VoxelIndex { #nodebpy.nodes.input.VoxelIndex }

```python
nodes.input.VoxelIndex()
```

Retrieve the integer coordinates of the voxel that the field is evaluated on

#### Attributes

| Name | Description |
| --- | --- |
| [o_extent_x](#nodebpy.nodes.input.VoxelIndex.o_extent_x) | Output socket: Extent X |
| [o_extent_y](#nodebpy.nodes.input.VoxelIndex.o_extent_y) | Output socket: Extent Y |
| [o_extent_z](#nodebpy.nodes.input.VoxelIndex.o_extent_z) | Output socket: Extent Z |
| [o_is_tile](#nodebpy.nodes.input.VoxelIndex.o_is_tile) | Output socket: Is Tile |
| [o_x](#nodebpy.nodes.input.VoxelIndex.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.input.VoxelIndex.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.input.VoxelIndex.o_z) | Output socket: Z |