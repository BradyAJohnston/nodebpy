# nodes.input { #nodebpy.nodes.input }

`nodes.input`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [ActiveCamera](#nodebpy.nodes.input.ActiveCamera) | Retrieve the scene's active camera |
| [Boolean](#nodebpy.nodes.input.Boolean) | Provide a True/False value that can be connected to other nodes in the tree |
| [Collection](#nodebpy.nodes.input.Collection) | Output a single collection |
| [Color](#nodebpy.nodes.input.Color) | Output a color value chosen with the color picker widget |
| [CurveTangent](#nodebpy.nodes.input.CurveTangent) | Retrieve the direction of curves at each control point |
| [ForEachGeometryElementInput](#nodebpy.nodes.input.ForEachGeometryElementInput) | For Each Geometry Element Input node |
| [ID](#nodebpy.nodes.input.ID) | Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist |
| [Image](#nodebpy.nodes.input.Image) | Input an image data-block |
| [Index](#nodebpy.nodes.input.Index) | Retrieve an integer value indicating the position of each element in the list, starting at zero |
| [InstanceBounds](#nodebpy.nodes.input.InstanceBounds) | Calculate position bounds of each instance's geometry set |
| [InstanceRotation](#nodebpy.nodes.input.InstanceRotation) | Retrieve the rotation of each instance in the geometry |
| [InstanceScale](#nodebpy.nodes.input.InstanceScale) | Retrieve the scale of each instance in the geometry |
| [Integer](#nodebpy.nodes.input.Integer) | Provide an integer value that can be connected to other nodes in the tree |
| [IsEdgeSmooth](#nodebpy.nodes.input.IsEdgeSmooth) | Retrieve whether each edge is marked for smooth or split normals |
| [IsFaceSmooth](#nodebpy.nodes.input.IsFaceSmooth) | Retrieve whether each face is marked for smooth or sharp normals |
| [IsSplineCyclic](#nodebpy.nodes.input.IsSplineCyclic) | Retrieve whether each spline endpoint connects to the beginning |
| [Material](#nodebpy.nodes.input.Material) | Output a single material |
| [MaterialIndex](#nodebpy.nodes.input.MaterialIndex) | Retrieve the index of the material used for each element in the geometry's list of materials |
| [NamedLayerSelection](#nodebpy.nodes.input.NamedLayerSelection) | Output a selection of a Grease Pencil layer |
| [Normal](#nodebpy.nodes.input.Normal) | Retrieve a unit length vector indicating the direction pointing away from the geometry at each element |
| [Object](#nodebpy.nodes.input.Object) | Output a single object |
| [Position](#nodebpy.nodes.input.Position) | Retrieve a vector indicating the location of each element |
| [Radius](#nodebpy.nodes.input.Radius) | Retrieve the radius at each point on curve or point cloud geometry |
| [Rotation](#nodebpy.nodes.input.Rotation) | Provide a rotation value that can be connected to other nodes in the tree |
| [SceneTime](#nodebpy.nodes.input.SceneTime) | Retrieve the current time in the scene's animation in units of seconds or frames |
| [ShortestEdgePaths](#nodebpy.nodes.input.ShortestEdgePaths) | Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge |
| [SpecialCharacters](#nodebpy.nodes.input.SpecialCharacters) | Output string characters that cannot be typed directly with the keyboard |
| [SplineResolution](#nodebpy.nodes.input.SplineResolution) | Retrieve the number of evaluated points that will be generated for every control point on curves |
| [String](#nodebpy.nodes.input.String) | Provide a string value that can be connected to other nodes in the tree |
| [Value](#nodebpy.nodes.input.Value) | Input numerical values to other nodes in the tree |
| [VoxelIndex](#nodebpy.nodes.input.VoxelIndex) | Retrieve the integer coordinates of the voxel that the field is evaluated on |

### ActiveCamera { #nodebpy.nodes.input.ActiveCamera }

```python
nodes.input.ActiveCamera(**kwargs)
```

Retrieve the scene's active camera

#### Attributes

| Name | Description |
| --- | --- |
| [o_active_camera](#nodebpy.nodes.input.ActiveCamera.o_active_camera) | Output socket: Active Camera |

### Boolean { #nodebpy.nodes.input.Boolean }

```python
nodes.input.Boolean(boolean=False, **kwargs)
```

Provide a True/False value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_boolean](#nodebpy.nodes.input.Boolean.o_boolean) | Output socket: Boolean |

### Collection { #nodebpy.nodes.input.Collection }

```python
nodes.input.Collection(**kwargs)
```

Output a single collection

#### Attributes

| Name | Description |
| --- | --- |
| [o_collection](#nodebpy.nodes.input.Collection.o_collection) | Output socket: Collection |

### Color { #nodebpy.nodes.input.Color }

```python
nodes.input.Color(value=0.0, **kwargs)
```

Output a color value chosen with the color picker widget

#### Attributes

| Name | Description |
| --- | --- |
| [o_color](#nodebpy.nodes.input.Color.o_color) | Output socket: Color |

### CurveTangent { #nodebpy.nodes.input.CurveTangent }

```python
nodes.input.CurveTangent(**kwargs)
```

Retrieve the direction of curves at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [o_tangent](#nodebpy.nodes.input.CurveTangent.o_tangent) | Output socket: Tangent |

### ForEachGeometryElementInput { #nodebpy.nodes.input.ForEachGeometryElementInput }

```python
nodes.input.ForEachGeometryElementInput(
    geometry=None,
    selection=True,
    extend=None,
    **kwargs,
)
```

For Each Geometry Element Input node

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.input.ForEachGeometryElementInput.i_geometry) | Input socket: Geometry |
| [i_input_socket](#nodebpy.nodes.input.ForEachGeometryElementInput.i_input_socket) | Input socket: |
| [i_selection](#nodebpy.nodes.input.ForEachGeometryElementInput.i_selection) | Input socket: Selection |
| [o_index](#nodebpy.nodes.input.ForEachGeometryElementInput.o_index) | Output socket: Index |
| [o_input_socket](#nodebpy.nodes.input.ForEachGeometryElementInput.o_input_socket) | Output socket: |

### ID { #nodebpy.nodes.input.ID }

```python
nodes.input.ID(**kwargs)
```

Retrieve a stable random identifier value from the "id" attribute on the point domain, or the index if the attribute does not exist

#### Attributes

| Name | Description |
| --- | --- |
| [o_id](#nodebpy.nodes.input.ID.o_id) | Output socket: ID |

### Image { #nodebpy.nodes.input.Image }

```python
nodes.input.Image(**kwargs)
```

Input an image data-block

#### Attributes

| Name | Description |
| --- | --- |
| [o_image](#nodebpy.nodes.input.Image.o_image) | Output socket: Image |

### Index { #nodebpy.nodes.input.Index }

```python
nodes.input.Index(**kwargs)
```

Retrieve an integer value indicating the position of each element in the list, starting at zero

#### Attributes

| Name | Description |
| --- | --- |
| [o_index](#nodebpy.nodes.input.Index.o_index) | Output socket: Index |

### InstanceBounds { #nodebpy.nodes.input.InstanceBounds }

```python
nodes.input.InstanceBounds(use_radius=True, **kwargs)
```

Calculate position bounds of each instance's geometry set

#### Attributes

| Name | Description |
| --- | --- |
| [i_use_radius](#nodebpy.nodes.input.InstanceBounds.i_use_radius) | Input socket: Use Radius |
| [o_max](#nodebpy.nodes.input.InstanceBounds.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.input.InstanceBounds.o_min) | Output socket: Min |

### InstanceRotation { #nodebpy.nodes.input.InstanceRotation }

```python
nodes.input.InstanceRotation(**kwargs)
```

Retrieve the rotation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.InstanceRotation.o_rotation) | Output socket: Rotation |

### InstanceScale { #nodebpy.nodes.input.InstanceScale }

```python
nodes.input.InstanceScale(**kwargs)
```

Retrieve the scale of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_scale](#nodebpy.nodes.input.InstanceScale.o_scale) | Output socket: Scale |

### Integer { #nodebpy.nodes.input.Integer }

```python
nodes.input.Integer(integer=1, **kwargs)
```

Provide an integer value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_integer](#nodebpy.nodes.input.Integer.o_integer) | Output socket: Integer |

### IsEdgeSmooth { #nodebpy.nodes.input.IsEdgeSmooth }

```python
nodes.input.IsEdgeSmooth(**kwargs)
```

Retrieve whether each edge is marked for smooth or split normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsEdgeSmooth.o_smooth) | Output socket: Smooth |

### IsFaceSmooth { #nodebpy.nodes.input.IsFaceSmooth }

```python
nodes.input.IsFaceSmooth(**kwargs)
```

Retrieve whether each face is marked for smooth or sharp normals

#### Attributes

| Name | Description |
| --- | --- |
| [o_smooth](#nodebpy.nodes.input.IsFaceSmooth.o_smooth) | Output socket: Smooth |

### IsSplineCyclic { #nodebpy.nodes.input.IsSplineCyclic }

```python
nodes.input.IsSplineCyclic(**kwargs)
```

Retrieve whether each spline endpoint connects to the beginning

#### Attributes

| Name | Description |
| --- | --- |
| [o_cyclic](#nodebpy.nodes.input.IsSplineCyclic.o_cyclic) | Output socket: Cyclic |

### Material { #nodebpy.nodes.input.Material }

```python
nodes.input.Material(**kwargs)
```

Output a single material

#### Attributes

| Name | Description |
| --- | --- |
| [o_material](#nodebpy.nodes.input.Material.o_material) | Output socket: Material |

### MaterialIndex { #nodebpy.nodes.input.MaterialIndex }

```python
nodes.input.MaterialIndex(**kwargs)
```

Retrieve the index of the material used for each element in the geometry's list of materials

#### Attributes

| Name | Description |
| --- | --- |
| [o_material_index](#nodebpy.nodes.input.MaterialIndex.o_material_index) | Output socket: Material Index |

### NamedLayerSelection { #nodebpy.nodes.input.NamedLayerSelection }

```python
nodes.input.NamedLayerSelection(name='', **kwargs)
```

Output a selection of a Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_name](#nodebpy.nodes.input.NamedLayerSelection.i_name) | Input socket: Name |
| [o_selection](#nodebpy.nodes.input.NamedLayerSelection.o_selection) | Output socket: Selection |

### Normal { #nodebpy.nodes.input.Normal }

```python
nodes.input.Normal(legacy_corner_normals=False, **kwargs)
```

Retrieve a unit length vector indicating the direction pointing away from the geometry at each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_normal](#nodebpy.nodes.input.Normal.o_normal) | Output socket: Normal |
| [o_true_normal](#nodebpy.nodes.input.Normal.o_true_normal) | Output socket: True Normal |

### Object { #nodebpy.nodes.input.Object }

```python
nodes.input.Object(**kwargs)
```

Output a single object

#### Attributes

| Name | Description |
| --- | --- |
| [o_object](#nodebpy.nodes.input.Object.o_object) | Output socket: Object |

### Position { #nodebpy.nodes.input.Position }

```python
nodes.input.Position(**kwargs)
```

Retrieve a vector indicating the location of each element

#### Attributes

| Name | Description |
| --- | --- |
| [o_position](#nodebpy.nodes.input.Position.o_position) | Output socket: Position |

### Radius { #nodebpy.nodes.input.Radius }

```python
nodes.input.Radius(**kwargs)
```

Retrieve the radius at each point on curve or point cloud geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_radius](#nodebpy.nodes.input.Radius.o_radius) | Output socket: Radius |

### Rotation { #nodebpy.nodes.input.Rotation }

```python
nodes.input.Rotation(rotation_euler=0.0, **kwargs)
```

Provide a rotation value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_rotation](#nodebpy.nodes.input.Rotation.o_rotation) | Output socket: Rotation |

### SceneTime { #nodebpy.nodes.input.SceneTime }

```python
nodes.input.SceneTime(**kwargs)
```

Retrieve the current time in the scene's animation in units of seconds or frames

#### Attributes

| Name | Description |
| --- | --- |
| [o_frame](#nodebpy.nodes.input.SceneTime.o_frame) | Output socket: Frame |
| [o_seconds](#nodebpy.nodes.input.SceneTime.o_seconds) | Output socket: Seconds |

### ShortestEdgePaths { #nodebpy.nodes.input.ShortestEdgePaths }

```python
nodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0, **kwargs)
```

Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_cost](#nodebpy.nodes.input.ShortestEdgePaths.i_edge_cost) | Input socket: Edge Cost |
| [i_end_vertex](#nodebpy.nodes.input.ShortestEdgePaths.i_end_vertex) | Input socket: End Vertex |
| [o_next_vertex_index](#nodebpy.nodes.input.ShortestEdgePaths.o_next_vertex_index) | Output socket: Next Vertex Index |
| [o_total_cost](#nodebpy.nodes.input.ShortestEdgePaths.o_total_cost) | Output socket: Total Cost |

### SpecialCharacters { #nodebpy.nodes.input.SpecialCharacters }

```python
nodes.input.SpecialCharacters(**kwargs)
```

Output string characters that cannot be typed directly with the keyboard

#### Attributes

| Name | Description |
| --- | --- |
| [o_line_break](#nodebpy.nodes.input.SpecialCharacters.o_line_break) | Output socket: Line Break |
| [o_tab](#nodebpy.nodes.input.SpecialCharacters.o_tab) | Output socket: Tab |

### SplineResolution { #nodebpy.nodes.input.SplineResolution }

```python
nodes.input.SplineResolution(**kwargs)
```

Retrieve the number of evaluated points that will be generated for every control point on curves

#### Attributes

| Name | Description |
| --- | --- |
| [o_resolution](#nodebpy.nodes.input.SplineResolution.o_resolution) | Output socket: Resolution |

### String { #nodebpy.nodes.input.String }

```python
nodes.input.String(string='', **kwargs)
```

Provide a string value that can be connected to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_string](#nodebpy.nodes.input.String.o_string) | Output socket: String |

### Value { #nodebpy.nodes.input.Value }

```python
nodes.input.Value(**kwargs)
```

Input numerical values to other nodes in the tree

#### Attributes

| Name | Description |
| --- | --- |
| [o_value](#nodebpy.nodes.input.Value.o_value) | Output socket: Value |

### VoxelIndex { #nodebpy.nodes.input.VoxelIndex }

```python
nodes.input.VoxelIndex(**kwargs)
```

Retrieve the integer coordinates of the voxel that the field is evaluated on

#### Attributes

| Name | Description |
| --- | --- |
| [o_extent_x](#nodebpy.nodes.input.VoxelIndex.o_extent_x) | Output socket: Extent X |
| [o_extent_y](#nodebpy.nodes.input.VoxelIndex.o_extent_y) | Output socket: Extent Y |
| [o_extent_z](#nodebpy.nodes.input.VoxelIndex.o_extent_z) | Output socket: Extent Z |
| [o_is_tile](#nodebpy.nodes.input.VoxelIndex.o_is_tile) | Output socket: Is Tile |
| [o_x](#nodebpy.nodes.input.VoxelIndex.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.input.VoxelIndex.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.input.VoxelIndex.o_z) | Output socket: Z |