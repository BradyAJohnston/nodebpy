# nodes.geometry { #nodebpy.nodes.geometry }

`nodes.geometry`



## Classes

| Name | Description |
| --- | --- |
| [Arc](#nodebpy.nodes.geometry.Arc) | Generate a poly spline arc |
| [BezierSegment](#nodebpy.nodes.geometry.BezierSegment) | Generate a 2D Bézier spline from the given control points and handles |
| [BoundingBox](#nodebpy.nodes.geometry.BoundingBox) | Calculate the limits of a geometry's positions and generate a box mesh with those dimensions |
| [Cone](#nodebpy.nodes.geometry.Cone) | Generate a cone mesh |
| [ConvexHull](#nodebpy.nodes.geometry.ConvexHull) | Create a mesh that encloses all points in the input geometry with the smallest number of points |
| [Cube](#nodebpy.nodes.geometry.Cube) | Generate a cuboid mesh with variable side lengths and subdivisions |
| [CurveCircle](#nodebpy.nodes.geometry.CurveCircle) | Generate a poly spline circle |
| [CurveLength](#nodebpy.nodes.geometry.CurveLength) | Retrieve the length of all splines added together |
| [CurveLine](#nodebpy.nodes.geometry.CurveLine) | Generate a poly spline line with two points |
| [CurveToMesh](#nodebpy.nodes.geometry.CurveToMesh) | Convert curves into a mesh, optionally with a custom profile shape defined by curves |
| [CurveToPoints](#nodebpy.nodes.geometry.CurveToPoints) | Generate a point cloud by sampling positions along curves |
| [CurvesToGreasePencil](#nodebpy.nodes.geometry.CurvesToGreasePencil) | Convert the curves in each top-level instance into Grease Pencil layer |
| [Cylinder](#nodebpy.nodes.geometry.Cylinder) | Generate a cylinder mesh |
| [DeformCurvesOnSurface](#nodebpy.nodes.geometry.DeformCurvesOnSurface) | Translate and rotate curves based on changes between the object's original and evaluated surface mesh |
| [DeleteGeometry](#nodebpy.nodes.geometry.DeleteGeometry) | Remove selected elements of a geometry |
| [DistributePointsOnFaces](#nodebpy.nodes.geometry.DistributePointsOnFaces) | Generate points spread out on the surface of a mesh |
| [DualMesh](#nodebpy.nodes.geometry.DualMesh) | Convert Faces into vertices and vertices into faces |
| [DuplicateElements](#nodebpy.nodes.geometry.DuplicateElements) | Generate an arbitrary number copies of each selected input element |
| [EdgePathsToCurves](#nodebpy.nodes.geometry.EdgePathsToCurves) | Output curves following paths across mesh edges |
| [ExtrudeMesh](#nodebpy.nodes.geometry.ExtrudeMesh) | Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary |
| [FillCurve](#nodebpy.nodes.geometry.FillCurve) | Generate a mesh on the XY plane with faces on the inside of input curves |
| [FilletCurve](#nodebpy.nodes.geometry.FilletCurve) | Round corners by generating circular arcs on each control point |
| [FlipFaces](#nodebpy.nodes.geometry.FlipFaces) | Reverse the order of the vertices and edges of selected faces, flipping their normal direction |
| [GeometryProximity](#nodebpy.nodes.geometry.GeometryProximity) | Compute the closest location on the target geometry |
| [GreasePencilToCurves](#nodebpy.nodes.geometry.GreasePencilToCurves) | Convert Grease Pencil layers into curve instances |
| [Grid](#nodebpy.nodes.geometry.Grid) | Generate a planar mesh on the XY plane |
| [IcoSphere](#nodebpy.nodes.geometry.IcoSphere) | Generate a spherical mesh that consists of equally sized triangles |
| [InstanceOnPoints](#nodebpy.nodes.geometry.InstanceOnPoints) | Generate a reference to geometry at each of the input points, without duplicating its underlying data |
| [InstancesToPoints](#nodebpy.nodes.geometry.InstancesToPoints) | Generate points at the origins of instances. |
| [InterpolateCurves](#nodebpy.nodes.geometry.InterpolateCurves) | Generate new curves on points by interpolating between existing curves |
| [MaterialSelection](#nodebpy.nodes.geometry.MaterialSelection) | Provide a selection of faces that use the specified material |
| [MergeByDistance](#nodebpy.nodes.geometry.MergeByDistance) | Merge vertices or points within a given distance |
| [MergeLayers](#nodebpy.nodes.geometry.MergeLayers) | Join groups of Grease Pencil layers into one |
| [MeshBoolean](#nodebpy.nodes.geometry.MeshBoolean) | Cut, subtract, or join multiple mesh inputs |
| [MeshCircle](#nodebpy.nodes.geometry.MeshCircle) | Generate a circular ring of edges |
| [MeshLine](#nodebpy.nodes.geometry.MeshLine) | Generate vertices in a line and connect them with edges |
| [MeshToCurve](#nodebpy.nodes.geometry.MeshToCurve) | Generate a curve from a mesh |
| [MeshToPoints](#nodebpy.nodes.geometry.MeshToPoints) | Generate a point cloud from a mesh's vertices |
| [Points](#nodebpy.nodes.geometry.Points) | Generate a point cloud with positions and radii defined by fields |
| [PointsToCurves](#nodebpy.nodes.geometry.PointsToCurves) | Split all points to curve by its group ID and reorder by weight |
| [PointsToVertices](#nodebpy.nodes.geometry.PointsToVertices) | Generate a mesh vertex for each point cloud point |
| [QuadraticBezier](#nodebpy.nodes.geometry.QuadraticBezier) | Generate a poly spline in a parabola shape with control points positions |
| [Quadrilateral](#nodebpy.nodes.geometry.Quadrilateral) | Generate a polygon with four points |
| [Raycast](#nodebpy.nodes.geometry.Raycast) | Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point |
| [RealizeInstances](#nodebpy.nodes.geometry.RealizeInstances) | Convert instances into real geometry data |
| [ReplaceMaterial](#nodebpy.nodes.geometry.ReplaceMaterial) | Swap one material with another |
| [ResampleCurve](#nodebpy.nodes.geometry.ResampleCurve) | Generate a poly spline for each input spline |
| [ReverseCurve](#nodebpy.nodes.geometry.ReverseCurve) | Change the direction of curves by swapping their start and end data |
| [RotateInstances](#nodebpy.nodes.geometry.RotateInstances) | Rotate geometry instances in local or global space |
| [SampleCurve](#nodebpy.nodes.geometry.SampleCurve) | Retrieve data from a point on a curve at a certain distance from its start |
| [SampleIndex](#nodebpy.nodes.geometry.SampleIndex) | Retrieve values from specific geometry elements |
| [SampleNearest](#nodebpy.nodes.geometry.SampleNearest) | Find the element of a geometry closest to a position. Similar to the "Index of Nearest" node |
| [SampleNearestSurface](#nodebpy.nodes.geometry.SampleNearestSurface) | Calculate the interpolated value of a mesh attribute on the closest point of its surface |
| [SampleUVSurface](#nodebpy.nodes.geometry.SampleUVSurface) | Calculate the interpolated values of a mesh attribute at a UV coordinate |
| [ScaleElements](#nodebpy.nodes.geometry.ScaleElements) | Scale groups of connected edges and faces |
| [ScaleInstances](#nodebpy.nodes.geometry.ScaleInstances) | Scale geometry instances in local or global space |
| [SeparateComponents](#nodebpy.nodes.geometry.SeparateComponents) | Split a geometry into a separate output for each type of data in the geometry |
| [SeparateGeometry](#nodebpy.nodes.geometry.SeparateGeometry) | Split a geometry into two geometry outputs based on a selection |
| [SetCurveNormal](#nodebpy.nodes.geometry.SetCurveNormal) | Set the evaluation mode for curve normals |
| [SetCurveRadius](#nodebpy.nodes.geometry.SetCurveRadius) | Set the radius of the curve at each control point |
| [SetCurveTilt](#nodebpy.nodes.geometry.SetCurveTilt) | Set the tilt angle at each curve control point |
| [SetFaceSet](#nodebpy.nodes.geometry.SetFaceSet) | Set sculpt face set values for faces |
| [SetGeometryName](#nodebpy.nodes.geometry.SetGeometryName) | Set the name of a geometry for easier debugging |
| [SetGreasePencilColor](#nodebpy.nodes.geometry.SetGreasePencilColor) | Set color and opacity attributes on Grease Pencil geometry |
| [SetGreasePencilDepth](#nodebpy.nodes.geometry.SetGreasePencilDepth) | Set the Grease Pencil depth order to use |
| [SetGreasePencilSoftness](#nodebpy.nodes.geometry.SetGreasePencilSoftness) | Set softness attribute on Grease Pencil geometry |
| [SetHandlePositions](#nodebpy.nodes.geometry.SetHandlePositions) | Set the positions for the handles of Bézier curves |
| [SetID](#nodebpy.nodes.geometry.SetID) | Set the id attribute on the input geometry, mainly used internally for randomizing |
| [SetInstanceTransform](#nodebpy.nodes.geometry.SetInstanceTransform) | Set the transformation matrix of every instance |
| [SetMaterial](#nodebpy.nodes.geometry.SetMaterial) | Assign a material to geometry elements |
| [SetMaterialIndex](#nodebpy.nodes.geometry.SetMaterialIndex) | Set the material index for each selected geometry element |
| [SetMeshNormal](#nodebpy.nodes.geometry.SetMeshNormal) | Store a normal vector for each mesh element |
| [SetPointRadius](#nodebpy.nodes.geometry.SetPointRadius) | Set the display size of point cloud points |
| [SetPosition](#nodebpy.nodes.geometry.SetPosition) | Set the location of each point |
| [SetSelection](#nodebpy.nodes.geometry.SetSelection) | Set selection of the edited geometry, for tool execution |
| [SetShadeSmooth](#nodebpy.nodes.geometry.SetShadeSmooth) | Control the smoothness of mesh normals around each face by changing the "shade smooth" attribute |
| [SetSplineCyclic](#nodebpy.nodes.geometry.SetSplineCyclic) | Control whether each spline loops back on itself by changing the "cyclic" attribute |
| [SetSplineResolution](#nodebpy.nodes.geometry.SetSplineResolution) | Control how many evaluated points should be generated on every curve segment |
| [SetSplineType](#nodebpy.nodes.geometry.SetSplineType) | Change the type of curves |
| [SortElements](#nodebpy.nodes.geometry.SortElements) | Rearrange geometry elements, changing their indices |
| [Spiral](#nodebpy.nodes.geometry.Spiral) | Generate a poly spline in a spiral shape |
| [SplitEdges](#nodebpy.nodes.geometry.SplitEdges) | Duplicate mesh edges and break connections with the surrounding faces |
| [SplitToInstances](#nodebpy.nodes.geometry.SplitToInstances) | Create separate geometries containing the elements from the same group |
| [Star](#nodebpy.nodes.geometry.Star) | Generate a poly spline in a star pattern by connecting alternating points of two circles |
| [StringToCurves](#nodebpy.nodes.geometry.StringToCurves) | Generate a paragraph of text with a specific font, using a curve instance to store each character |
| [SubdivideCurve](#nodebpy.nodes.geometry.SubdivideCurve) | Dividing each curve segment into a specified number of pieces |
| [SubdivideMesh](#nodebpy.nodes.geometry.SubdivideMesh) | Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices |
| [SubdivisionSurface](#nodebpy.nodes.geometry.SubdivisionSurface) | Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method |
| [TransformGeometry](#nodebpy.nodes.geometry.TransformGeometry) | Translate, rotate or scale the geometry |
| [TranslateInstances](#nodebpy.nodes.geometry.TranslateInstances) | Move top-level geometry instances in local or global space |
| [Triangulate](#nodebpy.nodes.geometry.Triangulate) | Convert all faces in a mesh to triangular faces |
| [TrimCurve](#nodebpy.nodes.geometry.TrimCurve) | Shorten curves by removing portions at the start or end |
| [UVSphere](#nodebpy.nodes.geometry.UVSphere) | Generate a spherical mesh with quads, except for triangles at the top and bottom |

### Arc { #nodebpy.nodes.geometry.Arc }

```python
nodes.geometry.Arc(
    resolution=16,
    start=None,
    middle=None,
    end=None,
    radius=1.0,
    start_angle=0.0,
    sweep_angle=5.4978,
    offset_angle=0.0,
    connect_center=False,
    invert_arc=False,
    *,
    mode='RADIUS',
)
```

Generate a poly spline arc

#### Attributes

| Name | Description |
| --- | --- |
| [i_connect_center](#nodebpy.nodes.geometry.Arc.i_connect_center) | Input socket: Connect Center |
| [i_end](#nodebpy.nodes.geometry.Arc.i_end) | Input socket: End |
| [i_invert_arc](#nodebpy.nodes.geometry.Arc.i_invert_arc) | Input socket: Invert Arc |
| [i_middle](#nodebpy.nodes.geometry.Arc.i_middle) | Input socket: Middle |
| [i_offset_angle](#nodebpy.nodes.geometry.Arc.i_offset_angle) | Input socket: Offset Angle |
| [i_radius](#nodebpy.nodes.geometry.Arc.i_radius) | Input socket: Radius |
| [i_resolution](#nodebpy.nodes.geometry.Arc.i_resolution) | Input socket: Resolution |
| [i_start](#nodebpy.nodes.geometry.Arc.i_start) | Input socket: Start |
| [i_start_angle](#nodebpy.nodes.geometry.Arc.i_start_angle) | Input socket: Start Angle |
| [i_sweep_angle](#nodebpy.nodes.geometry.Arc.i_sweep_angle) | Input socket: Sweep Angle |
| [mode](#nodebpy.nodes.geometry.Arc.mode) |  |
| [name](#nodebpy.nodes.geometry.Arc.name) |  |
| [node](#nodebpy.nodes.geometry.Arc.node) |  |
| [o_center](#nodebpy.nodes.geometry.Arc.o_center) | Output socket: Center |
| [o_curve](#nodebpy.nodes.geometry.Arc.o_curve) | Output socket: Curve |
| [o_normal](#nodebpy.nodes.geometry.Arc.o_normal) | Output socket: Normal |
| [o_radius](#nodebpy.nodes.geometry.Arc.o_radius) | Output socket: Radius |
| [tree](#nodebpy.nodes.geometry.Arc.tree) |  |
| [type](#nodebpy.nodes.geometry.Arc.type) |  |

### BezierSegment { #nodebpy.nodes.geometry.BezierSegment }

```python
nodes.geometry.BezierSegment(
    resolution=16,
    start=None,
    start_handle=None,
    end_handle=None,
    end=None,
    *,
    mode='POSITION',
)
```

Generate a 2D Bézier spline from the given control points and handles

#### Attributes

| Name | Description |
| --- | --- |
| [i_end](#nodebpy.nodes.geometry.BezierSegment.i_end) | Input socket: End |
| [i_end_handle](#nodebpy.nodes.geometry.BezierSegment.i_end_handle) | Input socket: End Handle |
| [i_resolution](#nodebpy.nodes.geometry.BezierSegment.i_resolution) | Input socket: Resolution |
| [i_start](#nodebpy.nodes.geometry.BezierSegment.i_start) | Input socket: Start |
| [i_start_handle](#nodebpy.nodes.geometry.BezierSegment.i_start_handle) | Input socket: Start Handle |
| [mode](#nodebpy.nodes.geometry.BezierSegment.mode) |  |
| [name](#nodebpy.nodes.geometry.BezierSegment.name) |  |
| [node](#nodebpy.nodes.geometry.BezierSegment.node) |  |
| [o_curve](#nodebpy.nodes.geometry.BezierSegment.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.BezierSegment.tree) |  |
| [type](#nodebpy.nodes.geometry.BezierSegment.type) |  |

### BoundingBox { #nodebpy.nodes.geometry.BoundingBox }

```python
nodes.geometry.BoundingBox(geometry=None, use_radius=True)
```

Calculate the limits of a geometry's positions and generate a box mesh with those dimensions

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.BoundingBox.i_geometry) | Input socket: Geometry |
| [i_use_radius](#nodebpy.nodes.geometry.BoundingBox.i_use_radius) | Input socket: Use Radius |
| [name](#nodebpy.nodes.geometry.BoundingBox.name) |  |
| [node](#nodebpy.nodes.geometry.BoundingBox.node) |  |
| [o_bounding_box](#nodebpy.nodes.geometry.BoundingBox.o_bounding_box) | Output socket: Bounding Box |
| [o_max](#nodebpy.nodes.geometry.BoundingBox.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.geometry.BoundingBox.o_min) | Output socket: Min |
| [tree](#nodebpy.nodes.geometry.BoundingBox.tree) |  |
| [type](#nodebpy.nodes.geometry.BoundingBox.type) |  |

### Cone { #nodebpy.nodes.geometry.Cone }

```python
nodes.geometry.Cone(
    vertices=32,
    side_segments=1,
    fill_segments=1,
    radius_top=0.0,
    radius_bottom=1.0,
    depth=2.0,
    *,
    fill_type='NGON',
)
```

Generate a cone mesh

#### Attributes

| Name | Description |
| --- | --- |
| [fill_type](#nodebpy.nodes.geometry.Cone.fill_type) |  |
| [i_depth](#nodebpy.nodes.geometry.Cone.i_depth) | Input socket: Depth |
| [i_fill_segments](#nodebpy.nodes.geometry.Cone.i_fill_segments) | Input socket: Fill Segments |
| [i_radius_bottom](#nodebpy.nodes.geometry.Cone.i_radius_bottom) | Input socket: Radius Bottom |
| [i_radius_top](#nodebpy.nodes.geometry.Cone.i_radius_top) | Input socket: Radius Top |
| [i_side_segments](#nodebpy.nodes.geometry.Cone.i_side_segments) | Input socket: Side Segments |
| [i_vertices](#nodebpy.nodes.geometry.Cone.i_vertices) | Input socket: Vertices |
| [name](#nodebpy.nodes.geometry.Cone.name) |  |
| [node](#nodebpy.nodes.geometry.Cone.node) |  |
| [o_bottom](#nodebpy.nodes.geometry.Cone.o_bottom) | Output socket: Bottom |
| [o_mesh](#nodebpy.nodes.geometry.Cone.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.geometry.Cone.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.geometry.Cone.o_top) | Output socket: Top |
| [o_uv_map](#nodebpy.nodes.geometry.Cone.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.Cone.tree) |  |
| [type](#nodebpy.nodes.geometry.Cone.type) |  |

### ConvexHull { #nodebpy.nodes.geometry.ConvexHull }

```python
nodes.geometry.ConvexHull(geometry=None)
```

Create a mesh that encloses all points in the input geometry with the smallest number of points

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.ConvexHull.i_geometry) | Input socket: Geometry |
| [name](#nodebpy.nodes.geometry.ConvexHull.name) |  |
| [node](#nodebpy.nodes.geometry.ConvexHull.node) |  |
| [o_convex_hull](#nodebpy.nodes.geometry.ConvexHull.o_convex_hull) | Output socket: Convex Hull |
| [tree](#nodebpy.nodes.geometry.ConvexHull.tree) |  |
| [type](#nodebpy.nodes.geometry.ConvexHull.type) |  |

### Cube { #nodebpy.nodes.geometry.Cube }

```python
nodes.geometry.Cube(size=None, vertices_x=2, vertices_y=2, vertices_z=2)
```

Generate a cuboid mesh with variable side lengths and subdivisions

#### Attributes

| Name | Description |
| --- | --- |
| [i_size](#nodebpy.nodes.geometry.Cube.i_size) | Input socket: Size |
| [i_vertices_x](#nodebpy.nodes.geometry.Cube.i_vertices_x) | Input socket: Vertices X |
| [i_vertices_y](#nodebpy.nodes.geometry.Cube.i_vertices_y) | Input socket: Vertices Y |
| [i_vertices_z](#nodebpy.nodes.geometry.Cube.i_vertices_z) | Input socket: Vertices Z |
| [name](#nodebpy.nodes.geometry.Cube.name) |  |
| [node](#nodebpy.nodes.geometry.Cube.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.Cube.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.geometry.Cube.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.Cube.tree) |  |
| [type](#nodebpy.nodes.geometry.Cube.type) |  |

### CurveCircle { #nodebpy.nodes.geometry.CurveCircle }

```python
nodes.geometry.CurveCircle(
    resolution=32,
    point_1=None,
    point_2=None,
    point_3=None,
    radius=1.0,
    *,
    mode='RADIUS',
)
```

Generate a poly spline circle

#### Attributes

| Name | Description |
| --- | --- |
| [i_point_1](#nodebpy.nodes.geometry.CurveCircle.i_point_1) | Input socket: Point 1 |
| [i_point_2](#nodebpy.nodes.geometry.CurveCircle.i_point_2) | Input socket: Point 2 |
| [i_point_3](#nodebpy.nodes.geometry.CurveCircle.i_point_3) | Input socket: Point 3 |
| [i_radius](#nodebpy.nodes.geometry.CurveCircle.i_radius) | Input socket: Radius |
| [i_resolution](#nodebpy.nodes.geometry.CurveCircle.i_resolution) | Input socket: Resolution |
| [mode](#nodebpy.nodes.geometry.CurveCircle.mode) |  |
| [name](#nodebpy.nodes.geometry.CurveCircle.name) |  |
| [node](#nodebpy.nodes.geometry.CurveCircle.node) |  |
| [o_center](#nodebpy.nodes.geometry.CurveCircle.o_center) | Output socket: Center |
| [o_curve](#nodebpy.nodes.geometry.CurveCircle.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.CurveCircle.tree) |  |
| [type](#nodebpy.nodes.geometry.CurveCircle.type) |  |

### CurveLength { #nodebpy.nodes.geometry.CurveLength }

```python
nodes.geometry.CurveLength(curve=None)
```

Retrieve the length of all splines added together

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.CurveLength.i_curve) | Input socket: Curve |
| [name](#nodebpy.nodes.geometry.CurveLength.name) |  |
| [node](#nodebpy.nodes.geometry.CurveLength.node) |  |
| [o_length](#nodebpy.nodes.geometry.CurveLength.o_length) | Output socket: Length |
| [tree](#nodebpy.nodes.geometry.CurveLength.tree) |  |
| [type](#nodebpy.nodes.geometry.CurveLength.type) |  |

### CurveLine { #nodebpy.nodes.geometry.CurveLine }

```python
nodes.geometry.CurveLine(
    start=None,
    end=None,
    direction=None,
    length=1.0,
    *,
    mode='POINTS',
)
```

Generate a poly spline line with two points

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.geometry.CurveLine.i_direction) | Input socket: Direction |
| [i_end](#nodebpy.nodes.geometry.CurveLine.i_end) | Input socket: End |
| [i_length](#nodebpy.nodes.geometry.CurveLine.i_length) | Input socket: Length |
| [i_start](#nodebpy.nodes.geometry.CurveLine.i_start) | Input socket: Start |
| [mode](#nodebpy.nodes.geometry.CurveLine.mode) |  |
| [name](#nodebpy.nodes.geometry.CurveLine.name) |  |
| [node](#nodebpy.nodes.geometry.CurveLine.node) |  |
| [o_curve](#nodebpy.nodes.geometry.CurveLine.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.CurveLine.tree) |  |
| [type](#nodebpy.nodes.geometry.CurveLine.type) |  |

### CurveToMesh { #nodebpy.nodes.geometry.CurveToMesh }

```python
nodes.geometry.CurveToMesh(
    curve=None,
    profile_curve=None,
    scale=1.0,
    fill_caps=False,
)
```

Convert curves into a mesh, optionally with a custom profile shape defined by curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.CurveToMesh.i_curve) | Input socket: Curve |
| [i_fill_caps](#nodebpy.nodes.geometry.CurveToMesh.i_fill_caps) | Input socket: Fill Caps |
| [i_profile_curve](#nodebpy.nodes.geometry.CurveToMesh.i_profile_curve) | Input socket: Profile Curve |
| [i_scale](#nodebpy.nodes.geometry.CurveToMesh.i_scale) | Input socket: Scale |
| [name](#nodebpy.nodes.geometry.CurveToMesh.name) |  |
| [node](#nodebpy.nodes.geometry.CurveToMesh.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.CurveToMesh.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.CurveToMesh.tree) |  |
| [type](#nodebpy.nodes.geometry.CurveToMesh.type) |  |

### CurveToPoints { #nodebpy.nodes.geometry.CurveToPoints }

```python
nodes.geometry.CurveToPoints(curve=None, count=10, length=0.1, *, mode='COUNT')
```

Generate a point cloud by sampling positions along curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.CurveToPoints.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.geometry.CurveToPoints.i_curve) | Input socket: Curve |
| [i_length](#nodebpy.nodes.geometry.CurveToPoints.i_length) | Input socket: Length |
| [mode](#nodebpy.nodes.geometry.CurveToPoints.mode) |  |
| [name](#nodebpy.nodes.geometry.CurveToPoints.name) |  |
| [node](#nodebpy.nodes.geometry.CurveToPoints.node) |  |
| [o_normal](#nodebpy.nodes.geometry.CurveToPoints.o_normal) | Output socket: Normal |
| [o_points](#nodebpy.nodes.geometry.CurveToPoints.o_points) | Output socket: Points |
| [o_rotation](#nodebpy.nodes.geometry.CurveToPoints.o_rotation) | Output socket: Rotation |
| [o_tangent](#nodebpy.nodes.geometry.CurveToPoints.o_tangent) | Output socket: Tangent |
| [tree](#nodebpy.nodes.geometry.CurveToPoints.tree) |  |
| [type](#nodebpy.nodes.geometry.CurveToPoints.type) |  |

### CurvesToGreasePencil { #nodebpy.nodes.geometry.CurvesToGreasePencil }

```python
nodes.geometry.CurvesToGreasePencil(
    curves=None,
    selection=True,
    instances_as_layers=True,
)
```

Convert the curves in each top-level instance into Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_curves](#nodebpy.nodes.geometry.CurvesToGreasePencil.i_curves) | Input socket: Curves |
| [i_instances_as_layers](#nodebpy.nodes.geometry.CurvesToGreasePencil.i_instances_as_layers) | Input socket: Instances as Layers |
| [i_selection](#nodebpy.nodes.geometry.CurvesToGreasePencil.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.CurvesToGreasePencil.name) |  |
| [node](#nodebpy.nodes.geometry.CurvesToGreasePencil.node) |  |
| [o_grease_pencil](#nodebpy.nodes.geometry.CurvesToGreasePencil.o_grease_pencil) | Output socket: Grease Pencil |
| [tree](#nodebpy.nodes.geometry.CurvesToGreasePencil.tree) |  |
| [type](#nodebpy.nodes.geometry.CurvesToGreasePencil.type) |  |

### Cylinder { #nodebpy.nodes.geometry.Cylinder }

```python
nodes.geometry.Cylinder(
    vertices=32,
    side_segments=1,
    fill_segments=1,
    radius=1.0,
    depth=2.0,
    *,
    fill_type='NGON',
)
```

Generate a cylinder mesh

#### Attributes

| Name | Description |
| --- | --- |
| [fill_type](#nodebpy.nodes.geometry.Cylinder.fill_type) |  |
| [i_depth](#nodebpy.nodes.geometry.Cylinder.i_depth) | Input socket: Depth |
| [i_fill_segments](#nodebpy.nodes.geometry.Cylinder.i_fill_segments) | Input socket: Fill Segments |
| [i_radius](#nodebpy.nodes.geometry.Cylinder.i_radius) | Input socket: Radius |
| [i_side_segments](#nodebpy.nodes.geometry.Cylinder.i_side_segments) | Input socket: Side Segments |
| [i_vertices](#nodebpy.nodes.geometry.Cylinder.i_vertices) | Input socket: Vertices |
| [name](#nodebpy.nodes.geometry.Cylinder.name) |  |
| [node](#nodebpy.nodes.geometry.Cylinder.node) |  |
| [o_bottom](#nodebpy.nodes.geometry.Cylinder.o_bottom) | Output socket: Bottom |
| [o_mesh](#nodebpy.nodes.geometry.Cylinder.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.geometry.Cylinder.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.geometry.Cylinder.o_top) | Output socket: Top |
| [o_uv_map](#nodebpy.nodes.geometry.Cylinder.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.Cylinder.tree) |  |
| [type](#nodebpy.nodes.geometry.Cylinder.type) |  |

### DeformCurvesOnSurface { #nodebpy.nodes.geometry.DeformCurvesOnSurface }

```python
nodes.geometry.DeformCurvesOnSurface(curves=None)
```

Translate and rotate curves based on changes between the object's original and evaluated surface mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_curves](#nodebpy.nodes.geometry.DeformCurvesOnSurface.i_curves) | Input socket: Curves |
| [name](#nodebpy.nodes.geometry.DeformCurvesOnSurface.name) |  |
| [node](#nodebpy.nodes.geometry.DeformCurvesOnSurface.node) |  |
| [o_curves](#nodebpy.nodes.geometry.DeformCurvesOnSurface.o_curves) | Output socket: Curves |
| [tree](#nodebpy.nodes.geometry.DeformCurvesOnSurface.tree) |  |
| [type](#nodebpy.nodes.geometry.DeformCurvesOnSurface.type) |  |

### DeleteGeometry { #nodebpy.nodes.geometry.DeleteGeometry }

```python
nodes.geometry.DeleteGeometry(
    geometry=None,
    selection=True,
    *,
    mode='ALL',
    domain='POINT',
)
```

Remove selected elements of a geometry

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.DeleteGeometry.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.DeleteGeometry.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.DeleteGeometry.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.DeleteGeometry.mode) |  |
| [name](#nodebpy.nodes.geometry.DeleteGeometry.name) |  |
| [node](#nodebpy.nodes.geometry.DeleteGeometry.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.DeleteGeometry.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.DeleteGeometry.tree) |  |
| [type](#nodebpy.nodes.geometry.DeleteGeometry.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.DeleteGeometry.edge) | Create Delete Geometry with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.DeleteGeometry.face) | Create Delete Geometry with operation 'Face'. |
| [instance](#nodebpy.nodes.geometry.DeleteGeometry.instance) | Create Delete Geometry with operation 'Instance'. |
| [layer](#nodebpy.nodes.geometry.DeleteGeometry.layer) | Create Delete Geometry with operation 'Layer'. |
| [point](#nodebpy.nodes.geometry.DeleteGeometry.point) | Create Delete Geometry with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.DeleteGeometry.spline) | Create Delete Geometry with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.DeleteGeometry.edge }

```python
nodes.geometry.DeleteGeometry.edge(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.DeleteGeometry.face }

```python
nodes.geometry.DeleteGeometry.face(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Face'.

##### instance { #nodebpy.nodes.geometry.DeleteGeometry.instance }

```python
nodes.geometry.DeleteGeometry.instance(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Instance'.

##### layer { #nodebpy.nodes.geometry.DeleteGeometry.layer }

```python
nodes.geometry.DeleteGeometry.layer(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Layer'.

##### point { #nodebpy.nodes.geometry.DeleteGeometry.point }

```python
nodes.geometry.DeleteGeometry.point(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.DeleteGeometry.spline }

```python
nodes.geometry.DeleteGeometry.spline(geometry=None, selection=True)
```

Create Delete Geometry with operation 'Spline'.

### DistributePointsOnFaces { #nodebpy.nodes.geometry.DistributePointsOnFaces }

```python
nodes.geometry.DistributePointsOnFaces(
    mesh=None,
    selection=True,
    distance_min=0.0,
    density_max=10.0,
    density=10.0,
    density_factor=1.0,
    seed=0,
    *,
    distribute_method='RANDOM',
    use_legacy_normal=False,
)
```

Generate points spread out on the surface of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [distribute_method](#nodebpy.nodes.geometry.DistributePointsOnFaces.distribute_method) |  |
| [i_density](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_density) | Input socket: Density |
| [i_density_factor](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_density_factor) | Input socket: Density Factor |
| [i_density_max](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_density_max) | Input socket: Density Max |
| [i_distance_min](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_distance_min) | Input socket: Distance Min |
| [i_mesh](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_mesh) | Input socket: Mesh |
| [i_seed](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_seed) | Input socket: Seed |
| [i_selection](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.DistributePointsOnFaces.name) |  |
| [node](#nodebpy.nodes.geometry.DistributePointsOnFaces.node) |  |
| [o_normal](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_normal) | Output socket: Normal |
| [o_points](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_points) | Output socket: Points |
| [o_rotation](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.geometry.DistributePointsOnFaces.tree) |  |
| [type](#nodebpy.nodes.geometry.DistributePointsOnFaces.type) |  |
| [use_legacy_normal](#nodebpy.nodes.geometry.DistributePointsOnFaces.use_legacy_normal) |  |

### DualMesh { #nodebpy.nodes.geometry.DualMesh }

```python
nodes.geometry.DualMesh(mesh=None, keep_boundaries=False)
```

Convert Faces into vertices and vertices into faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_keep_boundaries](#nodebpy.nodes.geometry.DualMesh.i_keep_boundaries) | Input socket: Keep Boundaries |
| [i_mesh](#nodebpy.nodes.geometry.DualMesh.i_mesh) | Input socket: Mesh |
| [name](#nodebpy.nodes.geometry.DualMesh.name) |  |
| [node](#nodebpy.nodes.geometry.DualMesh.node) |  |
| [o_dual_mesh](#nodebpy.nodes.geometry.DualMesh.o_dual_mesh) | Output socket: Dual Mesh |
| [tree](#nodebpy.nodes.geometry.DualMesh.tree) |  |
| [type](#nodebpy.nodes.geometry.DualMesh.type) |  |

### DuplicateElements { #nodebpy.nodes.geometry.DuplicateElements }

```python
nodes.geometry.DuplicateElements(
    geometry=None,
    selection=True,
    amount=1,
    *,
    domain='POINT',
)
```

Generate an arbitrary number copies of each selected input element

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.DuplicateElements.domain) |  |
| [i_amount](#nodebpy.nodes.geometry.DuplicateElements.i_amount) | Input socket: Amount |
| [i_geometry](#nodebpy.nodes.geometry.DuplicateElements.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.DuplicateElements.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.DuplicateElements.name) |  |
| [node](#nodebpy.nodes.geometry.DuplicateElements.node) |  |
| [o_duplicate_index](#nodebpy.nodes.geometry.DuplicateElements.o_duplicate_index) | Output socket: Duplicate Index |
| [o_geometry](#nodebpy.nodes.geometry.DuplicateElements.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.DuplicateElements.tree) |  |
| [type](#nodebpy.nodes.geometry.DuplicateElements.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.DuplicateElements.edge) | Create Duplicate Elements with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.DuplicateElements.face) | Create Duplicate Elements with operation 'Face'. |
| [instance](#nodebpy.nodes.geometry.DuplicateElements.instance) | Create Duplicate Elements with operation 'Instance'. |
| [layer](#nodebpy.nodes.geometry.DuplicateElements.layer) | Create Duplicate Elements with operation 'Layer'. |
| [point](#nodebpy.nodes.geometry.DuplicateElements.point) | Create Duplicate Elements with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.DuplicateElements.spline) | Create Duplicate Elements with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.DuplicateElements.edge }

```python
nodes.geometry.DuplicateElements.edge(geometry=None, selection=True, amount=1)
```

Create Duplicate Elements with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.DuplicateElements.face }

```python
nodes.geometry.DuplicateElements.face(geometry=None, selection=True, amount=1)
```

Create Duplicate Elements with operation 'Face'.

##### instance { #nodebpy.nodes.geometry.DuplicateElements.instance }

```python
nodes.geometry.DuplicateElements.instance(
    geometry=None,
    selection=True,
    amount=1,
)
```

Create Duplicate Elements with operation 'Instance'.

##### layer { #nodebpy.nodes.geometry.DuplicateElements.layer }

```python
nodes.geometry.DuplicateElements.layer(geometry=None, selection=True, amount=1)
```

Create Duplicate Elements with operation 'Layer'.

##### point { #nodebpy.nodes.geometry.DuplicateElements.point }

```python
nodes.geometry.DuplicateElements.point(geometry=None, selection=True, amount=1)
```

Create Duplicate Elements with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.DuplicateElements.spline }

```python
nodes.geometry.DuplicateElements.spline(geometry=None, selection=True, amount=1)
```

Create Duplicate Elements with operation 'Spline'.

### EdgePathsToCurves { #nodebpy.nodes.geometry.EdgePathsToCurves }

```python
nodes.geometry.EdgePathsToCurves(
    mesh=None,
    start_vertices=True,
    next_vertex_index=-1,
)
```

Output curves following paths across mesh edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.EdgePathsToCurves.i_mesh) | Input socket: Mesh |
| [i_next_vertex_index](#nodebpy.nodes.geometry.EdgePathsToCurves.i_next_vertex_index) | Input socket: Next Vertex Index |
| [i_start_vertices](#nodebpy.nodes.geometry.EdgePathsToCurves.i_start_vertices) | Input socket: Start Vertices |
| [name](#nodebpy.nodes.geometry.EdgePathsToCurves.name) |  |
| [node](#nodebpy.nodes.geometry.EdgePathsToCurves.node) |  |
| [o_curves](#nodebpy.nodes.geometry.EdgePathsToCurves.o_curves) | Output socket: Curves |
| [tree](#nodebpy.nodes.geometry.EdgePathsToCurves.tree) |  |
| [type](#nodebpy.nodes.geometry.EdgePathsToCurves.type) |  |

### ExtrudeMesh { #nodebpy.nodes.geometry.ExtrudeMesh }

```python
nodes.geometry.ExtrudeMesh(
    mesh=None,
    selection=True,
    offset=None,
    offset_scale=1.0,
    individual=True,
    *,
    mode='FACES',
)
```

Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary

#### Attributes

| Name | Description |
| --- | --- |
| [i_individual](#nodebpy.nodes.geometry.ExtrudeMesh.i_individual) | Input socket: Individual |
| [i_mesh](#nodebpy.nodes.geometry.ExtrudeMesh.i_mesh) | Input socket: Mesh |
| [i_offset](#nodebpy.nodes.geometry.ExtrudeMesh.i_offset) | Input socket: Offset |
| [i_offset_scale](#nodebpy.nodes.geometry.ExtrudeMesh.i_offset_scale) | Input socket: Offset Scale |
| [i_selection](#nodebpy.nodes.geometry.ExtrudeMesh.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.ExtrudeMesh.mode) |  |
| [name](#nodebpy.nodes.geometry.ExtrudeMesh.name) |  |
| [node](#nodebpy.nodes.geometry.ExtrudeMesh.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.ExtrudeMesh.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.geometry.ExtrudeMesh.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.geometry.ExtrudeMesh.o_top) | Output socket: Top |
| [tree](#nodebpy.nodes.geometry.ExtrudeMesh.tree) |  |
| [type](#nodebpy.nodes.geometry.ExtrudeMesh.type) |  |

### FillCurve { #nodebpy.nodes.geometry.FillCurve }

```python
nodes.geometry.FillCurve(curve=None, group_id=0, mode='Triangles')
```

Generate a mesh on the XY plane with faces on the inside of input curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.FillCurve.i_curve) | Input socket: Curve |
| [i_group_id](#nodebpy.nodes.geometry.FillCurve.i_group_id) | Input socket: Group ID |
| [i_mode](#nodebpy.nodes.geometry.FillCurve.i_mode) | Input socket: Mode |
| [name](#nodebpy.nodes.geometry.FillCurve.name) |  |
| [node](#nodebpy.nodes.geometry.FillCurve.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.FillCurve.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.FillCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.FillCurve.type) |  |

### FilletCurve { #nodebpy.nodes.geometry.FilletCurve }

```python
nodes.geometry.FilletCurve(
    curve=None,
    radius=0.25,
    limit_radius=False,
    mode='Bézier',
    count=1,
)
```

Round corners by generating circular arcs on each control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.FilletCurve.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.geometry.FilletCurve.i_curve) | Input socket: Curve |
| [i_limit_radius](#nodebpy.nodes.geometry.FilletCurve.i_limit_radius) | Input socket: Limit Radius |
| [i_mode](#nodebpy.nodes.geometry.FilletCurve.i_mode) | Input socket: Mode |
| [i_radius](#nodebpy.nodes.geometry.FilletCurve.i_radius) | Input socket: Radius |
| [name](#nodebpy.nodes.geometry.FilletCurve.name) |  |
| [node](#nodebpy.nodes.geometry.FilletCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.FilletCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.FilletCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.FilletCurve.type) |  |

### FlipFaces { #nodebpy.nodes.geometry.FlipFaces }

```python
nodes.geometry.FlipFaces(mesh=None, selection=True)
```

Reverse the order of the vertices and edges of selected faces, flipping their normal direction

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.FlipFaces.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.FlipFaces.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.FlipFaces.name) |  |
| [node](#nodebpy.nodes.geometry.FlipFaces.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.FlipFaces.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.FlipFaces.tree) |  |
| [type](#nodebpy.nodes.geometry.FlipFaces.type) |  |

### GeometryProximity { #nodebpy.nodes.geometry.GeometryProximity }

```python
nodes.geometry.GeometryProximity(
    target=None,
    group_id=0,
    source_position=None,
    sample_group_id=0,
    *,
    target_element='FACES',
)
```

Compute the closest location on the target geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.GeometryProximity.i_group_id) | Input socket: Group ID |
| [i_sample_group_id](#nodebpy.nodes.geometry.GeometryProximity.i_sample_group_id) | Input socket: Sample Group ID |
| [i_source_position](#nodebpy.nodes.geometry.GeometryProximity.i_source_position) | Input socket: Sample Position |
| [i_target](#nodebpy.nodes.geometry.GeometryProximity.i_target) | Input socket: Geometry |
| [name](#nodebpy.nodes.geometry.GeometryProximity.name) |  |
| [node](#nodebpy.nodes.geometry.GeometryProximity.node) |  |
| [o_distance](#nodebpy.nodes.geometry.GeometryProximity.o_distance) | Output socket: Distance |
| [o_is_valid](#nodebpy.nodes.geometry.GeometryProximity.o_is_valid) | Output socket: Is Valid |
| [o_position](#nodebpy.nodes.geometry.GeometryProximity.o_position) | Output socket: Position |
| [target_element](#nodebpy.nodes.geometry.GeometryProximity.target_element) |  |
| [tree](#nodebpy.nodes.geometry.GeometryProximity.tree) |  |
| [type](#nodebpy.nodes.geometry.GeometryProximity.type) |  |

### GreasePencilToCurves { #nodebpy.nodes.geometry.GreasePencilToCurves }

```python
nodes.geometry.GreasePencilToCurves(
    grease_pencil=None,
    selection=True,
    layers_as_instances=True,
)
```

Convert Grease Pencil layers into curve instances

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.GreasePencilToCurves.i_grease_pencil) | Input socket: Grease Pencil |
| [i_layers_as_instances](#nodebpy.nodes.geometry.GreasePencilToCurves.i_layers_as_instances) | Input socket: Layers as Instances |
| [i_selection](#nodebpy.nodes.geometry.GreasePencilToCurves.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.GreasePencilToCurves.name) |  |
| [node](#nodebpy.nodes.geometry.GreasePencilToCurves.node) |  |
| [o_curves](#nodebpy.nodes.geometry.GreasePencilToCurves.o_curves) | Output socket: Curves |
| [tree](#nodebpy.nodes.geometry.GreasePencilToCurves.tree) |  |
| [type](#nodebpy.nodes.geometry.GreasePencilToCurves.type) |  |

### Grid { #nodebpy.nodes.geometry.Grid }

```python
nodes.geometry.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3)
```

Generate a planar mesh on the XY plane

#### Attributes

| Name | Description |
| --- | --- |
| [i_size_x](#nodebpy.nodes.geometry.Grid.i_size_x) | Input socket: Size X |
| [i_size_y](#nodebpy.nodes.geometry.Grid.i_size_y) | Input socket: Size Y |
| [i_vertices_x](#nodebpy.nodes.geometry.Grid.i_vertices_x) | Input socket: Vertices X |
| [i_vertices_y](#nodebpy.nodes.geometry.Grid.i_vertices_y) | Input socket: Vertices Y |
| [name](#nodebpy.nodes.geometry.Grid.name) |  |
| [node](#nodebpy.nodes.geometry.Grid.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.Grid.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.geometry.Grid.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.Grid.tree) |  |
| [type](#nodebpy.nodes.geometry.Grid.type) |  |

### IcoSphere { #nodebpy.nodes.geometry.IcoSphere }

```python
nodes.geometry.IcoSphere(radius=1.0, subdivisions=1)
```

Generate a spherical mesh that consists of equally sized triangles

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.geometry.IcoSphere.i_radius) | Input socket: Radius |
| [i_subdivisions](#nodebpy.nodes.geometry.IcoSphere.i_subdivisions) | Input socket: Subdivisions |
| [name](#nodebpy.nodes.geometry.IcoSphere.name) |  |
| [node](#nodebpy.nodes.geometry.IcoSphere.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.IcoSphere.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.geometry.IcoSphere.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.IcoSphere.tree) |  |
| [type](#nodebpy.nodes.geometry.IcoSphere.type) |  |

### InstanceOnPoints { #nodebpy.nodes.geometry.InstanceOnPoints }

```python
nodes.geometry.InstanceOnPoints(
    points=None,
    selection=True,
    instance=None,
    pick_instance=False,
    instance_index=0,
    rotation=None,
    scale=None,
)
```

Generate a reference to geometry at each of the input points, without duplicating its underlying data

#### Attributes

| Name | Description |
| --- | --- |
| [i_instance](#nodebpy.nodes.geometry.InstanceOnPoints.i_instance) | Input socket: Instance |
| [i_instance_index](#nodebpy.nodes.geometry.InstanceOnPoints.i_instance_index) | Input socket: Instance Index |
| [i_pick_instance](#nodebpy.nodes.geometry.InstanceOnPoints.i_pick_instance) | Input socket: Pick Instance |
| [i_points](#nodebpy.nodes.geometry.InstanceOnPoints.i_points) | Input socket: Points |
| [i_rotation](#nodebpy.nodes.geometry.InstanceOnPoints.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.geometry.InstanceOnPoints.i_scale) | Input socket: Scale |
| [i_selection](#nodebpy.nodes.geometry.InstanceOnPoints.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.InstanceOnPoints.name) |  |
| [node](#nodebpy.nodes.geometry.InstanceOnPoints.node) |  |
| [o_instances](#nodebpy.nodes.geometry.InstanceOnPoints.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.InstanceOnPoints.tree) |  |
| [type](#nodebpy.nodes.geometry.InstanceOnPoints.type) |  |

### InstancesToPoints { #nodebpy.nodes.geometry.InstancesToPoints }

```python
nodes.geometry.InstancesToPoints(
    instances=None,
    selection=True,
    position=None,
    radius=0.05,
)
```

Generate points at the origins of instances.
Note: Nested instances are not affected by this node

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.InstancesToPoints.i_instances) | Input socket: Instances |
| [i_position](#nodebpy.nodes.geometry.InstancesToPoints.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.InstancesToPoints.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.InstancesToPoints.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.InstancesToPoints.name) |  |
| [node](#nodebpy.nodes.geometry.InstancesToPoints.node) |  |
| [o_points](#nodebpy.nodes.geometry.InstancesToPoints.o_points) | Output socket: Points |
| [tree](#nodebpy.nodes.geometry.InstancesToPoints.tree) |  |
| [type](#nodebpy.nodes.geometry.InstancesToPoints.type) |  |

### InterpolateCurves { #nodebpy.nodes.geometry.InterpolateCurves }

```python
nodes.geometry.InterpolateCurves(
    guide_curves=None,
    guide_up=None,
    guide_group_id=0,
    points=None,
    point_up=None,
    point_group_id=0,
    max_neighbors=4,
)
```

Generate new curves on points by interpolating between existing curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_guide_curves](#nodebpy.nodes.geometry.InterpolateCurves.i_guide_curves) | Input socket: Guide Curves |
| [i_guide_group_id](#nodebpy.nodes.geometry.InterpolateCurves.i_guide_group_id) | Input socket: Guide Group ID |
| [i_guide_up](#nodebpy.nodes.geometry.InterpolateCurves.i_guide_up) | Input socket: Guide Up |
| [i_max_neighbors](#nodebpy.nodes.geometry.InterpolateCurves.i_max_neighbors) | Input socket: Max Neighbors |
| [i_point_group_id](#nodebpy.nodes.geometry.InterpolateCurves.i_point_group_id) | Input socket: Point Group ID |
| [i_point_up](#nodebpy.nodes.geometry.InterpolateCurves.i_point_up) | Input socket: Point Up |
| [i_points](#nodebpy.nodes.geometry.InterpolateCurves.i_points) | Input socket: Points |
| [name](#nodebpy.nodes.geometry.InterpolateCurves.name) |  |
| [node](#nodebpy.nodes.geometry.InterpolateCurves.node) |  |
| [o_closest_index](#nodebpy.nodes.geometry.InterpolateCurves.o_closest_index) | Output socket: Closest Index |
| [o_closest_weight](#nodebpy.nodes.geometry.InterpolateCurves.o_closest_weight) | Output socket: Closest Weight |
| [o_curves](#nodebpy.nodes.geometry.InterpolateCurves.o_curves) | Output socket: Curves |
| [tree](#nodebpy.nodes.geometry.InterpolateCurves.tree) |  |
| [type](#nodebpy.nodes.geometry.InterpolateCurves.type) |  |

### MaterialSelection { #nodebpy.nodes.geometry.MaterialSelection }

```python
nodes.geometry.MaterialSelection(material=None)
```

Provide a selection of faces that use the specified material

#### Attributes

| Name | Description |
| --- | --- |
| [i_material](#nodebpy.nodes.geometry.MaterialSelection.i_material) | Input socket: Material |
| [name](#nodebpy.nodes.geometry.MaterialSelection.name) |  |
| [node](#nodebpy.nodes.geometry.MaterialSelection.node) |  |
| [o_selection](#nodebpy.nodes.geometry.MaterialSelection.o_selection) | Output socket: Selection |
| [tree](#nodebpy.nodes.geometry.MaterialSelection.tree) |  |
| [type](#nodebpy.nodes.geometry.MaterialSelection.type) |  |

### MergeByDistance { #nodebpy.nodes.geometry.MergeByDistance }

```python
nodes.geometry.MergeByDistance(
    geometry=None,
    selection=True,
    mode='All',
    distance=0.001,
)
```

Merge vertices or points within a given distance

#### Attributes

| Name | Description |
| --- | --- |
| [i_distance](#nodebpy.nodes.geometry.MergeByDistance.i_distance) | Input socket: Distance |
| [i_geometry](#nodebpy.nodes.geometry.MergeByDistance.i_geometry) | Input socket: Geometry |
| [i_mode](#nodebpy.nodes.geometry.MergeByDistance.i_mode) | Input socket: Mode |
| [i_selection](#nodebpy.nodes.geometry.MergeByDistance.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.MergeByDistance.name) |  |
| [node](#nodebpy.nodes.geometry.MergeByDistance.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.MergeByDistance.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.MergeByDistance.tree) |  |
| [type](#nodebpy.nodes.geometry.MergeByDistance.type) |  |

### MergeLayers { #nodebpy.nodes.geometry.MergeLayers }

```python
nodes.geometry.MergeLayers(
    grease_pencil=None,
    selection=True,
    group_id=0,
    *,
    mode='MERGE_BY_NAME',
)
```

Join groups of Grease Pencil layers into one

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.MergeLayers.i_grease_pencil) | Input socket: Grease Pencil |
| [i_group_id](#nodebpy.nodes.geometry.MergeLayers.i_group_id) | Input socket: Group ID |
| [i_selection](#nodebpy.nodes.geometry.MergeLayers.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.MergeLayers.mode) |  |
| [name](#nodebpy.nodes.geometry.MergeLayers.name) |  |
| [node](#nodebpy.nodes.geometry.MergeLayers.node) |  |
| [o_grease_pencil](#nodebpy.nodes.geometry.MergeLayers.o_grease_pencil) | Output socket: Grease Pencil |
| [tree](#nodebpy.nodes.geometry.MergeLayers.tree) |  |
| [type](#nodebpy.nodes.geometry.MergeLayers.type) |  |

### MeshBoolean { #nodebpy.nodes.geometry.MeshBoolean }

```python
nodes.geometry.MeshBoolean(
    mesh_1=None,
    mesh_2=None,
    self_intersection=False,
    hole_tolerant=False,
    *,
    operation='DIFFERENCE',
    solver='FLOAT',
)
```

Cut, subtract, or join multiple mesh inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_hole_tolerant](#nodebpy.nodes.geometry.MeshBoolean.i_hole_tolerant) | Input socket: Hole Tolerant |
| [i_mesh_1](#nodebpy.nodes.geometry.MeshBoolean.i_mesh_1) | Input socket: Mesh 1 |
| [i_mesh_2](#nodebpy.nodes.geometry.MeshBoolean.i_mesh_2) | Input socket: Mesh 2 |
| [i_self_intersection](#nodebpy.nodes.geometry.MeshBoolean.i_self_intersection) | Input socket: Self Intersection |
| [name](#nodebpy.nodes.geometry.MeshBoolean.name) |  |
| [node](#nodebpy.nodes.geometry.MeshBoolean.node) |  |
| [o_intersecting_edges](#nodebpy.nodes.geometry.MeshBoolean.o_intersecting_edges) | Output socket: Intersecting Edges |
| [o_mesh](#nodebpy.nodes.geometry.MeshBoolean.o_mesh) | Output socket: Mesh |
| [operation](#nodebpy.nodes.geometry.MeshBoolean.operation) |  |
| [solver](#nodebpy.nodes.geometry.MeshBoolean.solver) |  |
| [tree](#nodebpy.nodes.geometry.MeshBoolean.tree) |  |
| [type](#nodebpy.nodes.geometry.MeshBoolean.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [difference](#nodebpy.nodes.geometry.MeshBoolean.difference) | Create Mesh Boolean with operation 'Difference'. |
| [intersect](#nodebpy.nodes.geometry.MeshBoolean.intersect) | Create Mesh Boolean with operation 'Intersect'. |
| [union](#nodebpy.nodes.geometry.MeshBoolean.union) | Create Mesh Boolean with operation 'Union'. |

##### difference { #nodebpy.nodes.geometry.MeshBoolean.difference }

```python
nodes.geometry.MeshBoolean.difference(mesh_1=None, mesh_2=None)
```

Create Mesh Boolean with operation 'Difference'.

##### intersect { #nodebpy.nodes.geometry.MeshBoolean.intersect }

```python
nodes.geometry.MeshBoolean.intersect(mesh_2=None)
```

Create Mesh Boolean with operation 'Intersect'.

##### union { #nodebpy.nodes.geometry.MeshBoolean.union }

```python
nodes.geometry.MeshBoolean.union(mesh_2=None)
```

Create Mesh Boolean with operation 'Union'.

### MeshCircle { #nodebpy.nodes.geometry.MeshCircle }

```python
nodes.geometry.MeshCircle(vertices=32, radius=1.0, *, fill_type='NONE')
```

Generate a circular ring of edges

#### Attributes

| Name | Description |
| --- | --- |
| [fill_type](#nodebpy.nodes.geometry.MeshCircle.fill_type) |  |
| [i_radius](#nodebpy.nodes.geometry.MeshCircle.i_radius) | Input socket: Radius |
| [i_vertices](#nodebpy.nodes.geometry.MeshCircle.i_vertices) | Input socket: Vertices |
| [name](#nodebpy.nodes.geometry.MeshCircle.name) |  |
| [node](#nodebpy.nodes.geometry.MeshCircle.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.MeshCircle.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.MeshCircle.tree) |  |
| [type](#nodebpy.nodes.geometry.MeshCircle.type) |  |

### MeshLine { #nodebpy.nodes.geometry.MeshLine }

```python
nodes.geometry.MeshLine(
    count=10,
    resolution=1.0,
    start_location=None,
    offset=None,
    *,
    mode='OFFSET',
    count_mode='TOTAL',
)
```

Generate vertices in a line and connect them with edges

#### Attributes

| Name | Description |
| --- | --- |
| [count_mode](#nodebpy.nodes.geometry.MeshLine.count_mode) |  |
| [i_count](#nodebpy.nodes.geometry.MeshLine.i_count) | Input socket: Count |
| [i_offset](#nodebpy.nodes.geometry.MeshLine.i_offset) | Input socket: Offset |
| [i_resolution](#nodebpy.nodes.geometry.MeshLine.i_resolution) | Input socket: Resolution |
| [i_start_location](#nodebpy.nodes.geometry.MeshLine.i_start_location) | Input socket: Start Location |
| [mode](#nodebpy.nodes.geometry.MeshLine.mode) |  |
| [name](#nodebpy.nodes.geometry.MeshLine.name) |  |
| [node](#nodebpy.nodes.geometry.MeshLine.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.MeshLine.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.MeshLine.tree) |  |
| [type](#nodebpy.nodes.geometry.MeshLine.type) |  |

### MeshToCurve { #nodebpy.nodes.geometry.MeshToCurve }

```python
nodes.geometry.MeshToCurve(mesh=None, selection=True, *, mode='EDGES')
```

Generate a curve from a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.MeshToCurve.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.MeshToCurve.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.MeshToCurve.mode) |  |
| [name](#nodebpy.nodes.geometry.MeshToCurve.name) |  |
| [node](#nodebpy.nodes.geometry.MeshToCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.MeshToCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.MeshToCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.MeshToCurve.type) |  |

### MeshToPoints { #nodebpy.nodes.geometry.MeshToPoints }

```python
nodes.geometry.MeshToPoints(
    mesh=None,
    selection=True,
    position=None,
    radius=0.05,
    *,
    mode='VERTICES',
)
```

Generate a point cloud from a mesh's vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.MeshToPoints.i_mesh) | Input socket: Mesh |
| [i_position](#nodebpy.nodes.geometry.MeshToPoints.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.MeshToPoints.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.MeshToPoints.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.MeshToPoints.mode) |  |
| [name](#nodebpy.nodes.geometry.MeshToPoints.name) |  |
| [node](#nodebpy.nodes.geometry.MeshToPoints.node) |  |
| [o_points](#nodebpy.nodes.geometry.MeshToPoints.o_points) | Output socket: Points |
| [tree](#nodebpy.nodes.geometry.MeshToPoints.tree) |  |
| [type](#nodebpy.nodes.geometry.MeshToPoints.type) |  |

### Points { #nodebpy.nodes.geometry.Points }

```python
nodes.geometry.Points(count=1, position=None, radius=0.1)
```

Generate a point cloud with positions and radii defined by fields

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.Points.i_count) | Input socket: Count |
| [i_position](#nodebpy.nodes.geometry.Points.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.Points.i_radius) | Input socket: Radius |
| [name](#nodebpy.nodes.geometry.Points.name) |  |
| [node](#nodebpy.nodes.geometry.Points.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.Points.o_geometry) | Output socket: Points |
| [tree](#nodebpy.nodes.geometry.Points.tree) |  |
| [type](#nodebpy.nodes.geometry.Points.type) |  |

### PointsToCurves { #nodebpy.nodes.geometry.PointsToCurves }

```python
nodes.geometry.PointsToCurves(points=None, curve_group_id=0, weight=0.0)
```

Split all points to curve by its group ID and reorder by weight

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve_group_id](#nodebpy.nodes.geometry.PointsToCurves.i_curve_group_id) | Input socket: Curve Group ID |
| [i_points](#nodebpy.nodes.geometry.PointsToCurves.i_points) | Input socket: Points |
| [i_weight](#nodebpy.nodes.geometry.PointsToCurves.i_weight) | Input socket: Weight |
| [name](#nodebpy.nodes.geometry.PointsToCurves.name) |  |
| [node](#nodebpy.nodes.geometry.PointsToCurves.node) |  |
| [o_curves](#nodebpy.nodes.geometry.PointsToCurves.o_curves) | Output socket: Curves |
| [tree](#nodebpy.nodes.geometry.PointsToCurves.tree) |  |
| [type](#nodebpy.nodes.geometry.PointsToCurves.type) |  |

### PointsToVertices { #nodebpy.nodes.geometry.PointsToVertices }

```python
nodes.geometry.PointsToVertices(points=None, selection=True)
```

Generate a mesh vertex for each point cloud point

#### Attributes

| Name | Description |
| --- | --- |
| [i_points](#nodebpy.nodes.geometry.PointsToVertices.i_points) | Input socket: Points |
| [i_selection](#nodebpy.nodes.geometry.PointsToVertices.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.PointsToVertices.name) |  |
| [node](#nodebpy.nodes.geometry.PointsToVertices.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.PointsToVertices.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.PointsToVertices.tree) |  |
| [type](#nodebpy.nodes.geometry.PointsToVertices.type) |  |

### QuadraticBezier { #nodebpy.nodes.geometry.QuadraticBezier }

```python
nodes.geometry.QuadraticBezier(resolution=16, start=None, middle=None, end=None)
```

Generate a poly spline in a parabola shape with control points positions

#### Attributes

| Name | Description |
| --- | --- |
| [i_end](#nodebpy.nodes.geometry.QuadraticBezier.i_end) | Input socket: End |
| [i_middle](#nodebpy.nodes.geometry.QuadraticBezier.i_middle) | Input socket: Middle |
| [i_resolution](#nodebpy.nodes.geometry.QuadraticBezier.i_resolution) | Input socket: Resolution |
| [i_start](#nodebpy.nodes.geometry.QuadraticBezier.i_start) | Input socket: Start |
| [name](#nodebpy.nodes.geometry.QuadraticBezier.name) |  |
| [node](#nodebpy.nodes.geometry.QuadraticBezier.node) |  |
| [o_curve](#nodebpy.nodes.geometry.QuadraticBezier.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.QuadraticBezier.tree) |  |
| [type](#nodebpy.nodes.geometry.QuadraticBezier.type) |  |

### Quadrilateral { #nodebpy.nodes.geometry.Quadrilateral }

```python
nodes.geometry.Quadrilateral(
    width=2.0,
    height=2.0,
    bottom_width=4.0,
    top_width=2.0,
    offset=1.0,
    bottom_height=3.0,
    top_height=1.0,
    point_1=None,
    point_2=None,
    point_3=None,
    point_4=None,
    *,
    mode='RECTANGLE',
)
```

Generate a polygon with four points

#### Attributes

| Name | Description |
| --- | --- |
| [i_bottom_height](#nodebpy.nodes.geometry.Quadrilateral.i_bottom_height) | Input socket: Bottom Height |
| [i_bottom_width](#nodebpy.nodes.geometry.Quadrilateral.i_bottom_width) | Input socket: Bottom Width |
| [i_height](#nodebpy.nodes.geometry.Quadrilateral.i_height) | Input socket: Height |
| [i_offset](#nodebpy.nodes.geometry.Quadrilateral.i_offset) | Input socket: Offset |
| [i_point_1](#nodebpy.nodes.geometry.Quadrilateral.i_point_1) | Input socket: Point 1 |
| [i_point_2](#nodebpy.nodes.geometry.Quadrilateral.i_point_2) | Input socket: Point 2 |
| [i_point_3](#nodebpy.nodes.geometry.Quadrilateral.i_point_3) | Input socket: Point 3 |
| [i_point_4](#nodebpy.nodes.geometry.Quadrilateral.i_point_4) | Input socket: Point 4 |
| [i_top_height](#nodebpy.nodes.geometry.Quadrilateral.i_top_height) | Input socket: Top Height |
| [i_top_width](#nodebpy.nodes.geometry.Quadrilateral.i_top_width) | Input socket: Top Width |
| [i_width](#nodebpy.nodes.geometry.Quadrilateral.i_width) | Input socket: Width |
| [mode](#nodebpy.nodes.geometry.Quadrilateral.mode) |  |
| [name](#nodebpy.nodes.geometry.Quadrilateral.name) |  |
| [node](#nodebpy.nodes.geometry.Quadrilateral.node) |  |
| [o_curve](#nodebpy.nodes.geometry.Quadrilateral.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.Quadrilateral.tree) |  |
| [type](#nodebpy.nodes.geometry.Quadrilateral.type) |  |

### Raycast { #nodebpy.nodes.geometry.Raycast }

```python
nodes.geometry.Raycast(
    target_geometry=None,
    attribute=0.0,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
    *,
    data_type='FLOAT',
)
```

Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.geometry.Raycast.data_type) |  |
| [i_attribute](#nodebpy.nodes.geometry.Raycast.i_attribute) | Input socket: Attribute |
| [i_interpolation](#nodebpy.nodes.geometry.Raycast.i_interpolation) | Input socket: Interpolation |
| [i_ray_direction](#nodebpy.nodes.geometry.Raycast.i_ray_direction) | Input socket: Ray Direction |
| [i_ray_length](#nodebpy.nodes.geometry.Raycast.i_ray_length) | Input socket: Ray Length |
| [i_source_position](#nodebpy.nodes.geometry.Raycast.i_source_position) | Input socket: Source Position |
| [i_target_geometry](#nodebpy.nodes.geometry.Raycast.i_target_geometry) | Input socket: Target Geometry |
| [name](#nodebpy.nodes.geometry.Raycast.name) |  |
| [node](#nodebpy.nodes.geometry.Raycast.node) |  |
| [o_attribute](#nodebpy.nodes.geometry.Raycast.o_attribute) | Output socket: Attribute |
| [o_hit_distance](#nodebpy.nodes.geometry.Raycast.o_hit_distance) | Output socket: Hit Distance |
| [o_hit_normal](#nodebpy.nodes.geometry.Raycast.o_hit_normal) | Output socket: Hit Normal |
| [o_hit_position](#nodebpy.nodes.geometry.Raycast.o_hit_position) | Output socket: Hit Position |
| [o_is_hit](#nodebpy.nodes.geometry.Raycast.o_is_hit) | Output socket: Is Hit |
| [tree](#nodebpy.nodes.geometry.Raycast.tree) |  |
| [type](#nodebpy.nodes.geometry.Raycast.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.geometry.Raycast.boolean) | Create Raycast with operation 'Boolean'. |
| [color](#nodebpy.nodes.geometry.Raycast.color) | Create Raycast with operation 'Color'. |
| [float](#nodebpy.nodes.geometry.Raycast.float) | Create Raycast with operation 'Float'. |
| [integer](#nodebpy.nodes.geometry.Raycast.integer) | Create Raycast with operation 'Integer'. |
| [matrix](#nodebpy.nodes.geometry.Raycast.matrix) | Create Raycast with operation '4x4 Matrix'. |
| [quaternion](#nodebpy.nodes.geometry.Raycast.quaternion) | Create Raycast with operation 'Quaternion'. |
| [vector](#nodebpy.nodes.geometry.Raycast.vector) | Create Raycast with operation 'Vector'. |

##### boolean { #nodebpy.nodes.geometry.Raycast.boolean }

```python
nodes.geometry.Raycast.boolean(
    target_geometry=None,
    attribute=False,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Boolean'.

##### color { #nodebpy.nodes.geometry.Raycast.color }

```python
nodes.geometry.Raycast.color(
    target_geometry=None,
    attribute=None,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Color'.

##### float { #nodebpy.nodes.geometry.Raycast.float }

```python
nodes.geometry.Raycast.float(
    target_geometry=None,
    attribute=0.0,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Float'.

##### integer { #nodebpy.nodes.geometry.Raycast.integer }

```python
nodes.geometry.Raycast.integer(
    target_geometry=None,
    attribute=0,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Integer'.

##### matrix { #nodebpy.nodes.geometry.Raycast.matrix }

```python
nodes.geometry.Raycast.matrix(
    target_geometry=None,
    attribute=None,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation '4x4 Matrix'.

##### quaternion { #nodebpy.nodes.geometry.Raycast.quaternion }

```python
nodes.geometry.Raycast.quaternion(
    target_geometry=None,
    attribute=None,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Quaternion'.

##### vector { #nodebpy.nodes.geometry.Raycast.vector }

```python
nodes.geometry.Raycast.vector(
    target_geometry=None,
    attribute=None,
    interpolation='Interpolated',
    source_position=None,
    ray_direction=None,
    ray_length=100.0,
)
```

Create Raycast with operation 'Vector'.

### RealizeInstances { #nodebpy.nodes.geometry.RealizeInstances }

```python
nodes.geometry.RealizeInstances(
    geometry=None,
    selection=True,
    realize_all=True,
    depth=0,
)
```

Convert instances into real geometry data

#### Attributes

| Name | Description |
| --- | --- |
| [i_depth](#nodebpy.nodes.geometry.RealizeInstances.i_depth) | Input socket: Depth |
| [i_geometry](#nodebpy.nodes.geometry.RealizeInstances.i_geometry) | Input socket: Geometry |
| [i_realize_all](#nodebpy.nodes.geometry.RealizeInstances.i_realize_all) | Input socket: Realize All |
| [i_selection](#nodebpy.nodes.geometry.RealizeInstances.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.RealizeInstances.name) |  |
| [node](#nodebpy.nodes.geometry.RealizeInstances.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.RealizeInstances.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.RealizeInstances.tree) |  |
| [type](#nodebpy.nodes.geometry.RealizeInstances.type) |  |

### ReplaceMaterial { #nodebpy.nodes.geometry.ReplaceMaterial }

```python
nodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None)
```

Swap one material with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.ReplaceMaterial.i_geometry) | Input socket: Geometry |
| [i_new](#nodebpy.nodes.geometry.ReplaceMaterial.i_new) | Input socket: New |
| [i_old](#nodebpy.nodes.geometry.ReplaceMaterial.i_old) | Input socket: Old |
| [name](#nodebpy.nodes.geometry.ReplaceMaterial.name) |  |
| [node](#nodebpy.nodes.geometry.ReplaceMaterial.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.ReplaceMaterial.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.ReplaceMaterial.tree) |  |
| [type](#nodebpy.nodes.geometry.ReplaceMaterial.type) |  |

### ResampleCurve { #nodebpy.nodes.geometry.ResampleCurve }

```python
nodes.geometry.ResampleCurve(
    curve=None,
    selection=True,
    mode='Count',
    count=10,
    length=0.1,
    *,
    keep_last_segment=False,
)
```

Generate a poly spline for each input spline

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.ResampleCurve.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.geometry.ResampleCurve.i_curve) | Input socket: Curve |
| [i_length](#nodebpy.nodes.geometry.ResampleCurve.i_length) | Input socket: Length |
| [i_mode](#nodebpy.nodes.geometry.ResampleCurve.i_mode) | Input socket: Mode |
| [i_selection](#nodebpy.nodes.geometry.ResampleCurve.i_selection) | Input socket: Selection |
| [keep_last_segment](#nodebpy.nodes.geometry.ResampleCurve.keep_last_segment) |  |
| [name](#nodebpy.nodes.geometry.ResampleCurve.name) |  |
| [node](#nodebpy.nodes.geometry.ResampleCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.ResampleCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.ResampleCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.ResampleCurve.type) |  |

### ReverseCurve { #nodebpy.nodes.geometry.ReverseCurve }

```python
nodes.geometry.ReverseCurve(curve=None, selection=True)
```

Change the direction of curves by swapping their start and end data

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.ReverseCurve.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.geometry.ReverseCurve.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.ReverseCurve.name) |  |
| [node](#nodebpy.nodes.geometry.ReverseCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.ReverseCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.ReverseCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.ReverseCurve.type) |  |

### RotateInstances { #nodebpy.nodes.geometry.RotateInstances }

```python
nodes.geometry.RotateInstances(
    instances=None,
    selection=True,
    rotation=None,
    pivot_point=None,
    local_space=True,
)
```

Rotate geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.RotateInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.RotateInstances.i_local_space) | Input socket: Local Space |
| [i_pivot_point](#nodebpy.nodes.geometry.RotateInstances.i_pivot_point) | Input socket: Pivot Point |
| [i_rotation](#nodebpy.nodes.geometry.RotateInstances.i_rotation) | Input socket: Rotation |
| [i_selection](#nodebpy.nodes.geometry.RotateInstances.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.RotateInstances.name) |  |
| [node](#nodebpy.nodes.geometry.RotateInstances.node) |  |
| [o_instances](#nodebpy.nodes.geometry.RotateInstances.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.RotateInstances.tree) |  |
| [type](#nodebpy.nodes.geometry.RotateInstances.type) |  |

### SampleCurve { #nodebpy.nodes.geometry.SampleCurve }

```python
nodes.geometry.SampleCurve(
    curves=None,
    value=0.0,
    factor=0.0,
    length=0.0,
    curve_index=0,
    *,
    mode='FACTOR',
    use_all_curves=False,
    data_type='FLOAT',
)
```

Retrieve data from a point on a curve at a certain distance from its start

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.geometry.SampleCurve.data_type) |  |
| [i_curve_index](#nodebpy.nodes.geometry.SampleCurve.i_curve_index) | Input socket: Curve Index |
| [i_curves](#nodebpy.nodes.geometry.SampleCurve.i_curves) | Input socket: Curves |
| [i_factor](#nodebpy.nodes.geometry.SampleCurve.i_factor) | Input socket: Factor |
| [i_length](#nodebpy.nodes.geometry.SampleCurve.i_length) | Input socket: Length |
| [i_value](#nodebpy.nodes.geometry.SampleCurve.i_value) | Input socket: Value |
| [mode](#nodebpy.nodes.geometry.SampleCurve.mode) |  |
| [name](#nodebpy.nodes.geometry.SampleCurve.name) |  |
| [node](#nodebpy.nodes.geometry.SampleCurve.node) |  |
| [o_normal](#nodebpy.nodes.geometry.SampleCurve.o_normal) | Output socket: Normal |
| [o_position](#nodebpy.nodes.geometry.SampleCurve.o_position) | Output socket: Position |
| [o_tangent](#nodebpy.nodes.geometry.SampleCurve.o_tangent) | Output socket: Tangent |
| [o_value](#nodebpy.nodes.geometry.SampleCurve.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.geometry.SampleCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.SampleCurve.type) |  |
| [use_all_curves](#nodebpy.nodes.geometry.SampleCurve.use_all_curves) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.geometry.SampleCurve.boolean) | Create Sample Curve with operation 'Boolean'. |
| [color](#nodebpy.nodes.geometry.SampleCurve.color) | Create Sample Curve with operation 'Color'. |
| [float](#nodebpy.nodes.geometry.SampleCurve.float) | Create Sample Curve with operation 'Float'. |
| [integer](#nodebpy.nodes.geometry.SampleCurve.integer) | Create Sample Curve with operation 'Integer'. |
| [matrix](#nodebpy.nodes.geometry.SampleCurve.matrix) | Create Sample Curve with operation '4x4 Matrix'. |
| [quaternion](#nodebpy.nodes.geometry.SampleCurve.quaternion) | Create Sample Curve with operation 'Quaternion'. |
| [vector](#nodebpy.nodes.geometry.SampleCurve.vector) | Create Sample Curve with operation 'Vector'. |

##### boolean { #nodebpy.nodes.geometry.SampleCurve.boolean }

```python
nodes.geometry.SampleCurve.boolean(
    curves=None,
    value=False,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Boolean'.

##### color { #nodebpy.nodes.geometry.SampleCurve.color }

```python
nodes.geometry.SampleCurve.color(
    curves=None,
    value=None,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Color'.

##### float { #nodebpy.nodes.geometry.SampleCurve.float }

```python
nodes.geometry.SampleCurve.float(
    curves=None,
    value=0.0,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Float'.

##### integer { #nodebpy.nodes.geometry.SampleCurve.integer }

```python
nodes.geometry.SampleCurve.integer(
    curves=None,
    value=0,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Integer'.

##### matrix { #nodebpy.nodes.geometry.SampleCurve.matrix }

```python
nodes.geometry.SampleCurve.matrix(
    curves=None,
    value=None,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation '4x4 Matrix'.

##### quaternion { #nodebpy.nodes.geometry.SampleCurve.quaternion }

```python
nodes.geometry.SampleCurve.quaternion(
    curves=None,
    value=None,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Quaternion'.

##### vector { #nodebpy.nodes.geometry.SampleCurve.vector }

```python
nodes.geometry.SampleCurve.vector(
    curves=None,
    value=None,
    length=0.0,
    curve_index=0,
)
```

Create Sample Curve with operation 'Vector'.

### SampleIndex { #nodebpy.nodes.geometry.SampleIndex }

```python
nodes.geometry.SampleIndex(
    geometry=None,
    value=0.0,
    index=0,
    *,
    data_type='FLOAT',
    domain='POINT',
    clamp=False,
)
```

Retrieve values from specific geometry elements

#### Attributes

| Name | Description |
| --- | --- |
| [clamp](#nodebpy.nodes.geometry.SampleIndex.clamp) |  |
| [data_type](#nodebpy.nodes.geometry.SampleIndex.data_type) |  |
| [domain](#nodebpy.nodes.geometry.SampleIndex.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SampleIndex.i_geometry) | Input socket: Geometry |
| [i_index](#nodebpy.nodes.geometry.SampleIndex.i_index) | Input socket: Index |
| [i_value](#nodebpy.nodes.geometry.SampleIndex.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.geometry.SampleIndex.name) |  |
| [node](#nodebpy.nodes.geometry.SampleIndex.node) |  |
| [o_value](#nodebpy.nodes.geometry.SampleIndex.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.geometry.SampleIndex.tree) |  |
| [type](#nodebpy.nodes.geometry.SampleIndex.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.geometry.SampleIndex.boolean) | Create Sample Index with operation 'Boolean'. |
| [color](#nodebpy.nodes.geometry.SampleIndex.color) | Create Sample Index with operation 'Color'. |
| [edge](#nodebpy.nodes.geometry.SampleIndex.edge) | Create Sample Index with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SampleIndex.face) | Create Sample Index with operation 'Face'. |
| [face_corner](#nodebpy.nodes.geometry.SampleIndex.face_corner) | Create Sample Index with operation 'Face Corner'. |
| [float](#nodebpy.nodes.geometry.SampleIndex.float) | Create Sample Index with operation 'Float'. |
| [instance](#nodebpy.nodes.geometry.SampleIndex.instance) | Create Sample Index with operation 'Instance'. |
| [integer](#nodebpy.nodes.geometry.SampleIndex.integer) | Create Sample Index with operation 'Integer'. |
| [layer](#nodebpy.nodes.geometry.SampleIndex.layer) | Create Sample Index with operation 'Layer'. |
| [matrix](#nodebpy.nodes.geometry.SampleIndex.matrix) | Create Sample Index with operation '4x4 Matrix'. |
| [point](#nodebpy.nodes.geometry.SampleIndex.point) | Create Sample Index with operation 'Point'. |
| [quaternion](#nodebpy.nodes.geometry.SampleIndex.quaternion) | Create Sample Index with operation 'Quaternion'. |
| [spline](#nodebpy.nodes.geometry.SampleIndex.spline) | Create Sample Index with operation 'Spline'. |
| [vector](#nodebpy.nodes.geometry.SampleIndex.vector) | Create Sample Index with operation 'Vector'. |

##### boolean { #nodebpy.nodes.geometry.SampleIndex.boolean }

```python
nodes.geometry.SampleIndex.boolean(geometry=None, value=False, index=0)
```

Create Sample Index with operation 'Boolean'.

##### color { #nodebpy.nodes.geometry.SampleIndex.color }

```python
nodes.geometry.SampleIndex.color(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Color'.

##### edge { #nodebpy.nodes.geometry.SampleIndex.edge }

```python
nodes.geometry.SampleIndex.edge(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SampleIndex.face }

```python
nodes.geometry.SampleIndex.face(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Face'.

##### face_corner { #nodebpy.nodes.geometry.SampleIndex.face_corner }

```python
nodes.geometry.SampleIndex.face_corner(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Face Corner'.

##### float { #nodebpy.nodes.geometry.SampleIndex.float }

```python
nodes.geometry.SampleIndex.float(geometry=None, value=0.0, index=0)
```

Create Sample Index with operation 'Float'.

##### instance { #nodebpy.nodes.geometry.SampleIndex.instance }

```python
nodes.geometry.SampleIndex.instance(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Instance'.

##### integer { #nodebpy.nodes.geometry.SampleIndex.integer }

```python
nodes.geometry.SampleIndex.integer(geometry=None, value=0, index=0)
```

Create Sample Index with operation 'Integer'.

##### layer { #nodebpy.nodes.geometry.SampleIndex.layer }

```python
nodes.geometry.SampleIndex.layer(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Layer'.

##### matrix { #nodebpy.nodes.geometry.SampleIndex.matrix }

```python
nodes.geometry.SampleIndex.matrix(geometry=None, value=None, index=0)
```

Create Sample Index with operation '4x4 Matrix'.

##### point { #nodebpy.nodes.geometry.SampleIndex.point }

```python
nodes.geometry.SampleIndex.point(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Point'.

##### quaternion { #nodebpy.nodes.geometry.SampleIndex.quaternion }

```python
nodes.geometry.SampleIndex.quaternion(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Quaternion'.

##### spline { #nodebpy.nodes.geometry.SampleIndex.spline }

```python
nodes.geometry.SampleIndex.spline(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Spline'.

##### vector { #nodebpy.nodes.geometry.SampleIndex.vector }

```python
nodes.geometry.SampleIndex.vector(geometry=None, value=None, index=0)
```

Create Sample Index with operation 'Vector'.

### SampleNearest { #nodebpy.nodes.geometry.SampleNearest }

```python
nodes.geometry.SampleNearest(
    geometry=None,
    sample_position=None,
    *,
    domain='POINT',
)
```

Find the element of a geometry closest to a position. Similar to the "Index of Nearest" node

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SampleNearest.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SampleNearest.i_geometry) | Input socket: Geometry |
| [i_sample_position](#nodebpy.nodes.geometry.SampleNearest.i_sample_position) | Input socket: Sample Position |
| [name](#nodebpy.nodes.geometry.SampleNearest.name) |  |
| [node](#nodebpy.nodes.geometry.SampleNearest.node) |  |
| [o_index](#nodebpy.nodes.geometry.SampleNearest.o_index) | Output socket: Index |
| [tree](#nodebpy.nodes.geometry.SampleNearest.tree) |  |
| [type](#nodebpy.nodes.geometry.SampleNearest.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SampleNearest.edge) | Create Sample Nearest with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SampleNearest.face) | Create Sample Nearest with operation 'Face'. |
| [face_corner](#nodebpy.nodes.geometry.SampleNearest.face_corner) | Create Sample Nearest with operation 'Face Corner'. |
| [point](#nodebpy.nodes.geometry.SampleNearest.point) | Create Sample Nearest with operation 'Point'. |

##### edge { #nodebpy.nodes.geometry.SampleNearest.edge }

```python
nodes.geometry.SampleNearest.edge(geometry=None, sample_position=None)
```

Create Sample Nearest with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SampleNearest.face }

```python
nodes.geometry.SampleNearest.face(geometry=None, sample_position=None)
```

Create Sample Nearest with operation 'Face'.

##### face_corner { #nodebpy.nodes.geometry.SampleNearest.face_corner }

```python
nodes.geometry.SampleNearest.face_corner(geometry=None, sample_position=None)
```

Create Sample Nearest with operation 'Face Corner'.

##### point { #nodebpy.nodes.geometry.SampleNearest.point }

```python
nodes.geometry.SampleNearest.point(geometry=None, sample_position=None)
```

Create Sample Nearest with operation 'Point'.

### SampleNearestSurface { #nodebpy.nodes.geometry.SampleNearestSurface }

```python
nodes.geometry.SampleNearestSurface(
    mesh=None,
    value=0.0,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
    *,
    data_type='FLOAT',
)
```

Calculate the interpolated value of a mesh attribute on the closest point of its surface

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.geometry.SampleNearestSurface.data_type) |  |
| [i_group_id](#nodebpy.nodes.geometry.SampleNearestSurface.i_group_id) | Input socket: Group ID |
| [i_mesh](#nodebpy.nodes.geometry.SampleNearestSurface.i_mesh) | Input socket: Mesh |
| [i_sample_group_id](#nodebpy.nodes.geometry.SampleNearestSurface.i_sample_group_id) | Input socket: Sample Group ID |
| [i_sample_position](#nodebpy.nodes.geometry.SampleNearestSurface.i_sample_position) | Input socket: Sample Position |
| [i_value](#nodebpy.nodes.geometry.SampleNearestSurface.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.geometry.SampleNearestSurface.name) |  |
| [node](#nodebpy.nodes.geometry.SampleNearestSurface.node) |  |
| [o_is_valid](#nodebpy.nodes.geometry.SampleNearestSurface.o_is_valid) | Output socket: Is Valid |
| [o_value](#nodebpy.nodes.geometry.SampleNearestSurface.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.geometry.SampleNearestSurface.tree) |  |
| [type](#nodebpy.nodes.geometry.SampleNearestSurface.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.geometry.SampleNearestSurface.boolean) | Create Sample Nearest Surface with operation 'Boolean'. |
| [color](#nodebpy.nodes.geometry.SampleNearestSurface.color) | Create Sample Nearest Surface with operation 'Color'. |
| [float](#nodebpy.nodes.geometry.SampleNearestSurface.float) | Create Sample Nearest Surface with operation 'Float'. |
| [integer](#nodebpy.nodes.geometry.SampleNearestSurface.integer) | Create Sample Nearest Surface with operation 'Integer'. |
| [matrix](#nodebpy.nodes.geometry.SampleNearestSurface.matrix) | Create Sample Nearest Surface with operation '4x4 Matrix'. |
| [quaternion](#nodebpy.nodes.geometry.SampleNearestSurface.quaternion) | Create Sample Nearest Surface with operation 'Quaternion'. |
| [vector](#nodebpy.nodes.geometry.SampleNearestSurface.vector) | Create Sample Nearest Surface with operation 'Vector'. |

##### boolean { #nodebpy.nodes.geometry.SampleNearestSurface.boolean }

```python
nodes.geometry.SampleNearestSurface.boolean(
    mesh=None,
    value=False,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Boolean'.

##### color { #nodebpy.nodes.geometry.SampleNearestSurface.color }

```python
nodes.geometry.SampleNearestSurface.color(
    mesh=None,
    value=None,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Color'.

##### float { #nodebpy.nodes.geometry.SampleNearestSurface.float }

```python
nodes.geometry.SampleNearestSurface.float(
    mesh=None,
    value=0.0,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Float'.

##### integer { #nodebpy.nodes.geometry.SampleNearestSurface.integer }

```python
nodes.geometry.SampleNearestSurface.integer(
    mesh=None,
    value=0,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Integer'.

##### matrix { #nodebpy.nodes.geometry.SampleNearestSurface.matrix }

```python
nodes.geometry.SampleNearestSurface.matrix(
    mesh=None,
    value=None,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation '4x4 Matrix'.

##### quaternion { #nodebpy.nodes.geometry.SampleNearestSurface.quaternion }

```python
nodes.geometry.SampleNearestSurface.quaternion(
    mesh=None,
    value=None,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Quaternion'.

##### vector { #nodebpy.nodes.geometry.SampleNearestSurface.vector }

```python
nodes.geometry.SampleNearestSurface.vector(
    mesh=None,
    value=None,
    group_id=0,
    sample_position=None,
    sample_group_id=0,
)
```

Create Sample Nearest Surface with operation 'Vector'.

### SampleUVSurface { #nodebpy.nodes.geometry.SampleUVSurface }

```python
nodes.geometry.SampleUVSurface(
    mesh=None,
    value=0.0,
    source_uv_map=None,
    sample_uv=None,
    *,
    data_type='FLOAT',
)
```

Calculate the interpolated values of a mesh attribute at a UV coordinate

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.geometry.SampleUVSurface.data_type) |  |
| [i_mesh](#nodebpy.nodes.geometry.SampleUVSurface.i_mesh) | Input socket: Mesh |
| [i_sample_uv](#nodebpy.nodes.geometry.SampleUVSurface.i_sample_uv) | Input socket: Sample UV |
| [i_source_uv_map](#nodebpy.nodes.geometry.SampleUVSurface.i_source_uv_map) | Input socket: UV Map |
| [i_value](#nodebpy.nodes.geometry.SampleUVSurface.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.geometry.SampleUVSurface.name) |  |
| [node](#nodebpy.nodes.geometry.SampleUVSurface.node) |  |
| [o_is_valid](#nodebpy.nodes.geometry.SampleUVSurface.o_is_valid) | Output socket: Is Valid |
| [o_value](#nodebpy.nodes.geometry.SampleUVSurface.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.geometry.SampleUVSurface.tree) |  |
| [type](#nodebpy.nodes.geometry.SampleUVSurface.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.geometry.SampleUVSurface.boolean) | Create Sample UV Surface with operation 'Boolean'. |
| [color](#nodebpy.nodes.geometry.SampleUVSurface.color) | Create Sample UV Surface with operation 'Color'. |
| [float](#nodebpy.nodes.geometry.SampleUVSurface.float) | Create Sample UV Surface with operation 'Float'. |
| [integer](#nodebpy.nodes.geometry.SampleUVSurface.integer) | Create Sample UV Surface with operation 'Integer'. |
| [matrix](#nodebpy.nodes.geometry.SampleUVSurface.matrix) | Create Sample UV Surface with operation '4x4 Matrix'. |
| [quaternion](#nodebpy.nodes.geometry.SampleUVSurface.quaternion) | Create Sample UV Surface with operation 'Quaternion'. |
| [vector](#nodebpy.nodes.geometry.SampleUVSurface.vector) | Create Sample UV Surface with operation 'Vector'. |

##### boolean { #nodebpy.nodes.geometry.SampleUVSurface.boolean }

```python
nodes.geometry.SampleUVSurface.boolean(
    mesh=None,
    value=False,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Boolean'.

##### color { #nodebpy.nodes.geometry.SampleUVSurface.color }

```python
nodes.geometry.SampleUVSurface.color(
    mesh=None,
    value=None,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Color'.

##### float { #nodebpy.nodes.geometry.SampleUVSurface.float }

```python
nodes.geometry.SampleUVSurface.float(
    mesh=None,
    value=0.0,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Float'.

##### integer { #nodebpy.nodes.geometry.SampleUVSurface.integer }

```python
nodes.geometry.SampleUVSurface.integer(
    mesh=None,
    value=0,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Integer'.

##### matrix { #nodebpy.nodes.geometry.SampleUVSurface.matrix }

```python
nodes.geometry.SampleUVSurface.matrix(
    mesh=None,
    value=None,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation '4x4 Matrix'.

##### quaternion { #nodebpy.nodes.geometry.SampleUVSurface.quaternion }

```python
nodes.geometry.SampleUVSurface.quaternion(
    mesh=None,
    value=None,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Quaternion'.

##### vector { #nodebpy.nodes.geometry.SampleUVSurface.vector }

```python
nodes.geometry.SampleUVSurface.vector(
    mesh=None,
    value=None,
    source_uv_map=None,
    sample_uv=None,
)
```

Create Sample UV Surface with operation 'Vector'.

### ScaleElements { #nodebpy.nodes.geometry.ScaleElements }

```python
nodes.geometry.ScaleElements(
    geometry=None,
    selection=True,
    scale=1.0,
    center=None,
    scale_mode='Uniform',
    axis=None,
    *,
    domain='FACE',
)
```

Scale groups of connected edges and faces

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.ScaleElements.domain) |  |
| [i_axis](#nodebpy.nodes.geometry.ScaleElements.i_axis) | Input socket: Axis |
| [i_center](#nodebpy.nodes.geometry.ScaleElements.i_center) | Input socket: Center |
| [i_geometry](#nodebpy.nodes.geometry.ScaleElements.i_geometry) | Input socket: Geometry |
| [i_scale](#nodebpy.nodes.geometry.ScaleElements.i_scale) | Input socket: Scale |
| [i_scale_mode](#nodebpy.nodes.geometry.ScaleElements.i_scale_mode) | Input socket: Scale Mode |
| [i_selection](#nodebpy.nodes.geometry.ScaleElements.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.ScaleElements.name) |  |
| [node](#nodebpy.nodes.geometry.ScaleElements.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.ScaleElements.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.ScaleElements.tree) |  |
| [type](#nodebpy.nodes.geometry.ScaleElements.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.ScaleElements.edge) | Create Scale Elements with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.ScaleElements.face) | Create Scale Elements with operation 'Face'. |

##### edge { #nodebpy.nodes.geometry.ScaleElements.edge }

```python
nodes.geometry.ScaleElements.edge(
    geometry=None,
    selection=True,
    scale=1.0,
    center=None,
    scale_mode='Uniform',
)
```

Create Scale Elements with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.ScaleElements.face }

```python
nodes.geometry.ScaleElements.face(
    geometry=None,
    selection=True,
    scale=1.0,
    center=None,
    scale_mode='Uniform',
)
```

Create Scale Elements with operation 'Face'.

### ScaleInstances { #nodebpy.nodes.geometry.ScaleInstances }

```python
nodes.geometry.ScaleInstances(
    instances=None,
    selection=True,
    scale=None,
    center=None,
    local_space=True,
)
```

Scale geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_center](#nodebpy.nodes.geometry.ScaleInstances.i_center) | Input socket: Center |
| [i_instances](#nodebpy.nodes.geometry.ScaleInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.ScaleInstances.i_local_space) | Input socket: Local Space |
| [i_scale](#nodebpy.nodes.geometry.ScaleInstances.i_scale) | Input socket: Scale |
| [i_selection](#nodebpy.nodes.geometry.ScaleInstances.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.ScaleInstances.name) |  |
| [node](#nodebpy.nodes.geometry.ScaleInstances.node) |  |
| [o_instances](#nodebpy.nodes.geometry.ScaleInstances.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.ScaleInstances.tree) |  |
| [type](#nodebpy.nodes.geometry.ScaleInstances.type) |  |

### SeparateComponents { #nodebpy.nodes.geometry.SeparateComponents }

```python
nodes.geometry.SeparateComponents(geometry=None)
```

Split a geometry into a separate output for each type of data in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SeparateComponents.i_geometry) | Input socket: Geometry |
| [name](#nodebpy.nodes.geometry.SeparateComponents.name) |  |
| [node](#nodebpy.nodes.geometry.SeparateComponents.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SeparateComponents.o_curve) | Output socket: Curve |
| [o_grease_pencil](#nodebpy.nodes.geometry.SeparateComponents.o_grease_pencil) | Output socket: Grease Pencil |
| [o_instances](#nodebpy.nodes.geometry.SeparateComponents.o_instances) | Output socket: Instances |
| [o_mesh](#nodebpy.nodes.geometry.SeparateComponents.o_mesh) | Output socket: Mesh |
| [o_point_cloud](#nodebpy.nodes.geometry.SeparateComponents.o_point_cloud) | Output socket: Point Cloud |
| [o_volume](#nodebpy.nodes.geometry.SeparateComponents.o_volume) | Output socket: Volume |
| [tree](#nodebpy.nodes.geometry.SeparateComponents.tree) |  |
| [type](#nodebpy.nodes.geometry.SeparateComponents.type) |  |

### SeparateGeometry { #nodebpy.nodes.geometry.SeparateGeometry }

```python
nodes.geometry.SeparateGeometry(
    geometry=None,
    selection=True,
    *,
    domain='POINT',
)
```

Split a geometry into two geometry outputs based on a selection

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SeparateGeometry.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SeparateGeometry.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.SeparateGeometry.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SeparateGeometry.name) |  |
| [node](#nodebpy.nodes.geometry.SeparateGeometry.node) |  |
| [o_inverted](#nodebpy.nodes.geometry.SeparateGeometry.o_inverted) | Output socket: Inverted |
| [o_selection](#nodebpy.nodes.geometry.SeparateGeometry.o_selection) | Output socket: Selection |
| [tree](#nodebpy.nodes.geometry.SeparateGeometry.tree) |  |
| [type](#nodebpy.nodes.geometry.SeparateGeometry.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SeparateGeometry.edge) | Create Separate Geometry with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SeparateGeometry.face) | Create Separate Geometry with operation 'Face'. |
| [instance](#nodebpy.nodes.geometry.SeparateGeometry.instance) | Create Separate Geometry with operation 'Instance'. |
| [layer](#nodebpy.nodes.geometry.SeparateGeometry.layer) | Create Separate Geometry with operation 'Layer'. |
| [point](#nodebpy.nodes.geometry.SeparateGeometry.point) | Create Separate Geometry with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.SeparateGeometry.spline) | Create Separate Geometry with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.SeparateGeometry.edge }

```python
nodes.geometry.SeparateGeometry.edge(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SeparateGeometry.face }

```python
nodes.geometry.SeparateGeometry.face(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Face'.

##### instance { #nodebpy.nodes.geometry.SeparateGeometry.instance }

```python
nodes.geometry.SeparateGeometry.instance(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Instance'.

##### layer { #nodebpy.nodes.geometry.SeparateGeometry.layer }

```python
nodes.geometry.SeparateGeometry.layer(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Layer'.

##### point { #nodebpy.nodes.geometry.SeparateGeometry.point }

```python
nodes.geometry.SeparateGeometry.point(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.SeparateGeometry.spline }

```python
nodes.geometry.SeparateGeometry.spline(geometry=None, selection=True)
```

Create Separate Geometry with operation 'Spline'.

### SetCurveNormal { #nodebpy.nodes.geometry.SetCurveNormal }

```python
nodes.geometry.SetCurveNormal(
    curve=None,
    selection=True,
    mode='Minimum Twist',
    normal=None,
)
```

Set the evaluation mode for curve normals

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetCurveNormal.i_curve) | Input socket: Curve |
| [i_mode](#nodebpy.nodes.geometry.SetCurveNormal.i_mode) | Input socket: Mode |
| [i_normal](#nodebpy.nodes.geometry.SetCurveNormal.i_normal) | Input socket: Normal |
| [i_selection](#nodebpy.nodes.geometry.SetCurveNormal.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetCurveNormal.name) |  |
| [node](#nodebpy.nodes.geometry.SetCurveNormal.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SetCurveNormal.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetCurveNormal.tree) |  |
| [type](#nodebpy.nodes.geometry.SetCurveNormal.type) |  |

### SetCurveRadius { #nodebpy.nodes.geometry.SetCurveRadius }

```python
nodes.geometry.SetCurveRadius(curve=None, selection=True, radius=0.005)
```

Set the radius of the curve at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetCurveRadius.i_curve) | Input socket: Curve |
| [i_radius](#nodebpy.nodes.geometry.SetCurveRadius.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.SetCurveRadius.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetCurveRadius.name) |  |
| [node](#nodebpy.nodes.geometry.SetCurveRadius.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SetCurveRadius.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetCurveRadius.tree) |  |
| [type](#nodebpy.nodes.geometry.SetCurveRadius.type) |  |

### SetCurveTilt { #nodebpy.nodes.geometry.SetCurveTilt }

```python
nodes.geometry.SetCurveTilt(curve=None, selection=True, tilt=0.0)
```

Set the tilt angle at each curve control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetCurveTilt.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.geometry.SetCurveTilt.i_selection) | Input socket: Selection |
| [i_tilt](#nodebpy.nodes.geometry.SetCurveTilt.i_tilt) | Input socket: Tilt |
| [name](#nodebpy.nodes.geometry.SetCurveTilt.name) |  |
| [node](#nodebpy.nodes.geometry.SetCurveTilt.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SetCurveTilt.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetCurveTilt.tree) |  |
| [type](#nodebpy.nodes.geometry.SetCurveTilt.type) |  |

### SetFaceSet { #nodebpy.nodes.geometry.SetFaceSet }

```python
nodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0)
```

Set sculpt face set values for faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_set](#nodebpy.nodes.geometry.SetFaceSet.i_face_set) | Input socket: Face Set |
| [i_mesh](#nodebpy.nodes.geometry.SetFaceSet.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SetFaceSet.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetFaceSet.name) |  |
| [node](#nodebpy.nodes.geometry.SetFaceSet.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.SetFaceSet.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SetFaceSet.tree) |  |
| [type](#nodebpy.nodes.geometry.SetFaceSet.type) |  |

### SetGeometryName { #nodebpy.nodes.geometry.SetGeometryName }

```python
nodes.geometry.SetGeometryName(geometry=None, name='')
```

Set the name of a geometry for easier debugging

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetGeometryName.i_geometry) | Input socket: Geometry |
| [i_name](#nodebpy.nodes.geometry.SetGeometryName.i_name) | Input socket: Name |
| [name](#nodebpy.nodes.geometry.SetGeometryName.name) |  |
| [node](#nodebpy.nodes.geometry.SetGeometryName.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetGeometryName.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SetGeometryName.tree) |  |
| [type](#nodebpy.nodes.geometry.SetGeometryName.type) |  |

### SetGreasePencilColor { #nodebpy.nodes.geometry.SetGreasePencilColor }

```python
nodes.geometry.SetGreasePencilColor(
    grease_pencil=None,
    selection=True,
    color=None,
    opacity=1.0,
    *,
    mode='STROKE',
)
```

Set color and opacity attributes on Grease Pencil geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.geometry.SetGreasePencilColor.i_color) | Input socket: Color |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilColor.i_grease_pencil) | Input socket: Grease Pencil |
| [i_opacity](#nodebpy.nodes.geometry.SetGreasePencilColor.i_opacity) | Input socket: Opacity |
| [i_selection](#nodebpy.nodes.geometry.SetGreasePencilColor.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.SetGreasePencilColor.mode) |  |
| [name](#nodebpy.nodes.geometry.SetGreasePencilColor.name) |  |
| [node](#nodebpy.nodes.geometry.SetGreasePencilColor.node) |  |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilColor.o_grease_pencil) | Output socket: Grease Pencil |
| [tree](#nodebpy.nodes.geometry.SetGreasePencilColor.tree) |  |
| [type](#nodebpy.nodes.geometry.SetGreasePencilColor.type) |  |

### SetGreasePencilDepth { #nodebpy.nodes.geometry.SetGreasePencilDepth }

```python
nodes.geometry.SetGreasePencilDepth(grease_pencil=None, *, depth_order='2D')
```

Set the Grease Pencil depth order to use

#### Attributes

| Name | Description |
| --- | --- |
| [depth_order](#nodebpy.nodes.geometry.SetGreasePencilDepth.depth_order) |  |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilDepth.i_grease_pencil) | Input socket: Grease Pencil |
| [name](#nodebpy.nodes.geometry.SetGreasePencilDepth.name) |  |
| [node](#nodebpy.nodes.geometry.SetGreasePencilDepth.node) |  |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilDepth.o_grease_pencil) | Output socket: Grease Pencil |
| [tree](#nodebpy.nodes.geometry.SetGreasePencilDepth.tree) |  |
| [type](#nodebpy.nodes.geometry.SetGreasePencilDepth.type) |  |

### SetGreasePencilSoftness { #nodebpy.nodes.geometry.SetGreasePencilSoftness }

```python
nodes.geometry.SetGreasePencilSoftness(
    grease_pencil=None,
    selection=True,
    softness=0.0,
)
```

Set softness attribute on Grease Pencil geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_grease_pencil) | Input socket: Grease Pencil |
| [i_selection](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_selection) | Input socket: Selection |
| [i_softness](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_softness) | Input socket: Softness |
| [name](#nodebpy.nodes.geometry.SetGreasePencilSoftness.name) |  |
| [node](#nodebpy.nodes.geometry.SetGreasePencilSoftness.node) |  |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilSoftness.o_grease_pencil) | Output socket: Grease Pencil |
| [tree](#nodebpy.nodes.geometry.SetGreasePencilSoftness.tree) |  |
| [type](#nodebpy.nodes.geometry.SetGreasePencilSoftness.type) |  |

### SetHandlePositions { #nodebpy.nodes.geometry.SetHandlePositions }

```python
nodes.geometry.SetHandlePositions(
    curve=None,
    selection=True,
    position=None,
    offset=None,
    *,
    mode='LEFT',
)
```

Set the positions for the handles of Bézier curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetHandlePositions.i_curve) | Input socket: Curve |
| [i_offset](#nodebpy.nodes.geometry.SetHandlePositions.i_offset) | Input socket: Offset |
| [i_position](#nodebpy.nodes.geometry.SetHandlePositions.i_position) | Input socket: Position |
| [i_selection](#nodebpy.nodes.geometry.SetHandlePositions.i_selection) | Input socket: Selection |
| [mode](#nodebpy.nodes.geometry.SetHandlePositions.mode) |  |
| [name](#nodebpy.nodes.geometry.SetHandlePositions.name) |  |
| [node](#nodebpy.nodes.geometry.SetHandlePositions.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SetHandlePositions.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetHandlePositions.tree) |  |
| [type](#nodebpy.nodes.geometry.SetHandlePositions.type) |  |

### SetID { #nodebpy.nodes.geometry.SetID }

```python
nodes.geometry.SetID(geometry=None, selection=True, id=0)
```

Set the id attribute on the input geometry, mainly used internally for randomizing

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetID.i_geometry) | Input socket: Geometry |
| [i_id](#nodebpy.nodes.geometry.SetID.i_id) | Input socket: ID |
| [i_selection](#nodebpy.nodes.geometry.SetID.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetID.name) |  |
| [node](#nodebpy.nodes.geometry.SetID.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetID.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SetID.tree) |  |
| [type](#nodebpy.nodes.geometry.SetID.type) |  |

### SetInstanceTransform { #nodebpy.nodes.geometry.SetInstanceTransform }

```python
nodes.geometry.SetInstanceTransform(
    instances=None,
    selection=True,
    transform=None,
)
```

Set the transformation matrix of every instance

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.SetInstanceTransform.i_instances) | Input socket: Instances |
| [i_selection](#nodebpy.nodes.geometry.SetInstanceTransform.i_selection) | Input socket: Selection |
| [i_transform](#nodebpy.nodes.geometry.SetInstanceTransform.i_transform) | Input socket: Transform |
| [name](#nodebpy.nodes.geometry.SetInstanceTransform.name) |  |
| [node](#nodebpy.nodes.geometry.SetInstanceTransform.node) |  |
| [o_instances](#nodebpy.nodes.geometry.SetInstanceTransform.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.SetInstanceTransform.tree) |  |
| [type](#nodebpy.nodes.geometry.SetInstanceTransform.type) |  |

### SetMaterial { #nodebpy.nodes.geometry.SetMaterial }

```python
nodes.geometry.SetMaterial(geometry=None, selection=True, material=None)
```

Assign a material to geometry elements

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetMaterial.i_geometry) | Input socket: Geometry |
| [i_material](#nodebpy.nodes.geometry.SetMaterial.i_material) | Input socket: Material |
| [i_selection](#nodebpy.nodes.geometry.SetMaterial.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetMaterial.name) |  |
| [node](#nodebpy.nodes.geometry.SetMaterial.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetMaterial.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SetMaterial.tree) |  |
| [type](#nodebpy.nodes.geometry.SetMaterial.type) |  |

### SetMaterialIndex { #nodebpy.nodes.geometry.SetMaterialIndex }

```python
nodes.geometry.SetMaterialIndex(geometry=None, selection=True, material_index=0)
```

Set the material index for each selected geometry element

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetMaterialIndex.i_geometry) | Input socket: Geometry |
| [i_material_index](#nodebpy.nodes.geometry.SetMaterialIndex.i_material_index) | Input socket: Material Index |
| [i_selection](#nodebpy.nodes.geometry.SetMaterialIndex.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetMaterialIndex.name) |  |
| [node](#nodebpy.nodes.geometry.SetMaterialIndex.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetMaterialIndex.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SetMaterialIndex.tree) |  |
| [type](#nodebpy.nodes.geometry.SetMaterialIndex.type) |  |

### SetMeshNormal { #nodebpy.nodes.geometry.SetMeshNormal }

```python
nodes.geometry.SetMeshNormal(
    mesh=None,
    remove_custom=True,
    edge_sharpness=False,
    face_sharpness=False,
    *,
    mode='SHARPNESS',
    domain='POINT',
)
```

Store a normal vector for each mesh element

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SetMeshNormal.domain) |  |
| [i_edge_sharpness](#nodebpy.nodes.geometry.SetMeshNormal.i_edge_sharpness) | Input socket: Edge Sharpness |
| [i_face_sharpness](#nodebpy.nodes.geometry.SetMeshNormal.i_face_sharpness) | Input socket: Face Sharpness |
| [i_mesh](#nodebpy.nodes.geometry.SetMeshNormal.i_mesh) | Input socket: Mesh |
| [i_remove_custom](#nodebpy.nodes.geometry.SetMeshNormal.i_remove_custom) | Input socket: Remove Custom |
| [mode](#nodebpy.nodes.geometry.SetMeshNormal.mode) |  |
| [name](#nodebpy.nodes.geometry.SetMeshNormal.name) |  |
| [node](#nodebpy.nodes.geometry.SetMeshNormal.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.SetMeshNormal.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SetMeshNormal.tree) |  |
| [type](#nodebpy.nodes.geometry.SetMeshNormal.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [face](#nodebpy.nodes.geometry.SetMeshNormal.face) | Create Set Mesh Normal with operation 'Face'. |
| [face_corner](#nodebpy.nodes.geometry.SetMeshNormal.face_corner) | Create Set Mesh Normal with operation 'Face Corner'. |
| [point](#nodebpy.nodes.geometry.SetMeshNormal.point) | Create Set Mesh Normal with operation 'Point'. |

##### face { #nodebpy.nodes.geometry.SetMeshNormal.face }

```python
nodes.geometry.SetMeshNormal.face(mesh=None, custom_normal=None)
```

Create Set Mesh Normal with operation 'Face'.

##### face_corner { #nodebpy.nodes.geometry.SetMeshNormal.face_corner }

```python
nodes.geometry.SetMeshNormal.face_corner(mesh=None, custom_normal=None)
```

Create Set Mesh Normal with operation 'Face Corner'.

##### point { #nodebpy.nodes.geometry.SetMeshNormal.point }

```python
nodes.geometry.SetMeshNormal.point(mesh=None, custom_normal=None)
```

Create Set Mesh Normal with operation 'Point'.

### SetPointRadius { #nodebpy.nodes.geometry.SetPointRadius }

```python
nodes.geometry.SetPointRadius(points=None, selection=True, radius=0.05)
```

Set the display size of point cloud points

#### Attributes

| Name | Description |
| --- | --- |
| [i_points](#nodebpy.nodes.geometry.SetPointRadius.i_points) | Input socket: Points |
| [i_radius](#nodebpy.nodes.geometry.SetPointRadius.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.SetPointRadius.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetPointRadius.name) |  |
| [node](#nodebpy.nodes.geometry.SetPointRadius.node) |  |
| [o_points](#nodebpy.nodes.geometry.SetPointRadius.o_points) | Output socket: Points |
| [tree](#nodebpy.nodes.geometry.SetPointRadius.tree) |  |
| [type](#nodebpy.nodes.geometry.SetPointRadius.type) |  |

### SetPosition { #nodebpy.nodes.geometry.SetPosition }

```python
nodes.geometry.SetPosition(
    geometry=None,
    selection=True,
    position=None,
    offset=None,
)
```

Set the location of each point

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetPosition.i_geometry) | Input socket: Geometry |
| [i_offset](#nodebpy.nodes.geometry.SetPosition.i_offset) | Input socket: Offset |
| [i_position](#nodebpy.nodes.geometry.SetPosition.i_position) | Input socket: Position |
| [i_selection](#nodebpy.nodes.geometry.SetPosition.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetPosition.name) |  |
| [node](#nodebpy.nodes.geometry.SetPosition.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetPosition.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SetPosition.tree) |  |
| [type](#nodebpy.nodes.geometry.SetPosition.type) |  |

### SetSelection { #nodebpy.nodes.geometry.SetSelection }

```python
nodes.geometry.SetSelection(
    geometry=None,
    selection=True,
    *,
    domain='POINT',
    selection_type='BOOLEAN',
)
```

Set selection of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SetSelection.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SetSelection.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.SetSelection.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetSelection.name) |  |
| [node](#nodebpy.nodes.geometry.SetSelection.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetSelection.o_geometry) | Output socket: Geometry |
| [selection_type](#nodebpy.nodes.geometry.SetSelection.selection_type) |  |
| [tree](#nodebpy.nodes.geometry.SetSelection.tree) |  |
| [type](#nodebpy.nodes.geometry.SetSelection.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SetSelection.edge) | Create Set Selection with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SetSelection.face) | Create Set Selection with operation 'Face'. |
| [point](#nodebpy.nodes.geometry.SetSelection.point) | Create Set Selection with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.SetSelection.spline) | Create Set Selection with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.SetSelection.edge }

```python
nodes.geometry.SetSelection.edge(geometry=None, selection=True)
```

Create Set Selection with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SetSelection.face }

```python
nodes.geometry.SetSelection.face(geometry=None, selection=True)
```

Create Set Selection with operation 'Face'.

##### point { #nodebpy.nodes.geometry.SetSelection.point }

```python
nodes.geometry.SetSelection.point(geometry=None, selection=True)
```

Create Set Selection with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.SetSelection.spline }

```python
nodes.geometry.SetSelection.spline(geometry=None, selection=True)
```

Create Set Selection with operation 'Spline'.

### SetShadeSmooth { #nodebpy.nodes.geometry.SetShadeSmooth }

```python
nodes.geometry.SetShadeSmooth(
    geometry=None,
    selection=True,
    shade_smooth=True,
    *,
    domain='FACE',
)
```

Control the smoothness of mesh normals around each face by changing the "shade smooth" attribute

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SetShadeSmooth.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SetShadeSmooth.i_geometry) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SetShadeSmooth.i_selection) | Input socket: Selection |
| [i_shade_smooth](#nodebpy.nodes.geometry.SetShadeSmooth.i_shade_smooth) | Input socket: Shade Smooth |
| [name](#nodebpy.nodes.geometry.SetShadeSmooth.name) |  |
| [node](#nodebpy.nodes.geometry.SetShadeSmooth.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetShadeSmooth.o_geometry) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SetShadeSmooth.tree) |  |
| [type](#nodebpy.nodes.geometry.SetShadeSmooth.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SetShadeSmooth.edge) | Create Set Shade Smooth with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SetShadeSmooth.face) | Create Set Shade Smooth with operation 'Face'. |

##### edge { #nodebpy.nodes.geometry.SetShadeSmooth.edge }

```python
nodes.geometry.SetShadeSmooth.edge(
    geometry=None,
    selection=True,
    shade_smooth=True,
)
```

Create Set Shade Smooth with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SetShadeSmooth.face }

```python
nodes.geometry.SetShadeSmooth.face(
    geometry=None,
    selection=True,
    shade_smooth=True,
)
```

Create Set Shade Smooth with operation 'Face'.

### SetSplineCyclic { #nodebpy.nodes.geometry.SetSplineCyclic }

```python
nodes.geometry.SetSplineCyclic(geometry=None, selection=True, cyclic=False)
```

Control whether each spline loops back on itself by changing the "cyclic" attribute

#### Attributes

| Name | Description |
| --- | --- |
| [i_cyclic](#nodebpy.nodes.geometry.SetSplineCyclic.i_cyclic) | Input socket: Cyclic |
| [i_geometry](#nodebpy.nodes.geometry.SetSplineCyclic.i_geometry) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.geometry.SetSplineCyclic.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetSplineCyclic.name) |  |
| [node](#nodebpy.nodes.geometry.SetSplineCyclic.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetSplineCyclic.o_geometry) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetSplineCyclic.tree) |  |
| [type](#nodebpy.nodes.geometry.SetSplineCyclic.type) |  |

### SetSplineResolution { #nodebpy.nodes.geometry.SetSplineResolution }

```python
nodes.geometry.SetSplineResolution(geometry=None, selection=True, resolution=12)
```

Control how many evaluated points should be generated on every curve segment

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetSplineResolution.i_geometry) | Input socket: Curve |
| [i_resolution](#nodebpy.nodes.geometry.SetSplineResolution.i_resolution) | Input socket: Resolution |
| [i_selection](#nodebpy.nodes.geometry.SetSplineResolution.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetSplineResolution.name) |  |
| [node](#nodebpy.nodes.geometry.SetSplineResolution.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SetSplineResolution.o_geometry) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SetSplineResolution.tree) |  |
| [type](#nodebpy.nodes.geometry.SetSplineResolution.type) |  |

### SetSplineType { #nodebpy.nodes.geometry.SetSplineType }

```python
nodes.geometry.SetSplineType(curve=None, selection=True, *, spline_type='POLY')
```

Change the type of curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetSplineType.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.geometry.SetSplineType.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SetSplineType.name) |  |
| [node](#nodebpy.nodes.geometry.SetSplineType.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SetSplineType.o_curve) | Output socket: Curve |
| [spline_type](#nodebpy.nodes.geometry.SetSplineType.spline_type) |  |
| [tree](#nodebpy.nodes.geometry.SetSplineType.tree) |  |
| [type](#nodebpy.nodes.geometry.SetSplineType.type) |  |

### SortElements { #nodebpy.nodes.geometry.SortElements }

```python
nodes.geometry.SortElements(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
    *,
    domain='POINT',
)
```

Rearrange geometry elements, changing their indices

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SortElements.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SortElements.i_geometry) | Input socket: Geometry |
| [i_group_id](#nodebpy.nodes.geometry.SortElements.i_group_id) | Input socket: Group ID |
| [i_selection](#nodebpy.nodes.geometry.SortElements.i_selection) | Input socket: Selection |
| [i_sort_weight](#nodebpy.nodes.geometry.SortElements.i_sort_weight) | Input socket: Sort Weight |
| [name](#nodebpy.nodes.geometry.SortElements.name) |  |
| [node](#nodebpy.nodes.geometry.SortElements.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.SortElements.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.SortElements.tree) |  |
| [type](#nodebpy.nodes.geometry.SortElements.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SortElements.edge) | Create Sort Elements with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SortElements.face) | Create Sort Elements with operation 'Face'. |
| [instance](#nodebpy.nodes.geometry.SortElements.instance) | Create Sort Elements with operation 'Instance'. |
| [point](#nodebpy.nodes.geometry.SortElements.point) | Create Sort Elements with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.SortElements.spline) | Create Sort Elements with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.SortElements.edge }

```python
nodes.geometry.SortElements.edge(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
)
```

Create Sort Elements with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SortElements.face }

```python
nodes.geometry.SortElements.face(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
)
```

Create Sort Elements with operation 'Face'.

##### instance { #nodebpy.nodes.geometry.SortElements.instance }

```python
nodes.geometry.SortElements.instance(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
)
```

Create Sort Elements with operation 'Instance'.

##### point { #nodebpy.nodes.geometry.SortElements.point }

```python
nodes.geometry.SortElements.point(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
)
```

Create Sort Elements with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.SortElements.spline }

```python
nodes.geometry.SortElements.spline(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
)
```

Create Sort Elements with operation 'Spline'.

### Spiral { #nodebpy.nodes.geometry.Spiral }

```python
nodes.geometry.Spiral(
    resolution=32,
    rotations=2.0,
    start_radius=1.0,
    end_radius=2.0,
    height=2.0,
    reverse=False,
)
```

Generate a poly spline in a spiral shape

#### Attributes

| Name | Description |
| --- | --- |
| [i_end_radius](#nodebpy.nodes.geometry.Spiral.i_end_radius) | Input socket: End Radius |
| [i_height](#nodebpy.nodes.geometry.Spiral.i_height) | Input socket: Height |
| [i_resolution](#nodebpy.nodes.geometry.Spiral.i_resolution) | Input socket: Resolution |
| [i_reverse](#nodebpy.nodes.geometry.Spiral.i_reverse) | Input socket: Reverse |
| [i_rotations](#nodebpy.nodes.geometry.Spiral.i_rotations) | Input socket: Rotations |
| [i_start_radius](#nodebpy.nodes.geometry.Spiral.i_start_radius) | Input socket: Start Radius |
| [name](#nodebpy.nodes.geometry.Spiral.name) |  |
| [node](#nodebpy.nodes.geometry.Spiral.node) |  |
| [o_curve](#nodebpy.nodes.geometry.Spiral.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.Spiral.tree) |  |
| [type](#nodebpy.nodes.geometry.Spiral.type) |  |

### SplitEdges { #nodebpy.nodes.geometry.SplitEdges }

```python
nodes.geometry.SplitEdges(mesh=None, selection=True)
```

Duplicate mesh edges and break connections with the surrounding faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.SplitEdges.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SplitEdges.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SplitEdges.name) |  |
| [node](#nodebpy.nodes.geometry.SplitEdges.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.SplitEdges.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SplitEdges.tree) |  |
| [type](#nodebpy.nodes.geometry.SplitEdges.type) |  |

### SplitToInstances { #nodebpy.nodes.geometry.SplitToInstances }

```python
nodes.geometry.SplitToInstances(
    geometry=None,
    selection=True,
    group_id=0,
    *,
    domain='POINT',
)
```

Create separate geometries containing the elements from the same group

#### Attributes

| Name | Description |
| --- | --- |
| [domain](#nodebpy.nodes.geometry.SplitToInstances.domain) |  |
| [i_geometry](#nodebpy.nodes.geometry.SplitToInstances.i_geometry) | Input socket: Geometry |
| [i_group_id](#nodebpy.nodes.geometry.SplitToInstances.i_group_id) | Input socket: Group ID |
| [i_selection](#nodebpy.nodes.geometry.SplitToInstances.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.SplitToInstances.name) |  |
| [node](#nodebpy.nodes.geometry.SplitToInstances.node) |  |
| [o_group_id](#nodebpy.nodes.geometry.SplitToInstances.o_group_id) | Output socket: Group ID |
| [o_instances](#nodebpy.nodes.geometry.SplitToInstances.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.SplitToInstances.tree) |  |
| [type](#nodebpy.nodes.geometry.SplitToInstances.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [edge](#nodebpy.nodes.geometry.SplitToInstances.edge) | Create Split to Instances with operation 'Edge'. |
| [face](#nodebpy.nodes.geometry.SplitToInstances.face) | Create Split to Instances with operation 'Face'. |
| [instance](#nodebpy.nodes.geometry.SplitToInstances.instance) | Create Split to Instances with operation 'Instance'. |
| [layer](#nodebpy.nodes.geometry.SplitToInstances.layer) | Create Split to Instances with operation 'Layer'. |
| [point](#nodebpy.nodes.geometry.SplitToInstances.point) | Create Split to Instances with operation 'Point'. |
| [spline](#nodebpy.nodes.geometry.SplitToInstances.spline) | Create Split to Instances with operation 'Spline'. |

##### edge { #nodebpy.nodes.geometry.SplitToInstances.edge }

```python
nodes.geometry.SplitToInstances.edge(geometry=None, selection=True, group_id=0)
```

Create Split to Instances with operation 'Edge'.

##### face { #nodebpy.nodes.geometry.SplitToInstances.face }

```python
nodes.geometry.SplitToInstances.face(geometry=None, selection=True, group_id=0)
```

Create Split to Instances with operation 'Face'.

##### instance { #nodebpy.nodes.geometry.SplitToInstances.instance }

```python
nodes.geometry.SplitToInstances.instance(
    geometry=None,
    selection=True,
    group_id=0,
)
```

Create Split to Instances with operation 'Instance'.

##### layer { #nodebpy.nodes.geometry.SplitToInstances.layer }

```python
nodes.geometry.SplitToInstances.layer(geometry=None, selection=True, group_id=0)
```

Create Split to Instances with operation 'Layer'.

##### point { #nodebpy.nodes.geometry.SplitToInstances.point }

```python
nodes.geometry.SplitToInstances.point(geometry=None, selection=True, group_id=0)
```

Create Split to Instances with operation 'Point'.

##### spline { #nodebpy.nodes.geometry.SplitToInstances.spline }

```python
nodes.geometry.SplitToInstances.spline(
    geometry=None,
    selection=True,
    group_id=0,
)
```

Create Split to Instances with operation 'Spline'.

### Star { #nodebpy.nodes.geometry.Star }

```python
nodes.geometry.Star(points=8, inner_radius=1.0, outer_radius=2.0, twist=0.0)
```

Generate a poly spline in a star pattern by connecting alternating points of two circles

#### Attributes

| Name | Description |
| --- | --- |
| [i_inner_radius](#nodebpy.nodes.geometry.Star.i_inner_radius) | Input socket: Inner Radius |
| [i_outer_radius](#nodebpy.nodes.geometry.Star.i_outer_radius) | Input socket: Outer Radius |
| [i_points](#nodebpy.nodes.geometry.Star.i_points) | Input socket: Points |
| [i_twist](#nodebpy.nodes.geometry.Star.i_twist) | Input socket: Twist |
| [name](#nodebpy.nodes.geometry.Star.name) |  |
| [node](#nodebpy.nodes.geometry.Star.node) |  |
| [o_curve](#nodebpy.nodes.geometry.Star.o_curve) | Output socket: Curve |
| [o_outer_points](#nodebpy.nodes.geometry.Star.o_outer_points) | Output socket: Outer Points |
| [tree](#nodebpy.nodes.geometry.Star.tree) |  |
| [type](#nodebpy.nodes.geometry.Star.type) |  |

### StringToCurves { #nodebpy.nodes.geometry.StringToCurves }

```python
nodes.geometry.StringToCurves(
    string='',
    size=1.0,
    character_spacing=1.0,
    word_spacing=1.0,
    line_spacing=1.0,
    text_box_width=0.0,
    text_box_height=0.0,
    *,
    overflow='OVERFLOW',
    align_x='LEFT',
    align_y='TOP_BASELINE',
    pivot_mode='BOTTOM_LEFT',
)
```

Generate a paragraph of text with a specific font, using a curve instance to store each character

#### Attributes

| Name | Description |
| --- | --- |
| [align_x](#nodebpy.nodes.geometry.StringToCurves.align_x) |  |
| [align_y](#nodebpy.nodes.geometry.StringToCurves.align_y) |  |
| [i_character_spacing](#nodebpy.nodes.geometry.StringToCurves.i_character_spacing) | Input socket: Character Spacing |
| [i_line_spacing](#nodebpy.nodes.geometry.StringToCurves.i_line_spacing) | Input socket: Line Spacing |
| [i_size](#nodebpy.nodes.geometry.StringToCurves.i_size) | Input socket: Size |
| [i_string](#nodebpy.nodes.geometry.StringToCurves.i_string) | Input socket: String |
| [i_text_box_height](#nodebpy.nodes.geometry.StringToCurves.i_text_box_height) | Input socket: Text Box Height |
| [i_text_box_width](#nodebpy.nodes.geometry.StringToCurves.i_text_box_width) | Input socket: Text Box Width |
| [i_word_spacing](#nodebpy.nodes.geometry.StringToCurves.i_word_spacing) | Input socket: Word Spacing |
| [name](#nodebpy.nodes.geometry.StringToCurves.name) |  |
| [node](#nodebpy.nodes.geometry.StringToCurves.node) |  |
| [o_curve_instances](#nodebpy.nodes.geometry.StringToCurves.o_curve_instances) | Output socket: Curve Instances |
| [o_line](#nodebpy.nodes.geometry.StringToCurves.o_line) | Output socket: Line |
| [o_pivot_point](#nodebpy.nodes.geometry.StringToCurves.o_pivot_point) | Output socket: Pivot Point |
| [o_remainder](#nodebpy.nodes.geometry.StringToCurves.o_remainder) | Output socket: Remainder |
| [overflow](#nodebpy.nodes.geometry.StringToCurves.overflow) |  |
| [pivot_mode](#nodebpy.nodes.geometry.StringToCurves.pivot_mode) |  |
| [tree](#nodebpy.nodes.geometry.StringToCurves.tree) |  |
| [type](#nodebpy.nodes.geometry.StringToCurves.type) |  |

### SubdivideCurve { #nodebpy.nodes.geometry.SubdivideCurve }

```python
nodes.geometry.SubdivideCurve(curve=None, cuts=1)
```

Dividing each curve segment into a specified number of pieces

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SubdivideCurve.i_curve) | Input socket: Curve |
| [i_cuts](#nodebpy.nodes.geometry.SubdivideCurve.i_cuts) | Input socket: Cuts |
| [name](#nodebpy.nodes.geometry.SubdivideCurve.name) |  |
| [node](#nodebpy.nodes.geometry.SubdivideCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.SubdivideCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.SubdivideCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.SubdivideCurve.type) |  |

### SubdivideMesh { #nodebpy.nodes.geometry.SubdivideMesh }

```python
nodes.geometry.SubdivideMesh(mesh=None, level=1)
```

Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_level](#nodebpy.nodes.geometry.SubdivideMesh.i_level) | Input socket: Level |
| [i_mesh](#nodebpy.nodes.geometry.SubdivideMesh.i_mesh) | Input socket: Mesh |
| [name](#nodebpy.nodes.geometry.SubdivideMesh.name) |  |
| [node](#nodebpy.nodes.geometry.SubdivideMesh.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.SubdivideMesh.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SubdivideMesh.tree) |  |
| [type](#nodebpy.nodes.geometry.SubdivideMesh.type) |  |

### SubdivisionSurface { #nodebpy.nodes.geometry.SubdivisionSurface }

```python
nodes.geometry.SubdivisionSurface(
    mesh=None,
    level=1,
    edge_crease=0.0,
    vertex_crease=0.0,
    limit_surface=True,
    uv_smooth='Keep Boundaries',
    boundary_smooth='All',
)
```

Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method

#### Attributes

| Name | Description |
| --- | --- |
| [i_boundary_smooth](#nodebpy.nodes.geometry.SubdivisionSurface.i_boundary_smooth) | Input socket: Boundary Smooth |
| [i_edge_crease](#nodebpy.nodes.geometry.SubdivisionSurface.i_edge_crease) | Input socket: Edge Crease |
| [i_level](#nodebpy.nodes.geometry.SubdivisionSurface.i_level) | Input socket: Level |
| [i_limit_surface](#nodebpy.nodes.geometry.SubdivisionSurface.i_limit_surface) | Input socket: Limit Surface |
| [i_mesh](#nodebpy.nodes.geometry.SubdivisionSurface.i_mesh) | Input socket: Mesh |
| [i_uv_smooth](#nodebpy.nodes.geometry.SubdivisionSurface.i_uv_smooth) | Input socket: UV Smooth |
| [i_vertex_crease](#nodebpy.nodes.geometry.SubdivisionSurface.i_vertex_crease) | Input socket: Vertex Crease |
| [name](#nodebpy.nodes.geometry.SubdivisionSurface.name) |  |
| [node](#nodebpy.nodes.geometry.SubdivisionSurface.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.SubdivisionSurface.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.SubdivisionSurface.tree) |  |
| [type](#nodebpy.nodes.geometry.SubdivisionSurface.type) |  |

### TransformGeometry { #nodebpy.nodes.geometry.TransformGeometry }

```python
nodes.geometry.TransformGeometry(
    geometry=None,
    mode='Components',
    translation=None,
    rotation=None,
    scale=None,
    transform=None,
)
```

Translate, rotate or scale the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.TransformGeometry.i_geometry) | Input socket: Geometry |
| [i_mode](#nodebpy.nodes.geometry.TransformGeometry.i_mode) | Input socket: Mode |
| [i_rotation](#nodebpy.nodes.geometry.TransformGeometry.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.geometry.TransformGeometry.i_scale) | Input socket: Scale |
| [i_transform](#nodebpy.nodes.geometry.TransformGeometry.i_transform) | Input socket: Transform |
| [i_translation](#nodebpy.nodes.geometry.TransformGeometry.i_translation) | Input socket: Translation |
| [name](#nodebpy.nodes.geometry.TransformGeometry.name) |  |
| [node](#nodebpy.nodes.geometry.TransformGeometry.node) |  |
| [o_geometry](#nodebpy.nodes.geometry.TransformGeometry.o_geometry) | Output socket: Geometry |
| [tree](#nodebpy.nodes.geometry.TransformGeometry.tree) |  |
| [type](#nodebpy.nodes.geometry.TransformGeometry.type) |  |

### TranslateInstances { #nodebpy.nodes.geometry.TranslateInstances }

```python
nodes.geometry.TranslateInstances(
    instances=None,
    selection=True,
    translation=None,
    local_space=True,
)
```

Move top-level geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.TranslateInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.TranslateInstances.i_local_space) | Input socket: Local Space |
| [i_selection](#nodebpy.nodes.geometry.TranslateInstances.i_selection) | Input socket: Selection |
| [i_translation](#nodebpy.nodes.geometry.TranslateInstances.i_translation) | Input socket: Translation |
| [name](#nodebpy.nodes.geometry.TranslateInstances.name) |  |
| [node](#nodebpy.nodes.geometry.TranslateInstances.node) |  |
| [o_instances](#nodebpy.nodes.geometry.TranslateInstances.o_instances) | Output socket: Instances |
| [tree](#nodebpy.nodes.geometry.TranslateInstances.tree) |  |
| [type](#nodebpy.nodes.geometry.TranslateInstances.type) |  |

### Triangulate { #nodebpy.nodes.geometry.Triangulate }

```python
nodes.geometry.Triangulate(
    mesh=None,
    selection=True,
    quad_method='Shortest Diagonal',
    n_gon_method='Beauty',
)
```

Convert all faces in a mesh to triangular faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.Triangulate.i_mesh) | Input socket: Mesh |
| [i_n_gon_method](#nodebpy.nodes.geometry.Triangulate.i_n_gon_method) | Input socket: N-gon Method |
| [i_quad_method](#nodebpy.nodes.geometry.Triangulate.i_quad_method) | Input socket: Quad Method |
| [i_selection](#nodebpy.nodes.geometry.Triangulate.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.geometry.Triangulate.name) |  |
| [node](#nodebpy.nodes.geometry.Triangulate.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.Triangulate.o_mesh) | Output socket: Mesh |
| [tree](#nodebpy.nodes.geometry.Triangulate.tree) |  |
| [type](#nodebpy.nodes.geometry.Triangulate.type) |  |

### TrimCurve { #nodebpy.nodes.geometry.TrimCurve }

```python
nodes.geometry.TrimCurve(
    curve=None,
    selection=True,
    start=0.0,
    end=1.0,
    start_001=0.0,
    end_001=1.0,
    *,
    mode='FACTOR',
)
```

Shorten curves by removing portions at the start or end

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.TrimCurve.i_curve) | Input socket: Curve |
| [i_end](#nodebpy.nodes.geometry.TrimCurve.i_end) | Input socket: End |
| [i_end_001](#nodebpy.nodes.geometry.TrimCurve.i_end_001) | Input socket: End |
| [i_selection](#nodebpy.nodes.geometry.TrimCurve.i_selection) | Input socket: Selection |
| [i_start](#nodebpy.nodes.geometry.TrimCurve.i_start) | Input socket: Start |
| [i_start_001](#nodebpy.nodes.geometry.TrimCurve.i_start_001) | Input socket: Start |
| [mode](#nodebpy.nodes.geometry.TrimCurve.mode) |  |
| [name](#nodebpy.nodes.geometry.TrimCurve.name) |  |
| [node](#nodebpy.nodes.geometry.TrimCurve.node) |  |
| [o_curve](#nodebpy.nodes.geometry.TrimCurve.o_curve) | Output socket: Curve |
| [tree](#nodebpy.nodes.geometry.TrimCurve.tree) |  |
| [type](#nodebpy.nodes.geometry.TrimCurve.type) |  |

### UVSphere { #nodebpy.nodes.geometry.UVSphere }

```python
nodes.geometry.UVSphere(segments=32, rings=16, radius=1.0)
```

Generate a spherical mesh with quads, except for triangles at the top and bottom

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.geometry.UVSphere.i_radius) | Input socket: Radius |
| [i_rings](#nodebpy.nodes.geometry.UVSphere.i_rings) | Input socket: Rings |
| [i_segments](#nodebpy.nodes.geometry.UVSphere.i_segments) | Input socket: Segments |
| [name](#nodebpy.nodes.geometry.UVSphere.name) |  |
| [node](#nodebpy.nodes.geometry.UVSphere.node) |  |
| [o_mesh](#nodebpy.nodes.geometry.UVSphere.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.geometry.UVSphere.o_uv_map) | Output socket: UV Map |
| [tree](#nodebpy.nodes.geometry.UVSphere.tree) |  |
| [type](#nodebpy.nodes.geometry.UVSphere.type) |  |