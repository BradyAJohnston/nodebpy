# nodes.geometry { #nodebpy.nodes.geometry }

`nodes.geometry`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [AccumulateField](#nodebpy.nodes.geometry.AccumulateField) | Add the values of an evaluated field together and output the running total for each element |
| [ActiveElement](#nodebpy.nodes.geometry.ActiveElement) | Active element indices of the edited geometry, for tool execution |
| [AdvectGrid](#nodebpy.nodes.geometry.AdvectGrid) | Move grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs |
| [Bake](#nodebpy.nodes.geometry.Bake) | Cache the incoming data so that it can be used without recomputation |
| [BoundingBox](#nodebpy.nodes.geometry.BoundingBox) | Calculate the limits of a geometry's positions and generate a box mesh with those dimensions |
| [CameraInfo](#nodebpy.nodes.geometry.CameraInfo) | Retrieve information from a camera object |
| [CollectionInfo](#nodebpy.nodes.geometry.CollectionInfo) | Retrieve geometry instances from a collection |
| [ConvexHull](#nodebpy.nodes.geometry.ConvexHull) | Create a mesh that encloses all points in the input geometry with the smallest number of points |
| [CornersOfEdge](#nodebpy.nodes.geometry.CornersOfEdge) | Retrieve face corners connected to edges |
| [CornersOfFace](#nodebpy.nodes.geometry.CornersOfFace) | Retrieve corners that make up a face |
| [CornersOfVertex](#nodebpy.nodes.geometry.CornersOfVertex) | Retrieve face corners connected to vertices |
| [DCursor3](#nodebpy.nodes.geometry.DCursor3) | The scene's 3D cursor location and rotation |
| [DeleteGeometry](#nodebpy.nodes.geometry.DeleteGeometry) | Remove selected elements of a geometry |
| [DialGizmo](#nodebpy.nodes.geometry.DialGizmo) | Show a dial gizmo in the viewport for a value |
| [DistributePointsInGrid](#nodebpy.nodes.geometry.DistributePointsInGrid) | Generate points inside a volume grid |
| [DistributePointsInVolume](#nodebpy.nodes.geometry.DistributePointsInVolume) | Generate points inside a volume |
| [DistributePointsOnFaces](#nodebpy.nodes.geometry.DistributePointsOnFaces) | Generate points spread out on the surface of a mesh |
| [DuplicateElements](#nodebpy.nodes.geometry.DuplicateElements) | Generate an arbitrary number copies of each selected input element |
| [EdgePathsToSelection](#nodebpy.nodes.geometry.EdgePathsToSelection) | Output a selection of edges by following paths across mesh edges |
| [EdgesOfCorner](#nodebpy.nodes.geometry.EdgesOfCorner) | Retrieve the edges on both sides of a face corner |
| [EdgesOfVertex](#nodebpy.nodes.geometry.EdgesOfVertex) | Retrieve the edges connected to each vertex |
| [EdgesToFaceGroups](#nodebpy.nodes.geometry.EdgesToFaceGroups) | Group faces into regions surrounded by the selected boundary edges |
| [EvaluateAtIndex](#nodebpy.nodes.geometry.EvaluateAtIndex) | Retrieve data of other elements in the context's geometry |
| [EvaluateOnDomain](#nodebpy.nodes.geometry.EvaluateOnDomain) | Retrieve values from a field on a different domain besides the domain from the context |
| [FaceOfCorner](#nodebpy.nodes.geometry.FaceOfCorner) | Retrieve the face each face corner is part of |
| [FaceSet](#nodebpy.nodes.geometry.FaceSet) | Each face's sculpt face set value |
| [FieldAverage](#nodebpy.nodes.geometry.FieldAverage) | Calculate the mean and median of a given field |
| [FieldMinMax](#nodebpy.nodes.geometry.FieldMinMax) | Calculate the minimum and maximum of a given field |
| [FieldToGrid](#nodebpy.nodes.geometry.FieldToGrid) | Create new grids by evaluating new values on an existing volume grid topology |
| [FieldVariance](#nodebpy.nodes.geometry.FieldVariance) | Calculate the standard deviation and variance of a given field |
| [FlipFaces](#nodebpy.nodes.geometry.FlipFaces) | Reverse the order of the vertices and edges of selected faces, flipping their normal direction |
| [ForEachGeometryElementOutput](#nodebpy.nodes.geometry.ForEachGeometryElementOutput) | For Each Geometry Element Output node |
| [GeometryProximity](#nodebpy.nodes.geometry.GeometryProximity) | Compute the closest location on the target geometry |
| [GeometryToInstance](#nodebpy.nodes.geometry.GeometryToInstance) | Convert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large |
| [GetListItem](#nodebpy.nodes.geometry.GetListItem) | Retrieve a value from a list |
| [GetNamedGrid](#nodebpy.nodes.geometry.GetNamedGrid) | Get volume grid from a volume geometry with the specified name |
| [GridCurl](#nodebpy.nodes.geometry.GridCurl) | Calculate the magnitude and direction of circulation of a directional vector grid |
| [GridDivergence](#nodebpy.nodes.geometry.GridDivergence) | Calculate the flow into and out of each point of a directional vector grid |
| [GridGradient](#nodebpy.nodes.geometry.GridGradient) | Calculate the direction and magnitude of the change in values of a scalar grid |
| [GridInfo](#nodebpy.nodes.geometry.GridInfo) | Retrieve information about a volume grid |
| [GridLaplacian](#nodebpy.nodes.geometry.GridLaplacian) | Compute the divergence of the gradient of the input grid |
| [Group](#nodebpy.nodes.geometry.Group) | Group node |
| [ImageInfo](#nodebpy.nodes.geometry.ImageInfo) | Retrieve information about an image |
| [ImageTexture](#nodebpy.nodes.geometry.ImageTexture) | Sample values from an image texture |
| [ImportCSV](#nodebpy.nodes.geometry.ImportCSV) | Import geometry from an CSV file |
| [ImportOBJ](#nodebpy.nodes.geometry.ImportOBJ) | Import geometry from an OBJ file |
| [ImportPLY](#nodebpy.nodes.geometry.ImportPLY) | Import a point cloud from a PLY file |
| [ImportSTL](#nodebpy.nodes.geometry.ImportSTL) | Import a mesh from an STL file |
| [ImportText](#nodebpy.nodes.geometry.ImportText) | Import a string from a text file |
| [ImportVDB](#nodebpy.nodes.geometry.ImportVDB) | Import volume data from a .vdb file |
| [IndexOfNearest](#nodebpy.nodes.geometry.IndexOfNearest) | Find the nearest element in a group. Similar to the "Sample Nearest" node |
| [InstanceOnPoints](#nodebpy.nodes.geometry.InstanceOnPoints) | Generate a reference to geometry at each of the input points, without duplicating its underlying data |
| [InstanceTransform](#nodebpy.nodes.geometry.InstanceTransform) | Retrieve the full transformation of each instance in the geometry |
| [InstancesToPoints](#nodebpy.nodes.geometry.InstancesToPoints) | Generate points at the origins of instances. |
| [IsViewport](#nodebpy.nodes.geometry.IsViewport) | Retrieve whether the nodes are being evaluated for the viewport rather than the final render |
| [JoinStrings](#nodebpy.nodes.geometry.JoinStrings) | Combine any number of input strings |
| [LinearGizmo](#nodebpy.nodes.geometry.LinearGizmo) | Show a linear gizmo in the viewport for a value |
| [List](#nodebpy.nodes.geometry.List) | Create a list of values |
| [ListLength](#nodebpy.nodes.geometry.ListLength) | Count how many items are in a given list |
| [MaterialSelection](#nodebpy.nodes.geometry.MaterialSelection) | Provide a selection of faces that use the specified material |
| [MergeByDistance](#nodebpy.nodes.geometry.MergeByDistance) | Merge vertices or points within a given distance |
| [MergeLayers](#nodebpy.nodes.geometry.MergeLayers) | Join groups of Grease Pencil layers into one |
| [MousePosition](#nodebpy.nodes.geometry.MousePosition) | Retrieve the position of the mouse cursor |
| [ObjectInfo](#nodebpy.nodes.geometry.ObjectInfo) | Retrieve information from an object |
| [OffsetCornerInFace](#nodebpy.nodes.geometry.OffsetCornerInFace) | Retrieve corners in the same face as another |
| [PackUVIslands](#nodebpy.nodes.geometry.PackUVIslands) | Scale islands of a UV map and move them so they fill the UV space as much as possible |
| [Points](#nodebpy.nodes.geometry.Points) | Generate a point cloud with positions and radii defined by fields |
| [PointsToSDFGrid](#nodebpy.nodes.geometry.PointsToSDFGrid) | Create a signed distance volume grid from points |
| [PointsToVertices](#nodebpy.nodes.geometry.PointsToVertices) | Generate a mesh vertex for each point cloud point |
| [PointsToVolume](#nodebpy.nodes.geometry.PointsToVolume) | Generate a fog volume sphere around every point |
| [PruneGrid](#nodebpy.nodes.geometry.PruneGrid) | Make the storage of a volume grid more efficient by collapsing data into tiles or inner nodes |
| [Raycast](#nodebpy.nodes.geometry.Raycast) | Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point |
| [RealizeInstances](#nodebpy.nodes.geometry.RealizeInstances) | Convert instances into real geometry data |
| [ReplaceMaterial](#nodebpy.nodes.geometry.ReplaceMaterial) | Swap one material with another |
| [RotateInstances](#nodebpy.nodes.geometry.RotateInstances) | Rotate geometry instances in local or global space |
| [SDFGridBoolean](#nodebpy.nodes.geometry.SDFGridBoolean) | Cut, subtract, or join multiple SDF volume grid inputs |
| [SDFGridFillet](#nodebpy.nodes.geometry.SDFGridFillet) | Round off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces |
| [SDFGridLaplacian](#nodebpy.nodes.geometry.SDFGridLaplacian) | Apply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization |
| [SDFGridMean](#nodebpy.nodes.geometry.SDFGridMean) | Apply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field |
| [SDFGridMeanCurvature](#nodebpy.nodes.geometry.SDFGridMeanCurvature) | Apply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas |
| [SDFGridMedian](#nodebpy.nodes.geometry.SDFGridMedian) | Apply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field |
| [SDFGridOffset](#nodebpy.nodes.geometry.SDFGridOffset) | Offset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property |
| [SampleGrid](#nodebpy.nodes.geometry.SampleGrid) | Retrieve values from the specified volume grid |
| [SampleGridIndex](#nodebpy.nodes.geometry.SampleGridIndex) | Retrieve volume grid values at specific voxels |
| [SampleIndex](#nodebpy.nodes.geometry.SampleIndex) | Retrieve values from specific geometry elements |
| [SampleNearest](#nodebpy.nodes.geometry.SampleNearest) | Find the element of a geometry closest to a position. Similar to the "Index of Nearest" node |
| [SampleNearestSurface](#nodebpy.nodes.geometry.SampleNearestSurface) | Calculate the interpolated value of a mesh attribute on the closest point of its surface |
| [SampleUVSurface](#nodebpy.nodes.geometry.SampleUVSurface) | Calculate the interpolated values of a mesh attribute at a UV coordinate |
| [ScaleElements](#nodebpy.nodes.geometry.ScaleElements) | Scale groups of connected edges and faces |
| [ScaleInstances](#nodebpy.nodes.geometry.ScaleInstances) | Scale geometry instances in local or global space |
| [Selection](#nodebpy.nodes.geometry.Selection) | User selection of the edited geometry, for tool execution |
| [SelfObject](#nodebpy.nodes.geometry.SelfObject) | Retrieve the object that contains the geometry nodes modifier currently being executed |
| [SeparateComponents](#nodebpy.nodes.geometry.SeparateComponents) | Split a geometry into a separate output for each type of data in the geometry |
| [SeparateGeometry](#nodebpy.nodes.geometry.SeparateGeometry) | Split a geometry into two geometry outputs based on a selection |
| [SetFaceSet](#nodebpy.nodes.geometry.SetFaceSet) | Set sculpt face set values for faces |
| [SetGeometryName](#nodebpy.nodes.geometry.SetGeometryName) | Set the name of a geometry for easier debugging |
| [SetGreasePencilColor](#nodebpy.nodes.geometry.SetGreasePencilColor) | Set color and opacity attributes on Grease Pencil geometry |
| [SetGreasePencilDepth](#nodebpy.nodes.geometry.SetGreasePencilDepth) | Set the Grease Pencil depth order to use |
| [SetGreasePencilSoftness](#nodebpy.nodes.geometry.SetGreasePencilSoftness) | Set softness attribute on Grease Pencil geometry |
| [SetGridBackground](#nodebpy.nodes.geometry.SetGridBackground) | Set the background value used for inactive voxels and tiles |
| [SetGridTransform](#nodebpy.nodes.geometry.SetGridTransform) | Set the transform for the grid from index space into object space. |
| [SetID](#nodebpy.nodes.geometry.SetID) | Set the id attribute on the input geometry, mainly used internally for randomizing |
| [SetInstanceTransform](#nodebpy.nodes.geometry.SetInstanceTransform) | Set the transformation matrix of every instance |
| [SetMaterial](#nodebpy.nodes.geometry.SetMaterial) | Assign a material to geometry elements |
| [SetMaterialIndex](#nodebpy.nodes.geometry.SetMaterialIndex) | Set the material index for each selected geometry element |
| [SetPointRadius](#nodebpy.nodes.geometry.SetPointRadius) | Set the display size of point cloud points |
| [SetPosition](#nodebpy.nodes.geometry.SetPosition) | Set the location of each point |
| [SetSelection](#nodebpy.nodes.geometry.SetSelection) | Set selection of the edited geometry, for tool execution |
| [SetShadeSmooth](#nodebpy.nodes.geometry.SetShadeSmooth) | Control the smoothness of mesh normals around each face by changing the "shade smooth" attribute |
| [SetSplineCyclic](#nodebpy.nodes.geometry.SetSplineCyclic) | Control whether each spline loops back on itself by changing the "cyclic" attribute |
| [SetSplineResolution](#nodebpy.nodes.geometry.SetSplineResolution) | Control how many evaluated points should be generated on every curve segment |
| [SortElements](#nodebpy.nodes.geometry.SortElements) | Rearrange geometry elements, changing their indices |
| [SplineLength](#nodebpy.nodes.geometry.SplineLength) | Retrieve the total length of each spline, as a distance or as a number of points |
| [SplineParameter](#nodebpy.nodes.geometry.SplineParameter) | Retrieve how far along each spline a control point is |
| [SplitEdges](#nodebpy.nodes.geometry.SplitEdges) | Duplicate mesh edges and break connections with the surrounding faces |
| [SplitToInstances](#nodebpy.nodes.geometry.SplitToInstances) | Create separate geometries containing the elements from the same group |
| [StoreNamedGrid](#nodebpy.nodes.geometry.StoreNamedGrid) | Store grid data in a volume geometry with the specified name |
| [SubdivisionSurface](#nodebpy.nodes.geometry.SubdivisionSurface) | Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method |
| [Switch](#nodebpy.nodes.geometry.Switch) | Switch between two inputs |
| [TransformGeometry](#nodebpy.nodes.geometry.TransformGeometry) | Translate, rotate or scale the geometry |
| [TransformGizmo](#nodebpy.nodes.geometry.TransformGizmo) | Show a transform gizmo in the viewport |
| [TranslateInstances](#nodebpy.nodes.geometry.TranslateInstances) | Move top-level geometry instances in local or global space |
| [Triangulate](#nodebpy.nodes.geometry.Triangulate) | Convert all faces in a mesh to triangular faces |
| [UVTangent](#nodebpy.nodes.geometry.UVTangent) | Generate tangent directions based on a UV map |
| [UVUnwrap](#nodebpy.nodes.geometry.UVUnwrap) | Generate a UV map based on seam edges |
| [VertexOfCorner](#nodebpy.nodes.geometry.VertexOfCorner) | Retrieve the vertex each face corner is attached to |
| [Viewer](#nodebpy.nodes.geometry.Viewer) | Display the input data in the Spreadsheet Editor |
| [ViewportTransform](#nodebpy.nodes.geometry.ViewportTransform) | Retrieve the view direction and location of the 3D viewport |
| [VolumeCube](#nodebpy.nodes.geometry.VolumeCube) | Generate a dense volume with a field that controls the density at each grid voxel based on its position |
| [VoxelizeGrid](#nodebpy.nodes.geometry.VoxelizeGrid) | Remove sparseness from a volume grid by making the active tiles into voxels |
| [Warning](#nodebpy.nodes.geometry.Warning) | Create custom warnings in node groups |

### AccumulateField { #nodebpy.nodes.geometry.AccumulateField }

```python
nodes.geometry.AccumulateField(
    value=1.0,
    group_index=0,
    data_type='FLOAT',
    domain='POINT',
    **kwargs,
)
```

Add the values of an evaluated field together and output the running total for each element

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.AccumulateField.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.geometry.AccumulateField.i_value) | Input socket: Value |
| [o_leading](#nodebpy.nodes.geometry.AccumulateField.o_leading) | Output socket: Leading |
| [o_total](#nodebpy.nodes.geometry.AccumulateField.o_total) | Output socket: Total |
| [o_trailing](#nodebpy.nodes.geometry.AccumulateField.o_trailing) | Output socket: Trailing |

### ActiveElement { #nodebpy.nodes.geometry.ActiveElement }

```python
nodes.geometry.ActiveElement(domain='POINT', **kwargs)
```

Active element indices of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [o_exists](#nodebpy.nodes.geometry.ActiveElement.o_exists) | Output socket: Exists |
| [o_index](#nodebpy.nodes.geometry.ActiveElement.o_index) | Output socket: Index |

### AdvectGrid { #nodebpy.nodes.geometry.AdvectGrid }

```python
nodes.geometry.AdvectGrid(
    grid=0.0,
    velocity=[0.0, 0.0, 0.0],
    time_step=1.0,
    integration_scheme='Runge-Kutta 3',
    limiter='Clamp',
    data_type='FLOAT',
    **kwargs,
)
```

Move grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.AdvectGrid.i_grid) | Input socket: Grid |
| [i_integration_scheme](#nodebpy.nodes.geometry.AdvectGrid.i_integration_scheme) | Input socket: Integration Scheme |
| [i_limiter](#nodebpy.nodes.geometry.AdvectGrid.i_limiter) | Input socket: Limiter |
| [i_time_step](#nodebpy.nodes.geometry.AdvectGrid.i_time_step) | Input socket: Time Step |
| [i_velocity](#nodebpy.nodes.geometry.AdvectGrid.i_velocity) | Input socket: Velocity |
| [o_grid](#nodebpy.nodes.geometry.AdvectGrid.o_grid) | Output socket: Grid |

### Bake { #nodebpy.nodes.geometry.Bake }

```python
nodes.geometry.Bake(extend=None, active_index=0, **kwargs)
```

Cache the incoming data so that it can be used without recomputation

#### Attributes

| Name | Description |
| --- | --- |
| [i_input_socket](#nodebpy.nodes.geometry.Bake.i_input_socket) | Input socket: |
| [o_input_socket](#nodebpy.nodes.geometry.Bake.o_input_socket) | Output socket: |

### BoundingBox { #nodebpy.nodes.geometry.BoundingBox }

```python
nodes.geometry.BoundingBox(geometry=None, use_radius=True, **kwargs)
```

Calculate the limits of a geometry's positions and generate a box mesh with those dimensions

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.BoundingBox.i_geometry) | Input socket: Geometry |
| [i_use_radius](#nodebpy.nodes.geometry.BoundingBox.i_use_radius) | Input socket: Use Radius |
| [o_bounding_box](#nodebpy.nodes.geometry.BoundingBox.o_bounding_box) | Output socket: Bounding Box |
| [o_max](#nodebpy.nodes.geometry.BoundingBox.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.geometry.BoundingBox.o_min) | Output socket: Min |

### CameraInfo { #nodebpy.nodes.geometry.CameraInfo }

```python
nodes.geometry.CameraInfo(camera=None, **kwargs)
```

Retrieve information from a camera object

#### Attributes

| Name | Description |
| --- | --- |
| [i_camera](#nodebpy.nodes.geometry.CameraInfo.i_camera) | Input socket: Camera |
| [o_clip_end](#nodebpy.nodes.geometry.CameraInfo.o_clip_end) | Output socket: Clip End |
| [o_clip_start](#nodebpy.nodes.geometry.CameraInfo.o_clip_start) | Output socket: Clip Start |
| [o_focal_length](#nodebpy.nodes.geometry.CameraInfo.o_focal_length) | Output socket: Focal Length |
| [o_focus_distance](#nodebpy.nodes.geometry.CameraInfo.o_focus_distance) | Output socket: Focus Distance |
| [o_is_orthographic](#nodebpy.nodes.geometry.CameraInfo.o_is_orthographic) | Output socket: Is Orthographic |
| [o_orthographic_scale](#nodebpy.nodes.geometry.CameraInfo.o_orthographic_scale) | Output socket: Orthographic Scale |
| [o_projection_matrix](#nodebpy.nodes.geometry.CameraInfo.o_projection_matrix) | Output socket: Projection Matrix |
| [o_sensor](#nodebpy.nodes.geometry.CameraInfo.o_sensor) | Output socket: Sensor |
| [o_shift](#nodebpy.nodes.geometry.CameraInfo.o_shift) | Output socket: Shift |

### CollectionInfo { #nodebpy.nodes.geometry.CollectionInfo }

```python
nodes.geometry.CollectionInfo(
    collection=None,
    separate_children=False,
    reset_children=False,
    transform_space='ORIGINAL',
    **kwargs,
)
```

Retrieve geometry instances from a collection

#### Attributes

| Name | Description |
| --- | --- |
| [i_collection](#nodebpy.nodes.geometry.CollectionInfo.i_collection) | Input socket: Collection |
| [i_reset_children](#nodebpy.nodes.geometry.CollectionInfo.i_reset_children) | Input socket: Reset Children |
| [i_separate_children](#nodebpy.nodes.geometry.CollectionInfo.i_separate_children) | Input socket: Separate Children |
| [o_instances](#nodebpy.nodes.geometry.CollectionInfo.o_instances) | Output socket: Instances |

### ConvexHull { #nodebpy.nodes.geometry.ConvexHull }

```python
nodes.geometry.ConvexHull(geometry=None, **kwargs)
```

Create a mesh that encloses all points in the input geometry with the smallest number of points

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.ConvexHull.i_geometry) | Input socket: Geometry |
| [o_convex_hull](#nodebpy.nodes.geometry.ConvexHull.o_convex_hull) | Output socket: Convex Hull |

### CornersOfEdge { #nodebpy.nodes.geometry.CornersOfEdge }

```python
nodes.geometry.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0, **kwargs)
```

Retrieve face corners connected to edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_index](#nodebpy.nodes.geometry.CornersOfEdge.i_edge_index) | Input socket: Edge Index |
| [i_sort_index](#nodebpy.nodes.geometry.CornersOfEdge.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.geometry.CornersOfEdge.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.geometry.CornersOfEdge.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.geometry.CornersOfEdge.o_total) | Output socket: Total |

### CornersOfFace { #nodebpy.nodes.geometry.CornersOfFace }

```python
nodes.geometry.CornersOfFace(face_index=0, weights=0.0, sort_index=0, **kwargs)
```

Retrieve corners that make up a face

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_index](#nodebpy.nodes.geometry.CornersOfFace.i_face_index) | Input socket: Face Index |
| [i_sort_index](#nodebpy.nodes.geometry.CornersOfFace.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.geometry.CornersOfFace.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.geometry.CornersOfFace.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.geometry.CornersOfFace.o_total) | Output socket: Total |

### CornersOfVertex { #nodebpy.nodes.geometry.CornersOfVertex }

```python
nodes.geometry.CornersOfVertex(
    vertex_index=0,
    weights=0.0,
    sort_index=0,
    **kwargs,
)
```

Retrieve face corners connected to vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.geometry.CornersOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.geometry.CornersOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.geometry.CornersOfVertex.i_weights) | Input socket: Weights |
| [o_corner_index](#nodebpy.nodes.geometry.CornersOfVertex.o_corner_index) | Output socket: Corner Index |
| [o_total](#nodebpy.nodes.geometry.CornersOfVertex.o_total) | Output socket: Total |

### DCursor3 { #nodebpy.nodes.geometry.DCursor3 }

```python
nodes.geometry.DCursor3(**kwargs)
```

The scene's 3D cursor location and rotation

#### Attributes

| Name | Description |
| --- | --- |
| [o_location](#nodebpy.nodes.geometry.DCursor3.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.geometry.DCursor3.o_rotation) | Output socket: Rotation |

### DeleteGeometry { #nodebpy.nodes.geometry.DeleteGeometry }

```python
nodes.geometry.DeleteGeometry(
    geometry=None,
    selection=True,
    mode='ALL',
    domain='POINT',
    **kwargs,
)
```

Remove selected elements of a geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.DeleteGeometry.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.DeleteGeometry.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.DeleteGeometry.o_geometry) | Output socket: Geometry |

### DialGizmo { #nodebpy.nodes.geometry.DialGizmo }

```python
nodes.geometry.DialGizmo(
    value=0.0,
    position=[0.0, 0.0, 0.0],
    up=[0.0, 0.0, 1.0],
    screen_space=True,
    radius=1.0,
    color_id='PRIMARY',
    **kwargs,
)
```

Show a dial gizmo in the viewport for a value

#### Attributes

| Name | Description |
| --- | --- |
| [i_position](#nodebpy.nodes.geometry.DialGizmo.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.DialGizmo.i_radius) | Input socket: Radius |
| [i_screen_space](#nodebpy.nodes.geometry.DialGizmo.i_screen_space) | Input socket: Screen Space |
| [i_up](#nodebpy.nodes.geometry.DialGizmo.i_up) | Input socket: Up |
| [i_value](#nodebpy.nodes.geometry.DialGizmo.i_value) | Input socket: Value |
| [o_transform](#nodebpy.nodes.geometry.DialGizmo.o_transform) | Output socket: Transform |

### DistributePointsInGrid { #nodebpy.nodes.geometry.DistributePointsInGrid }

```python
nodes.geometry.DistributePointsInGrid(
    grid=0.0,
    density=1.0,
    seed=0,
    mode='DENSITY_RANDOM',
    **kwargs,
)
```

Generate points inside a volume grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.geometry.DistributePointsInGrid.i_density) | Input socket: Density |
| [i_grid](#nodebpy.nodes.geometry.DistributePointsInGrid.i_grid) | Input socket: Grid |
| [i_seed](#nodebpy.nodes.geometry.DistributePointsInGrid.i_seed) | Input socket: Seed |
| [o_points](#nodebpy.nodes.geometry.DistributePointsInGrid.o_points) | Output socket: Points |

### DistributePointsInVolume { #nodebpy.nodes.geometry.DistributePointsInVolume }

```python
nodes.geometry.DistributePointsInVolume(
    volume=None,
    mode='Random',
    density=1.0,
    seed=0,
    spacing=[0.30000001192092896, 0.30000001192092896, 0.30000001192092896],
    threshold=0.10000000149011612,
    **kwargs,
)
```

Generate points inside a volume

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.geometry.DistributePointsInVolume.i_density) | Input socket: Density |
| [i_mode](#nodebpy.nodes.geometry.DistributePointsInVolume.i_mode) | Input socket: Mode |
| [i_seed](#nodebpy.nodes.geometry.DistributePointsInVolume.i_seed) | Input socket: Seed |
| [i_spacing](#nodebpy.nodes.geometry.DistributePointsInVolume.i_spacing) | Input socket: Spacing |
| [i_threshold](#nodebpy.nodes.geometry.DistributePointsInVolume.i_threshold) | Input socket: Threshold |
| [i_volume](#nodebpy.nodes.geometry.DistributePointsInVolume.i_volume) | Input socket: Volume |
| [o_points](#nodebpy.nodes.geometry.DistributePointsInVolume.o_points) | Output socket: Points |

### DistributePointsOnFaces { #nodebpy.nodes.geometry.DistributePointsOnFaces }

```python
nodes.geometry.DistributePointsOnFaces(
    mesh=None,
    selection=True,
    density=10.0,
    seed=0,
    distribute_method='RANDOM',
    use_legacy_normal=False,
    **kwargs,
)
```

Generate points spread out on the surface of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_density) | Input socket: Density |
| [i_mesh](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_mesh) | Input socket: Mesh |
| [i_seed](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_seed) | Input socket: Seed |
| [i_selection](#nodebpy.nodes.geometry.DistributePointsOnFaces.i_selection) | Input socket: Selection |
| [o_normal](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_normal) | Output socket: Normal |
| [o_points](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_points) | Output socket: Points |
| [o_rotation](#nodebpy.nodes.geometry.DistributePointsOnFaces.o_rotation) | Output socket: Rotation |

### DuplicateElements { #nodebpy.nodes.geometry.DuplicateElements }

```python
nodes.geometry.DuplicateElements(
    geometry=None,
    selection=True,
    amount=1,
    domain='POINT',
    **kwargs,
)
```

Generate an arbitrary number copies of each selected input element

#### Attributes

| Name | Description |
| --- | --- |
| [i_amount](#nodebpy.nodes.geometry.DuplicateElements.i_amount) | Input socket: Amount |
| [i_geometry](#nodebpy.nodes.geometry.DuplicateElements.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.DuplicateElements.i_selection) | Input socket: Selection |
| [o_duplicate_index](#nodebpy.nodes.geometry.DuplicateElements.o_duplicate_index) | Output socket: Duplicate Index |
| [o_geometry](#nodebpy.nodes.geometry.DuplicateElements.o_geometry) | Output socket: Geometry |

### EdgePathsToSelection { #nodebpy.nodes.geometry.EdgePathsToSelection }

```python
nodes.geometry.EdgePathsToSelection(
    start_vertices=True,
    next_vertex_index=-1,
    **kwargs,
)
```

Output a selection of edges by following paths across mesh edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_next_vertex_index](#nodebpy.nodes.geometry.EdgePathsToSelection.i_next_vertex_index) | Input socket: Next Vertex Index |
| [i_start_vertices](#nodebpy.nodes.geometry.EdgePathsToSelection.i_start_vertices) | Input socket: Start Vertices |
| [o_selection](#nodebpy.nodes.geometry.EdgePathsToSelection.o_selection) | Output socket: Selection |

### EdgesOfCorner { #nodebpy.nodes.geometry.EdgesOfCorner }

```python
nodes.geometry.EdgesOfCorner(corner_index=0, **kwargs)
```

Retrieve the edges on both sides of a face corner

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.geometry.EdgesOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_next_edge_index](#nodebpy.nodes.geometry.EdgesOfCorner.o_next_edge_index) | Output socket: Next Edge Index |
| [o_previous_edge_index](#nodebpy.nodes.geometry.EdgesOfCorner.o_previous_edge_index) | Output socket: Previous Edge Index |

### EdgesOfVertex { #nodebpy.nodes.geometry.EdgesOfVertex }

```python
nodes.geometry.EdgesOfVertex(
    vertex_index=0,
    weights=0.0,
    sort_index=0,
    **kwargs,
)
```

Retrieve the edges connected to each vertex

#### Attributes

| Name | Description |
| --- | --- |
| [i_sort_index](#nodebpy.nodes.geometry.EdgesOfVertex.i_sort_index) | Input socket: Sort Index |
| [i_vertex_index](#nodebpy.nodes.geometry.EdgesOfVertex.i_vertex_index) | Input socket: Vertex Index |
| [i_weights](#nodebpy.nodes.geometry.EdgesOfVertex.i_weights) | Input socket: Weights |
| [o_edge_index](#nodebpy.nodes.geometry.EdgesOfVertex.o_edge_index) | Output socket: Edge Index |
| [o_total](#nodebpy.nodes.geometry.EdgesOfVertex.o_total) | Output socket: Total |

### EdgesToFaceGroups { #nodebpy.nodes.geometry.EdgesToFaceGroups }

```python
nodes.geometry.EdgesToFaceGroups(boundary_edges=True, **kwargs)
```

Group faces into regions surrounded by the selected boundary edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_boundary_edges](#nodebpy.nodes.geometry.EdgesToFaceGroups.i_boundary_edges) | Input socket: Boundary Edges |
| [o_face_group_id](#nodebpy.nodes.geometry.EdgesToFaceGroups.o_face_group_id) | Output socket: Face Group ID |

### EvaluateAtIndex { #nodebpy.nodes.geometry.EvaluateAtIndex }

```python
nodes.geometry.EvaluateAtIndex(
    value=0.0,
    index=0,
    domain='POINT',
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve data of other elements in the context's geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_index](#nodebpy.nodes.geometry.EvaluateAtIndex.i_index) | Input socket: Index |
| [i_value](#nodebpy.nodes.geometry.EvaluateAtIndex.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.geometry.EvaluateAtIndex.o_value) | Output socket: Value |

### EvaluateOnDomain { #nodebpy.nodes.geometry.EvaluateOnDomain }

```python
nodes.geometry.EvaluateOnDomain(
    value=0.0,
    domain='POINT',
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve values from a field on a different domain besides the domain from the context

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.geometry.EvaluateOnDomain.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.geometry.EvaluateOnDomain.o_value) | Output socket: Value |

### FaceOfCorner { #nodebpy.nodes.geometry.FaceOfCorner }

```python
nodes.geometry.FaceOfCorner(corner_index=0, **kwargs)
```

Retrieve the face each face corner is part of

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.geometry.FaceOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_face_index](#nodebpy.nodes.geometry.FaceOfCorner.o_face_index) | Output socket: Face Index |
| [o_index_in_face](#nodebpy.nodes.geometry.FaceOfCorner.o_index_in_face) | Output socket: Index in Face |

### FaceSet { #nodebpy.nodes.geometry.FaceSet }

```python
nodes.geometry.FaceSet(**kwargs)
```

Each face's sculpt face set value

#### Attributes

| Name | Description |
| --- | --- |
| [o_exists](#nodebpy.nodes.geometry.FaceSet.o_exists) | Output socket: Exists |
| [o_face_set](#nodebpy.nodes.geometry.FaceSet.o_face_set) | Output socket: Face Set |

### FieldAverage { #nodebpy.nodes.geometry.FieldAverage }

```python
nodes.geometry.FieldAverage(
    value=0.0,
    group_index=0,
    data_type='FLOAT',
    domain='POINT',
    **kwargs,
)
```

Calculate the mean and median of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.FieldAverage.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.geometry.FieldAverage.i_value) | Input socket: Value |
| [o_mean](#nodebpy.nodes.geometry.FieldAverage.o_mean) | Output socket: Mean |
| [o_median](#nodebpy.nodes.geometry.FieldAverage.o_median) | Output socket: Median |

### FieldMinMax { #nodebpy.nodes.geometry.FieldMinMax }

```python
nodes.geometry.FieldMinMax(
    value=0.0,
    group_index=0,
    data_type='FLOAT',
    domain='POINT',
    **kwargs,
)
```

Calculate the minimum and maximum of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.FieldMinMax.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.geometry.FieldMinMax.i_value) | Input socket: Value |
| [o_max](#nodebpy.nodes.geometry.FieldMinMax.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.geometry.FieldMinMax.o_min) | Output socket: Min |

### FieldToGrid { #nodebpy.nodes.geometry.FieldToGrid }

```python
nodes.geometry.FieldToGrid(
    topology=0.0,
    extend=None,
    active_index=0,
    data_type='FLOAT',
    **kwargs,
)
```

Create new grids by evaluating new values on an existing volume grid topology

#### Attributes

| Name | Description |
| --- | --- |
| [i_input_socket](#nodebpy.nodes.geometry.FieldToGrid.i_input_socket) | Input socket: |
| [i_topology](#nodebpy.nodes.geometry.FieldToGrid.i_topology) | Input socket: Topology |
| [o_input_socket](#nodebpy.nodes.geometry.FieldToGrid.o_input_socket) | Output socket: |

### FieldVariance { #nodebpy.nodes.geometry.FieldVariance }

```python
nodes.geometry.FieldVariance(
    value=0.0,
    group_index=0,
    data_type='FLOAT',
    domain='POINT',
    **kwargs,
)
```

Calculate the standard deviation and variance of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.FieldVariance.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.geometry.FieldVariance.i_value) | Input socket: Value |
| [o_standard_deviation](#nodebpy.nodes.geometry.FieldVariance.o_standard_deviation) | Output socket: Standard Deviation |
| [o_variance](#nodebpy.nodes.geometry.FieldVariance.o_variance) | Output socket: Variance |

### FlipFaces { #nodebpy.nodes.geometry.FlipFaces }

```python
nodes.geometry.FlipFaces(mesh=None, selection=True, **kwargs)
```

Reverse the order of the vertices and edges of selected faces, flipping their normal direction

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.FlipFaces.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.FlipFaces.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.geometry.FlipFaces.o_mesh) | Output socket: Mesh |

### ForEachGeometryElementOutput { #nodebpy.nodes.geometry.ForEachGeometryElementOutput }

```python
nodes.geometry.ForEachGeometryElementOutput(
    extend_main=None,
    generation_0=None,
    extend_generation=None,
    active_input_index=0,
    active_generation_index=0,
    active_main_index=0,
    domain='POINT',
    inspection_index=0,
    **kwargs,
)
```

For Each Geometry Element Output node

#### Attributes

| Name | Description |
| --- | --- |
| [i_extend_generation](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.i_extend_generation) | Input socket: |
| [i_geometry](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.i_geometry) | Input socket: Geometry |
| [i_input_socket](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.i_input_socket) | Input socket: |
| [o_extend_generation](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.o_extend_generation) | Output socket: |
| [o_generation_0](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.o_generation_0) | Output socket: Geometry |
| [o_geometry](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.o_geometry) | Output socket: Geometry |
| [o_input_socket](#nodebpy.nodes.geometry.ForEachGeometryElementOutput.o_input_socket) | Output socket: |

### GeometryProximity { #nodebpy.nodes.geometry.GeometryProximity }

```python
nodes.geometry.GeometryProximity(
    target=None,
    group_id=0,
    source_position=[0.0, 0.0, 0.0],
    sample_group_id=0,
    target_element='FACES',
    **kwargs,
)
```

Compute the closest location on the target geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.GeometryProximity.i_geometry) | Input socket: Geometry |
| [i_group_id](#nodebpy.nodes.geometry.GeometryProximity.i_group_id) | Input socket: Group ID |
| [i_sample_group_id](#nodebpy.nodes.geometry.GeometryProximity.i_sample_group_id) | Input socket: Sample Group ID |
| [i_sample_position](#nodebpy.nodes.geometry.GeometryProximity.i_sample_position) | Input socket: Sample Position |
| [o_distance](#nodebpy.nodes.geometry.GeometryProximity.o_distance) | Output socket: Distance |
| [o_is_valid](#nodebpy.nodes.geometry.GeometryProximity.o_is_valid) | Output socket: Is Valid |
| [o_position](#nodebpy.nodes.geometry.GeometryProximity.o_position) | Output socket: Position |

### GeometryToInstance { #nodebpy.nodes.geometry.GeometryToInstance }

```python
nodes.geometry.GeometryToInstance(geometry=None, **kwargs)
```

Convert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.GeometryToInstance.i_geometry) | Input socket: Geometry |
| [o_instances](#nodebpy.nodes.geometry.GeometryToInstance.o_instances) | Output socket: Instances |

### GetListItem { #nodebpy.nodes.geometry.GetListItem }

```python
nodes.geometry.GetListItem(list=0.0, index=0, data_type='FLOAT', **kwargs)
```

Retrieve a value from a list

#### Attributes

| Name | Description |
| --- | --- |
| [i_index](#nodebpy.nodes.geometry.GetListItem.i_index) | Input socket: Index |
| [i_list](#nodebpy.nodes.geometry.GetListItem.i_list) | Input socket: List |
| [o_value](#nodebpy.nodes.geometry.GetListItem.o_value) | Output socket: Value |

### GetNamedGrid { #nodebpy.nodes.geometry.GetNamedGrid }

```python
nodes.geometry.GetNamedGrid(
    volume=None,
    name='',
    remove=True,
    data_type='FLOAT',
    **kwargs,
)
```

Get volume grid from a volume geometry with the specified name

#### Attributes

| Name | Description |
| --- | --- |
| [i_name](#nodebpy.nodes.geometry.GetNamedGrid.i_name) | Input socket: Name |
| [i_remove](#nodebpy.nodes.geometry.GetNamedGrid.i_remove) | Input socket: Remove |
| [i_volume](#nodebpy.nodes.geometry.GetNamedGrid.i_volume) | Input socket: Volume |
| [o_grid](#nodebpy.nodes.geometry.GetNamedGrid.o_grid) | Output socket: Grid |
| [o_volume](#nodebpy.nodes.geometry.GetNamedGrid.o_volume) | Output socket: Volume |

### GridCurl { #nodebpy.nodes.geometry.GridCurl }

```python
nodes.geometry.GridCurl(grid=[0.0, 0.0, 0.0], **kwargs)
```

Calculate the magnitude and direction of circulation of a directional vector grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.GridCurl.i_grid) | Input socket: Grid |
| [o_curl](#nodebpy.nodes.geometry.GridCurl.o_curl) | Output socket: Curl |

### GridDivergence { #nodebpy.nodes.geometry.GridDivergence }

```python
nodes.geometry.GridDivergence(grid=[0.0, 0.0, 0.0], **kwargs)
```

Calculate the flow into and out of each point of a directional vector grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.GridDivergence.i_grid) | Input socket: Grid |
| [o_divergence](#nodebpy.nodes.geometry.GridDivergence.o_divergence) | Output socket: Divergence |

### GridGradient { #nodebpy.nodes.geometry.GridGradient }

```python
nodes.geometry.GridGradient(grid=0.0, **kwargs)
```

Calculate the direction and magnitude of the change in values of a scalar grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.GridGradient.i_grid) | Input socket: Grid |
| [o_gradient](#nodebpy.nodes.geometry.GridGradient.o_gradient) | Output socket: Gradient |

### GridInfo { #nodebpy.nodes.geometry.GridInfo }

```python
nodes.geometry.GridInfo(grid=0.0, data_type='FLOAT', **kwargs)
```

Retrieve information about a volume grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.GridInfo.i_grid) | Input socket: Grid |
| [o_background_value](#nodebpy.nodes.geometry.GridInfo.o_background_value) | Output socket: Background Value |
| [o_transform](#nodebpy.nodes.geometry.GridInfo.o_transform) | Output socket: Transform |

### GridLaplacian { #nodebpy.nodes.geometry.GridLaplacian }

```python
nodes.geometry.GridLaplacian(grid=0.0, **kwargs)
```

Compute the divergence of the gradient of the input grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.GridLaplacian.i_grid) | Input socket: Grid |
| [o_laplacian](#nodebpy.nodes.geometry.GridLaplacian.o_laplacian) | Output socket: Laplacian |

### Group { #nodebpy.nodes.geometry.Group }

```python
nodes.geometry.Group(**kwargs)
```

Group node

### ImageInfo { #nodebpy.nodes.geometry.ImageInfo }

```python
nodes.geometry.ImageInfo(image=None, frame=0, **kwargs)
```

Retrieve information about an image

#### Attributes

| Name | Description |
| --- | --- |
| [i_frame](#nodebpy.nodes.geometry.ImageInfo.i_frame) | Input socket: Frame |
| [i_image](#nodebpy.nodes.geometry.ImageInfo.i_image) | Input socket: Image |
| [o_fps](#nodebpy.nodes.geometry.ImageInfo.o_fps) | Output socket: FPS |
| [o_frame_count](#nodebpy.nodes.geometry.ImageInfo.o_frame_count) | Output socket: Frame Count |
| [o_has_alpha](#nodebpy.nodes.geometry.ImageInfo.o_has_alpha) | Output socket: Has Alpha |
| [o_height](#nodebpy.nodes.geometry.ImageInfo.o_height) | Output socket: Height |
| [o_width](#nodebpy.nodes.geometry.ImageInfo.o_width) | Output socket: Width |

### ImageTexture { #nodebpy.nodes.geometry.ImageTexture }

```python
nodes.geometry.ImageTexture(
    image=None,
    vector=[0.0, 0.0, 0.0],
    frame=0,
    interpolation='Linear',
    extension='REPEAT',
    **kwargs,
)
```

Sample values from an image texture

#### Attributes

| Name | Description |
| --- | --- |
| [i_frame](#nodebpy.nodes.geometry.ImageTexture.i_frame) | Input socket: Frame |
| [i_image](#nodebpy.nodes.geometry.ImageTexture.i_image) | Input socket: Image |
| [i_vector](#nodebpy.nodes.geometry.ImageTexture.i_vector) | Input socket: Vector |
| [o_alpha](#nodebpy.nodes.geometry.ImageTexture.o_alpha) | Output socket: Alpha |
| [o_color](#nodebpy.nodes.geometry.ImageTexture.o_color) | Output socket: Color |

### ImportCSV { #nodebpy.nodes.geometry.ImportCSV }

```python
nodes.geometry.ImportCSV(path='', delimiter=',', **kwargs)
```

Import geometry from an CSV file

#### Attributes

| Name | Description |
| --- | --- |
| [i_delimiter](#nodebpy.nodes.geometry.ImportCSV.i_delimiter) | Input socket: Delimiter |
| [i_path](#nodebpy.nodes.geometry.ImportCSV.i_path) | Input socket: Path |
| [o_point_cloud](#nodebpy.nodes.geometry.ImportCSV.o_point_cloud) | Output socket: Point Cloud |

### ImportOBJ { #nodebpy.nodes.geometry.ImportOBJ }

```python
nodes.geometry.ImportOBJ(path='', **kwargs)
```

Import geometry from an OBJ file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.geometry.ImportOBJ.i_path) | Input socket: Path |
| [o_instances](#nodebpy.nodes.geometry.ImportOBJ.o_instances) | Output socket: Instances |

### ImportPLY { #nodebpy.nodes.geometry.ImportPLY }

```python
nodes.geometry.ImportPLY(path='', **kwargs)
```

Import a point cloud from a PLY file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.geometry.ImportPLY.i_path) | Input socket: Path |
| [o_mesh](#nodebpy.nodes.geometry.ImportPLY.o_mesh) | Output socket: Mesh |

### ImportSTL { #nodebpy.nodes.geometry.ImportSTL }

```python
nodes.geometry.ImportSTL(path='', **kwargs)
```

Import a mesh from an STL file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.geometry.ImportSTL.i_path) | Input socket: Path |
| [o_mesh](#nodebpy.nodes.geometry.ImportSTL.o_mesh) | Output socket: Mesh |

### ImportText { #nodebpy.nodes.geometry.ImportText }

```python
nodes.geometry.ImportText(path='', **kwargs)
```

Import a string from a text file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.geometry.ImportText.i_path) | Input socket: Path |
| [o_string](#nodebpy.nodes.geometry.ImportText.o_string) | Output socket: String |

### ImportVDB { #nodebpy.nodes.geometry.ImportVDB }

```python
nodes.geometry.ImportVDB(path='', **kwargs)
```

Import volume data from a .vdb file

#### Attributes

| Name | Description |
| --- | --- |
| [i_path](#nodebpy.nodes.geometry.ImportVDB.i_path) | Input socket: Path |
| [o_volume](#nodebpy.nodes.geometry.ImportVDB.o_volume) | Output socket: Volume |

### IndexOfNearest { #nodebpy.nodes.geometry.IndexOfNearest }

```python
nodes.geometry.IndexOfNearest(position=[0.0, 0.0, 0.0], group_id=0, **kwargs)
```

Find the nearest element in a group. Similar to the "Sample Nearest" node

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.IndexOfNearest.i_group_id) | Input socket: Group ID |
| [i_position](#nodebpy.nodes.geometry.IndexOfNearest.i_position) | Input socket: Position |
| [o_has_neighbor](#nodebpy.nodes.geometry.IndexOfNearest.o_has_neighbor) | Output socket: Has Neighbor |
| [o_index](#nodebpy.nodes.geometry.IndexOfNearest.o_index) | Output socket: Index |

### InstanceOnPoints { #nodebpy.nodes.geometry.InstanceOnPoints }

```python
nodes.geometry.InstanceOnPoints(
    points=None,
    selection=True,
    instance=None,
    pick_instance=False,
    instance_index=0,
    rotation=[0.0, 0.0, 0.0],
    scale=[1.0, 1.0, 1.0],
    **kwargs,
)
```

Generate a reference to geometry at each of the input points, without duplicating its underlying data

#### Attributes

| Name | Description |
| --- | --- |
| [i_instance](#nodebpy.nodes.geometry.InstanceOnPoints.i_instance) | Input socket: Instance |
| [i_instance_index](#nodebpy.nodes.geometry.InstanceOnPoints.i_instance_index) | Input socket: Instance Index |
| [i_pick_instance](#nodebpy.nodes.geometry.InstanceOnPoints.i_pick_instance) | Input socket: Pick Instance |
| [i_points](#nodebpy.nodes.geometry.InstanceOnPoints.i_points) | Input socket: Points |
| [i_rotation](#nodebpy.nodes.geometry.InstanceOnPoints.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.geometry.InstanceOnPoints.i_scale) | Input socket: Scale |
| [i_selection](#nodebpy.nodes.geometry.InstanceOnPoints.i_selection) | Input socket: Selection |
| [o_instances](#nodebpy.nodes.geometry.InstanceOnPoints.o_instances) | Output socket: Instances |

### InstanceTransform { #nodebpy.nodes.geometry.InstanceTransform }

```python
nodes.geometry.InstanceTransform(**kwargs)
```

Retrieve the full transformation of each instance in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [o_transform](#nodebpy.nodes.geometry.InstanceTransform.o_transform) | Output socket: Transform |

### InstancesToPoints { #nodebpy.nodes.geometry.InstancesToPoints }

```python
nodes.geometry.InstancesToPoints(
    instances=None,
    selection=True,
    position=[0.0, 0.0, 0.0],
    radius=0.05000000074505806,
    **kwargs,
)
```

Generate points at the origins of instances.
Note: Nested instances are not affected by this node

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.InstancesToPoints.i_instances) | Input socket: Instances |
| [i_position](#nodebpy.nodes.geometry.InstancesToPoints.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.InstancesToPoints.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.InstancesToPoints.i_selection) | Input socket: Selection |
| [o_points](#nodebpy.nodes.geometry.InstancesToPoints.o_points) | Output socket: Points |

### IsViewport { #nodebpy.nodes.geometry.IsViewport }

```python
nodes.geometry.IsViewport(**kwargs)
```

Retrieve whether the nodes are being evaluated for the viewport rather than the final render

#### Attributes

| Name | Description |
| --- | --- |
| [o_is_viewport](#nodebpy.nodes.geometry.IsViewport.o_is_viewport) | Output socket: Is Viewport |

### JoinStrings { #nodebpy.nodes.geometry.JoinStrings }

```python
nodes.geometry.JoinStrings(delimiter='', strings='', **kwargs)
```

Combine any number of input strings

#### Attributes

| Name | Description |
| --- | --- |
| [i_delimiter](#nodebpy.nodes.geometry.JoinStrings.i_delimiter) | Input socket: Delimiter |
| [i_strings](#nodebpy.nodes.geometry.JoinStrings.i_strings) | Input socket: Strings |
| [o_string](#nodebpy.nodes.geometry.JoinStrings.o_string) | Output socket: String |

### LinearGizmo { #nodebpy.nodes.geometry.LinearGizmo }

```python
nodes.geometry.LinearGizmo(
    value=0.0,
    position=[0.0, 0.0, 0.0],
    direction=[0.0, 0.0, 1.0],
    color_id='PRIMARY',
    draw_style='ARROW',
    **kwargs,
)
```

Show a linear gizmo in the viewport for a value

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.geometry.LinearGizmo.i_direction) | Input socket: Direction |
| [i_position](#nodebpy.nodes.geometry.LinearGizmo.i_position) | Input socket: Position |
| [i_value](#nodebpy.nodes.geometry.LinearGizmo.i_value) | Input socket: Value |
| [o_transform](#nodebpy.nodes.geometry.LinearGizmo.o_transform) | Output socket: Transform |

### List { #nodebpy.nodes.geometry.List }

```python
nodes.geometry.List(count=1, value=0.0, data_type='FLOAT', **kwargs)
```

Create a list of values

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.List.i_count) | Input socket: Count |
| [i_value](#nodebpy.nodes.geometry.List.i_value) | Input socket: Value |
| [o_list](#nodebpy.nodes.geometry.List.o_list) | Output socket: List |

### ListLength { #nodebpy.nodes.geometry.ListLength }

```python
nodes.geometry.ListLength(list=0.0, data_type='FLOAT', **kwargs)
```

Count how many items are in a given list

#### Attributes

| Name | Description |
| --- | --- |
| [i_list](#nodebpy.nodes.geometry.ListLength.i_list) | Input socket: List |
| [o_length](#nodebpy.nodes.geometry.ListLength.o_length) | Output socket: Length |

### MaterialSelection { #nodebpy.nodes.geometry.MaterialSelection }

```python
nodes.geometry.MaterialSelection(material=None, **kwargs)
```

Provide a selection of faces that use the specified material

#### Attributes

| Name | Description |
| --- | --- |
| [i_material](#nodebpy.nodes.geometry.MaterialSelection.i_material) | Input socket: Material |
| [o_selection](#nodebpy.nodes.geometry.MaterialSelection.o_selection) | Output socket: Selection |

### MergeByDistance { #nodebpy.nodes.geometry.MergeByDistance }

```python
nodes.geometry.MergeByDistance(
    geometry=None,
    selection=True,
    mode='All',
    distance=0.0010000000474974513,
    **kwargs,
)
```

Merge vertices or points within a given distance

#### Attributes

| Name | Description |
| --- | --- |
| [i_distance](#nodebpy.nodes.geometry.MergeByDistance.i_distance) | Input socket: Distance |
| [i_geometry](#nodebpy.nodes.geometry.MergeByDistance.i_geometry) | Input socket: Geometry |
| [i_mode](#nodebpy.nodes.geometry.MergeByDistance.i_mode) | Input socket: Mode |
| [i_selection](#nodebpy.nodes.geometry.MergeByDistance.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.MergeByDistance.o_geometry) | Output socket: Geometry |

### MergeLayers { #nodebpy.nodes.geometry.MergeLayers }

```python
nodes.geometry.MergeLayers(
    grease_pencil=None,
    selection=True,
    mode='MERGE_BY_NAME',
    **kwargs,
)
```

Join groups of Grease Pencil layers into one

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.MergeLayers.i_grease_pencil) | Input socket: Grease Pencil |
| [i_selection](#nodebpy.nodes.geometry.MergeLayers.i_selection) | Input socket: Selection |
| [o_grease_pencil](#nodebpy.nodes.geometry.MergeLayers.o_grease_pencil) | Output socket: Grease Pencil |

### MousePosition { #nodebpy.nodes.geometry.MousePosition }

```python
nodes.geometry.MousePosition(**kwargs)
```

Retrieve the position of the mouse cursor

#### Attributes

| Name | Description |
| --- | --- |
| [o_mouse_x](#nodebpy.nodes.geometry.MousePosition.o_mouse_x) | Output socket: Mouse X |
| [o_mouse_y](#nodebpy.nodes.geometry.MousePosition.o_mouse_y) | Output socket: Mouse Y |
| [o_region_height](#nodebpy.nodes.geometry.MousePosition.o_region_height) | Output socket: Region Height |
| [o_region_width](#nodebpy.nodes.geometry.MousePosition.o_region_width) | Output socket: Region Width |

### ObjectInfo { #nodebpy.nodes.geometry.ObjectInfo }

```python
nodes.geometry.ObjectInfo(
    object=None,
    as_instance=False,
    transform_space='ORIGINAL',
    **kwargs,
)
```

Retrieve information from an object

#### Attributes

| Name | Description |
| --- | --- |
| [i_as_instance](#nodebpy.nodes.geometry.ObjectInfo.i_as_instance) | Input socket: As Instance |
| [i_object](#nodebpy.nodes.geometry.ObjectInfo.i_object) | Input socket: Object |
| [o_geometry](#nodebpy.nodes.geometry.ObjectInfo.o_geometry) | Output socket: Geometry |
| [o_location](#nodebpy.nodes.geometry.ObjectInfo.o_location) | Output socket: Location |
| [o_rotation](#nodebpy.nodes.geometry.ObjectInfo.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.geometry.ObjectInfo.o_scale) | Output socket: Scale |
| [o_transform](#nodebpy.nodes.geometry.ObjectInfo.o_transform) | Output socket: Transform |

### OffsetCornerInFace { #nodebpy.nodes.geometry.OffsetCornerInFace }

```python
nodes.geometry.OffsetCornerInFace(corner_index=0, offset=0, **kwargs)
```

Retrieve corners in the same face as another

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.geometry.OffsetCornerInFace.i_corner_index) | Input socket: Corner Index |
| [i_offset](#nodebpy.nodes.geometry.OffsetCornerInFace.i_offset) | Input socket: Offset |
| [o_corner_index](#nodebpy.nodes.geometry.OffsetCornerInFace.o_corner_index) | Output socket: Corner Index |

### PackUVIslands { #nodebpy.nodes.geometry.PackUVIslands }

```python
nodes.geometry.PackUVIslands(
    uv=[0.0, 0.0, 0.0],
    selection=True,
    margin=0.0010000000474974513,
    rotate=True,
    method='Bounding Box',
    **kwargs,
)
```

Scale islands of a UV map and move them so they fill the UV space as much as possible

#### Attributes

| Name | Description |
| --- | --- |
| [i_margin](#nodebpy.nodes.geometry.PackUVIslands.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.geometry.PackUVIslands.i_method) | Input socket: Method |
| [i_rotate](#nodebpy.nodes.geometry.PackUVIslands.i_rotate) | Input socket: Rotate |
| [i_selection](#nodebpy.nodes.geometry.PackUVIslands.i_selection) | Input socket: Selection |
| [i_uv](#nodebpy.nodes.geometry.PackUVIslands.i_uv) | Input socket: UV |
| [o_uv](#nodebpy.nodes.geometry.PackUVIslands.o_uv) | Output socket: UV |

### Points { #nodebpy.nodes.geometry.Points }

```python
nodes.geometry.Points(
    count=1,
    position=[0.0, 0.0, 0.0],
    radius=0.10000000149011612,
    **kwargs,
)
```

Generate a point cloud with positions and radii defined by fields

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.geometry.Points.i_count) | Input socket: Count |
| [i_position](#nodebpy.nodes.geometry.Points.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.geometry.Points.i_radius) | Input socket: Radius |
| [o_points](#nodebpy.nodes.geometry.Points.o_points) | Output socket: Points |

### PointsToSDFGrid { #nodebpy.nodes.geometry.PointsToSDFGrid }

```python
nodes.geometry.PointsToSDFGrid(
    points=None,
    radius=0.5,
    voxel_size=0.30000001192092896,
    **kwargs,
)
```

Create a signed distance volume grid from points

#### Attributes

| Name | Description |
| --- | --- |
| [i_points](#nodebpy.nodes.geometry.PointsToSDFGrid.i_points) | Input socket: Points |
| [i_radius](#nodebpy.nodes.geometry.PointsToSDFGrid.i_radius) | Input socket: Radius |
| [i_voxel_size](#nodebpy.nodes.geometry.PointsToSDFGrid.i_voxel_size) | Input socket: Voxel Size |
| [o_sdf_grid](#nodebpy.nodes.geometry.PointsToSDFGrid.o_sdf_grid) | Output socket: SDF Grid |

### PointsToVertices { #nodebpy.nodes.geometry.PointsToVertices }

```python
nodes.geometry.PointsToVertices(points=None, selection=True, **kwargs)
```

Generate a mesh vertex for each point cloud point

#### Attributes

| Name | Description |
| --- | --- |
| [i_points](#nodebpy.nodes.geometry.PointsToVertices.i_points) | Input socket: Points |
| [i_selection](#nodebpy.nodes.geometry.PointsToVertices.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.geometry.PointsToVertices.o_mesh) | Output socket: Mesh |

### PointsToVolume { #nodebpy.nodes.geometry.PointsToVolume }

```python
nodes.geometry.PointsToVolume(
    points=None,
    density=1.0,
    resolution_mode='Amount',
    voxel_size=0.30000001192092896,
    voxel_amount=64.0,
    radius=0.5,
    **kwargs,
)
```

Generate a fog volume sphere around every point

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.geometry.PointsToVolume.i_density) | Input socket: Density |
| [i_points](#nodebpy.nodes.geometry.PointsToVolume.i_points) | Input socket: Points |
| [i_radius](#nodebpy.nodes.geometry.PointsToVolume.i_radius) | Input socket: Radius |
| [i_resolution_mode](#nodebpy.nodes.geometry.PointsToVolume.i_resolution_mode) | Input socket: Resolution Mode |
| [i_voxel_amount](#nodebpy.nodes.geometry.PointsToVolume.i_voxel_amount) | Input socket: Voxel Amount |
| [i_voxel_size](#nodebpy.nodes.geometry.PointsToVolume.i_voxel_size) | Input socket: Voxel Size |
| [o_volume](#nodebpy.nodes.geometry.PointsToVolume.o_volume) | Output socket: Volume |

### PruneGrid { #nodebpy.nodes.geometry.PruneGrid }

```python
nodes.geometry.PruneGrid(
    grid=0.0,
    mode='Threshold',
    threshold=0.009999999776482582,
    data_type='FLOAT',
    **kwargs,
)
```

Make the storage of a volume grid more efficient by collapsing data into tiles or inner nodes

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.PruneGrid.i_grid) | Input socket: Grid |
| [i_mode](#nodebpy.nodes.geometry.PruneGrid.i_mode) | Input socket: Mode |
| [i_threshold](#nodebpy.nodes.geometry.PruneGrid.i_threshold) | Input socket: Threshold |
| [o_grid](#nodebpy.nodes.geometry.PruneGrid.o_grid) | Output socket: Grid |

### Raycast { #nodebpy.nodes.geometry.Raycast }

```python
nodes.geometry.Raycast(
    target_geometry=None,
    attribute=0.0,
    interpolation='Interpolated',
    source_position=[0.0, 0.0, 0.0],
    ray_direction=[0.0, 0.0, -1.0],
    ray_length=100.0,
    data_type='FLOAT',
    **kwargs,
)
```

Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point

#### Attributes

| Name | Description |
| --- | --- |
| [i_attribute](#nodebpy.nodes.geometry.Raycast.i_attribute) | Input socket: Attribute |
| [i_interpolation](#nodebpy.nodes.geometry.Raycast.i_interpolation) | Input socket: Interpolation |
| [i_ray_direction](#nodebpy.nodes.geometry.Raycast.i_ray_direction) | Input socket: Ray Direction |
| [i_ray_length](#nodebpy.nodes.geometry.Raycast.i_ray_length) | Input socket: Ray Length |
| [i_source_position](#nodebpy.nodes.geometry.Raycast.i_source_position) | Input socket: Source Position |
| [i_target_geometry](#nodebpy.nodes.geometry.Raycast.i_target_geometry) | Input socket: Target Geometry |
| [o_attribute](#nodebpy.nodes.geometry.Raycast.o_attribute) | Output socket: Attribute |
| [o_hit_distance](#nodebpy.nodes.geometry.Raycast.o_hit_distance) | Output socket: Hit Distance |
| [o_hit_normal](#nodebpy.nodes.geometry.Raycast.o_hit_normal) | Output socket: Hit Normal |
| [o_hit_position](#nodebpy.nodes.geometry.Raycast.o_hit_position) | Output socket: Hit Position |
| [o_is_hit](#nodebpy.nodes.geometry.Raycast.o_is_hit) | Output socket: Is Hit |

### RealizeInstances { #nodebpy.nodes.geometry.RealizeInstances }

```python
nodes.geometry.RealizeInstances(
    geometry=None,
    selection=True,
    realize_all=True,
    depth=0,
    **kwargs,
)
```

Convert instances into real geometry data

#### Attributes

| Name | Description |
| --- | --- |
| [i_depth](#nodebpy.nodes.geometry.RealizeInstances.i_depth) | Input socket: Depth |
| [i_geometry](#nodebpy.nodes.geometry.RealizeInstances.i_geometry) | Input socket: Geometry |
| [i_realize_all](#nodebpy.nodes.geometry.RealizeInstances.i_realize_all) | Input socket: Realize All |
| [i_selection](#nodebpy.nodes.geometry.RealizeInstances.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.RealizeInstances.o_geometry) | Output socket: Geometry |

### ReplaceMaterial { #nodebpy.nodes.geometry.ReplaceMaterial }

```python
nodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None, **kwargs)
```

Swap one material with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.ReplaceMaterial.i_geometry) | Input socket: Geometry |
| [i_new](#nodebpy.nodes.geometry.ReplaceMaterial.i_new) | Input socket: New |
| [i_old](#nodebpy.nodes.geometry.ReplaceMaterial.i_old) | Input socket: Old |
| [o_geometry](#nodebpy.nodes.geometry.ReplaceMaterial.o_geometry) | Output socket: Geometry |

### RotateInstances { #nodebpy.nodes.geometry.RotateInstances }

```python
nodes.geometry.RotateInstances(
    instances=None,
    selection=True,
    rotation=[0.0, 0.0, 0.0],
    pivot_point=[0.0, 0.0, 0.0],
    local_space=True,
    **kwargs,
)
```

Rotate geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.RotateInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.RotateInstances.i_local_space) | Input socket: Local Space |
| [i_pivot_point](#nodebpy.nodes.geometry.RotateInstances.i_pivot_point) | Input socket: Pivot Point |
| [i_rotation](#nodebpy.nodes.geometry.RotateInstances.i_rotation) | Input socket: Rotation |
| [i_selection](#nodebpy.nodes.geometry.RotateInstances.i_selection) | Input socket: Selection |
| [o_instances](#nodebpy.nodes.geometry.RotateInstances.o_instances) | Output socket: Instances |

### SDFGridBoolean { #nodebpy.nodes.geometry.SDFGridBoolean }

```python
nodes.geometry.SDFGridBoolean(
    grid_1=0.0,
    grid_2=0.0,
    operation='DIFFERENCE',
    **kwargs,
)
```

Cut, subtract, or join multiple SDF volume grid inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid_1](#nodebpy.nodes.geometry.SDFGridBoolean.i_grid_1) | Input socket: Grid 1 |
| [i_grid_2](#nodebpy.nodes.geometry.SDFGridBoolean.i_grid_2) | Input socket: Grid 2 |
| [o_grid](#nodebpy.nodes.geometry.SDFGridBoolean.o_grid) | Output socket: Grid |

#### Methods

| Name | Description |
| --- | --- |
| [difference](#nodebpy.nodes.geometry.SDFGridBoolean.difference) | Create SDF Grid Boolean with operation 'Difference'. |
| [intersect](#nodebpy.nodes.geometry.SDFGridBoolean.intersect) | Create SDF Grid Boolean with operation 'Intersect'. |
| [union](#nodebpy.nodes.geometry.SDFGridBoolean.union) | Create SDF Grid Boolean with operation 'Union'. |

##### difference { #nodebpy.nodes.geometry.SDFGridBoolean.difference }

```python
nodes.geometry.SDFGridBoolean.difference(grid_1=0.0, grid_2=0.0)
```

Create SDF Grid Boolean with operation 'Difference'.

##### intersect { #nodebpy.nodes.geometry.SDFGridBoolean.intersect }

```python
nodes.geometry.SDFGridBoolean.intersect(grid_1=0.0, grid_2=0.0)
```

Create SDF Grid Boolean with operation 'Intersect'.

##### union { #nodebpy.nodes.geometry.SDFGridBoolean.union }

```python
nodes.geometry.SDFGridBoolean.union(grid_1=0.0, grid_2=0.0)
```

Create SDF Grid Boolean with operation 'Union'.

### SDFGridFillet { #nodebpy.nodes.geometry.SDFGridFillet }

```python
nodes.geometry.SDFGridFillet(grid=0.0, iterations=1, **kwargs)
```

Round off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SDFGridFillet.i_grid) | Input socket: Grid |
| [i_iterations](#nodebpy.nodes.geometry.SDFGridFillet.i_iterations) | Input socket: Iterations |
| [o_grid](#nodebpy.nodes.geometry.SDFGridFillet.o_grid) | Output socket: Grid |

### SDFGridLaplacian { #nodebpy.nodes.geometry.SDFGridLaplacian }

```python
nodes.geometry.SDFGridLaplacian(grid=0.0, iterations=1, **kwargs)
```

Apply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SDFGridLaplacian.i_grid) | Input socket: Grid |
| [i_iterations](#nodebpy.nodes.geometry.SDFGridLaplacian.i_iterations) | Input socket: Iterations |
| [o_grid](#nodebpy.nodes.geometry.SDFGridLaplacian.o_grid) | Output socket: Grid |

### SDFGridMean { #nodebpy.nodes.geometry.SDFGridMean }

```python
nodes.geometry.SDFGridMean(grid=0.0, width=1, iterations=1, **kwargs)
```

Apply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SDFGridMean.i_grid) | Input socket: Grid |
| [i_iterations](#nodebpy.nodes.geometry.SDFGridMean.i_iterations) | Input socket: Iterations |
| [i_width](#nodebpy.nodes.geometry.SDFGridMean.i_width) | Input socket: Width |
| [o_grid](#nodebpy.nodes.geometry.SDFGridMean.o_grid) | Output socket: Grid |

### SDFGridMeanCurvature { #nodebpy.nodes.geometry.SDFGridMeanCurvature }

```python
nodes.geometry.SDFGridMeanCurvature(grid=0.0, iterations=1, **kwargs)
```

Apply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SDFGridMeanCurvature.i_grid) | Input socket: Grid |
| [i_iterations](#nodebpy.nodes.geometry.SDFGridMeanCurvature.i_iterations) | Input socket: Iterations |
| [o_grid](#nodebpy.nodes.geometry.SDFGridMeanCurvature.o_grid) | Output socket: Grid |

### SDFGridMedian { #nodebpy.nodes.geometry.SDFGridMedian }

```python
nodes.geometry.SDFGridMedian(grid=0.0, width=1, iterations=1, **kwargs)
```

Apply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SDFGridMedian.i_grid) | Input socket: Grid |
| [i_iterations](#nodebpy.nodes.geometry.SDFGridMedian.i_iterations) | Input socket: Iterations |
| [i_width](#nodebpy.nodes.geometry.SDFGridMedian.i_width) | Input socket: Width |
| [o_grid](#nodebpy.nodes.geometry.SDFGridMedian.o_grid) | Output socket: Grid |

### SDFGridOffset { #nodebpy.nodes.geometry.SDFGridOffset }

```python
nodes.geometry.SDFGridOffset(grid=0.0, distance=0.10000000149011612, **kwargs)
```

Offset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property

#### Attributes

| Name | Description |
| --- | --- |
| [i_distance](#nodebpy.nodes.geometry.SDFGridOffset.i_distance) | Input socket: Distance |
| [i_grid](#nodebpy.nodes.geometry.SDFGridOffset.i_grid) | Input socket: Grid |
| [o_grid](#nodebpy.nodes.geometry.SDFGridOffset.o_grid) | Output socket: Grid |

### SampleGrid { #nodebpy.nodes.geometry.SampleGrid }

```python
nodes.geometry.SampleGrid(
    grid=0.0,
    position=[0.0, 0.0, 0.0],
    interpolation='Trilinear',
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve values from the specified volume grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SampleGrid.i_grid) | Input socket: Grid |
| [i_interpolation](#nodebpy.nodes.geometry.SampleGrid.i_interpolation) | Input socket: Interpolation |
| [i_position](#nodebpy.nodes.geometry.SampleGrid.i_position) | Input socket: Position |
| [o_value](#nodebpy.nodes.geometry.SampleGrid.o_value) | Output socket: Value |

### SampleGridIndex { #nodebpy.nodes.geometry.SampleGridIndex }

```python
nodes.geometry.SampleGridIndex(
    grid=0.0,
    x=0,
    y=0,
    z=0,
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve volume grid values at specific voxels

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SampleGridIndex.i_grid) | Input socket: Grid |
| [i_x](#nodebpy.nodes.geometry.SampleGridIndex.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.geometry.SampleGridIndex.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.geometry.SampleGridIndex.i_z) | Input socket: Z |
| [o_value](#nodebpy.nodes.geometry.SampleGridIndex.o_value) | Output socket: Value |

### SampleIndex { #nodebpy.nodes.geometry.SampleIndex }

```python
nodes.geometry.SampleIndex(
    geometry=None,
    value=0.0,
    index=0,
    data_type='FLOAT',
    domain='POINT',
    clamp=False,
    **kwargs,
)
```

Retrieve values from specific geometry elements

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SampleIndex.i_geometry) | Input socket: Geometry |
| [i_index](#nodebpy.nodes.geometry.SampleIndex.i_index) | Input socket: Index |
| [i_value](#nodebpy.nodes.geometry.SampleIndex.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.geometry.SampleIndex.o_value) | Output socket: Value |

### SampleNearest { #nodebpy.nodes.geometry.SampleNearest }

```python
nodes.geometry.SampleNearest(
    geometry=None,
    sample_position=[0.0, 0.0, 0.0],
    domain='POINT',
    **kwargs,
)
```

Find the element of a geometry closest to a position. Similar to the "Index of Nearest" node

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SampleNearest.i_geometry) | Input socket: Geometry |
| [i_sample_position](#nodebpy.nodes.geometry.SampleNearest.i_sample_position) | Input socket: Sample Position |
| [o_index](#nodebpy.nodes.geometry.SampleNearest.o_index) | Output socket: Index |

### SampleNearestSurface { #nodebpy.nodes.geometry.SampleNearestSurface }

```python
nodes.geometry.SampleNearestSurface(
    mesh=None,
    value=0.0,
    group_id=0,
    sample_position=[0.0, 0.0, 0.0],
    sample_group_id=0,
    data_type='FLOAT',
    **kwargs,
)
```

Calculate the interpolated value of a mesh attribute on the closest point of its surface

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.geometry.SampleNearestSurface.i_group_id) | Input socket: Group ID |
| [i_mesh](#nodebpy.nodes.geometry.SampleNearestSurface.i_mesh) | Input socket: Mesh |
| [i_sample_group_id](#nodebpy.nodes.geometry.SampleNearestSurface.i_sample_group_id) | Input socket: Sample Group ID |
| [i_sample_position](#nodebpy.nodes.geometry.SampleNearestSurface.i_sample_position) | Input socket: Sample Position |
| [i_value](#nodebpy.nodes.geometry.SampleNearestSurface.i_value) | Input socket: Value |
| [o_is_valid](#nodebpy.nodes.geometry.SampleNearestSurface.o_is_valid) | Output socket: Is Valid |
| [o_value](#nodebpy.nodes.geometry.SampleNearestSurface.o_value) | Output socket: Value |

### SampleUVSurface { #nodebpy.nodes.geometry.SampleUVSurface }

```python
nodes.geometry.SampleUVSurface(
    mesh=None,
    value=0.0,
    source_uv_map=[0.0, 0.0, 0.0],
    sample_uv=[0.0, 0.0, 0.0],
    data_type='FLOAT',
    **kwargs,
)
```

Calculate the interpolated values of a mesh attribute at a UV coordinate

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.SampleUVSurface.i_mesh) | Input socket: Mesh |
| [i_sample_uv](#nodebpy.nodes.geometry.SampleUVSurface.i_sample_uv) | Input socket: Sample UV |
| [i_uv_map](#nodebpy.nodes.geometry.SampleUVSurface.i_uv_map) | Input socket: UV Map |
| [i_value](#nodebpy.nodes.geometry.SampleUVSurface.i_value) | Input socket: Value |
| [o_is_valid](#nodebpy.nodes.geometry.SampleUVSurface.o_is_valid) | Output socket: Is Valid |
| [o_value](#nodebpy.nodes.geometry.SampleUVSurface.o_value) | Output socket: Value |

### ScaleElements { #nodebpy.nodes.geometry.ScaleElements }

```python
nodes.geometry.ScaleElements(
    geometry=None,
    selection=True,
    scale=1.0,
    center=[0.0, 0.0, 0.0],
    scale_mode='Uniform',
    axis=[1.0, 0.0, 0.0],
    domain='FACE',
    **kwargs,
)
```

Scale groups of connected edges and faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_axis](#nodebpy.nodes.geometry.ScaleElements.i_axis) | Input socket: Axis |
| [i_center](#nodebpy.nodes.geometry.ScaleElements.i_center) | Input socket: Center |
| [i_geometry](#nodebpy.nodes.geometry.ScaleElements.i_geometry) | Input socket: Geometry |
| [i_scale](#nodebpy.nodes.geometry.ScaleElements.i_scale) | Input socket: Scale |
| [i_scale_mode](#nodebpy.nodes.geometry.ScaleElements.i_scale_mode) | Input socket: Scale Mode |
| [i_selection](#nodebpy.nodes.geometry.ScaleElements.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.ScaleElements.o_geometry) | Output socket: Geometry |

### ScaleInstances { #nodebpy.nodes.geometry.ScaleInstances }

```python
nodes.geometry.ScaleInstances(
    instances=None,
    selection=True,
    scale=[1.0, 1.0, 1.0],
    center=[0.0, 0.0, 0.0],
    local_space=True,
    **kwargs,
)
```

Scale geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_center](#nodebpy.nodes.geometry.ScaleInstances.i_center) | Input socket: Center |
| [i_instances](#nodebpy.nodes.geometry.ScaleInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.ScaleInstances.i_local_space) | Input socket: Local Space |
| [i_scale](#nodebpy.nodes.geometry.ScaleInstances.i_scale) | Input socket: Scale |
| [i_selection](#nodebpy.nodes.geometry.ScaleInstances.i_selection) | Input socket: Selection |
| [o_instances](#nodebpy.nodes.geometry.ScaleInstances.o_instances) | Output socket: Instances |

### Selection { #nodebpy.nodes.geometry.Selection }

```python
nodes.geometry.Selection(**kwargs)
```

User selection of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [o_boolean](#nodebpy.nodes.geometry.Selection.o_boolean) | Output socket: Boolean |
| [o_float](#nodebpy.nodes.geometry.Selection.o_float) | Output socket: Float |

### SelfObject { #nodebpy.nodes.geometry.SelfObject }

```python
nodes.geometry.SelfObject(**kwargs)
```

Retrieve the object that contains the geometry nodes modifier currently being executed

#### Attributes

| Name | Description |
| --- | --- |
| [o_self_object](#nodebpy.nodes.geometry.SelfObject.o_self_object) | Output socket: Self Object |

### SeparateComponents { #nodebpy.nodes.geometry.SeparateComponents }

```python
nodes.geometry.SeparateComponents(geometry=None, **kwargs)
```

Split a geometry into a separate output for each type of data in the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SeparateComponents.i_geometry) | Input socket: Geometry |
| [o_curve](#nodebpy.nodes.geometry.SeparateComponents.o_curve) | Output socket: Curve |
| [o_grease_pencil](#nodebpy.nodes.geometry.SeparateComponents.o_grease_pencil) | Output socket: Grease Pencil |
| [o_instances](#nodebpy.nodes.geometry.SeparateComponents.o_instances) | Output socket: Instances |
| [o_mesh](#nodebpy.nodes.geometry.SeparateComponents.o_mesh) | Output socket: Mesh |
| [o_point_cloud](#nodebpy.nodes.geometry.SeparateComponents.o_point_cloud) | Output socket: Point Cloud |
| [o_volume](#nodebpy.nodes.geometry.SeparateComponents.o_volume) | Output socket: Volume |

### SeparateGeometry { #nodebpy.nodes.geometry.SeparateGeometry }

```python
nodes.geometry.SeparateGeometry(
    geometry=None,
    selection=True,
    domain='POINT',
    **kwargs,
)
```

Split a geometry into two geometry outputs based on a selection

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SeparateGeometry.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.SeparateGeometry.i_selection) | Input socket: Selection |
| [o_inverted](#nodebpy.nodes.geometry.SeparateGeometry.o_inverted) | Output socket: Inverted |
| [o_selection](#nodebpy.nodes.geometry.SeparateGeometry.o_selection) | Output socket: Selection |

### SetFaceSet { #nodebpy.nodes.geometry.SetFaceSet }

```python
nodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0, **kwargs)
```

Set sculpt face set values for faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_set](#nodebpy.nodes.geometry.SetFaceSet.i_face_set) | Input socket: Face Set |
| [i_mesh](#nodebpy.nodes.geometry.SetFaceSet.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SetFaceSet.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.geometry.SetFaceSet.o_mesh) | Output socket: Mesh |

### SetGeometryName { #nodebpy.nodes.geometry.SetGeometryName }

```python
nodes.geometry.SetGeometryName(geometry=None, name='', **kwargs)
```

Set the name of a geometry for easier debugging

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetGeometryName.i_geometry) | Input socket: Geometry |
| [i_name](#nodebpy.nodes.geometry.SetGeometryName.i_name) | Input socket: Name |
| [o_geometry](#nodebpy.nodes.geometry.SetGeometryName.o_geometry) | Output socket: Geometry |

### SetGreasePencilColor { #nodebpy.nodes.geometry.SetGreasePencilColor }

```python
nodes.geometry.SetGreasePencilColor(
    grease_pencil=None,
    selection=True,
    color=[1.0, 1.0, 1.0, 1.0],
    opacity=1.0,
    mode='STROKE',
    **kwargs,
)
```

Set color and opacity attributes on Grease Pencil geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.geometry.SetGreasePencilColor.i_color) | Input socket: Color |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilColor.i_grease_pencil) | Input socket: Grease Pencil |
| [i_opacity](#nodebpy.nodes.geometry.SetGreasePencilColor.i_opacity) | Input socket: Opacity |
| [i_selection](#nodebpy.nodes.geometry.SetGreasePencilColor.i_selection) | Input socket: Selection |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilColor.o_grease_pencil) | Output socket: Grease Pencil |

### SetGreasePencilDepth { #nodebpy.nodes.geometry.SetGreasePencilDepth }

```python
nodes.geometry.SetGreasePencilDepth(
    grease_pencil=None,
    depth_order='2D',
    **kwargs,
)
```

Set the Grease Pencil depth order to use

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilDepth.i_grease_pencil) | Input socket: Grease Pencil |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilDepth.o_grease_pencil) | Output socket: Grease Pencil |

### SetGreasePencilSoftness { #nodebpy.nodes.geometry.SetGreasePencilSoftness }

```python
nodes.geometry.SetGreasePencilSoftness(
    grease_pencil=None,
    selection=True,
    softness=0.0,
    **kwargs,
)
```

Set softness attribute on Grease Pencil geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_grease_pencil) | Input socket: Grease Pencil |
| [i_selection](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_selection) | Input socket: Selection |
| [i_softness](#nodebpy.nodes.geometry.SetGreasePencilSoftness.i_softness) | Input socket: Softness |
| [o_grease_pencil](#nodebpy.nodes.geometry.SetGreasePencilSoftness.o_grease_pencil) | Output socket: Grease Pencil |

### SetGridBackground { #nodebpy.nodes.geometry.SetGridBackground }

```python
nodes.geometry.SetGridBackground(
    grid=0.0,
    background=0.0,
    data_type='FLOAT',
    **kwargs,
)
```

Set the background value used for inactive voxels and tiles

#### Attributes

| Name | Description |
| --- | --- |
| [i_background](#nodebpy.nodes.geometry.SetGridBackground.i_background) | Input socket: Background |
| [i_grid](#nodebpy.nodes.geometry.SetGridBackground.i_grid) | Input socket: Grid |
| [o_grid](#nodebpy.nodes.geometry.SetGridBackground.o_grid) | Output socket: Grid |

### SetGridTransform { #nodebpy.nodes.geometry.SetGridTransform }

```python
nodes.geometry.SetGridTransform(
    grid=0.0,
    transform=None,
    data_type='FLOAT',
    **kwargs,
)
```

Set the transform for the grid from index space into object space.

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.SetGridTransform.i_grid) | Input socket: Grid |
| [i_transform](#nodebpy.nodes.geometry.SetGridTransform.i_transform) | Input socket: Transform |
| [o_grid](#nodebpy.nodes.geometry.SetGridTransform.o_grid) | Output socket: Grid |
| [o_is_valid](#nodebpy.nodes.geometry.SetGridTransform.o_is_valid) | Output socket: Is Valid |

### SetID { #nodebpy.nodes.geometry.SetID }

```python
nodes.geometry.SetID(geometry=None, selection=True, id=0, **kwargs)
```

Set the id attribute on the input geometry, mainly used internally for randomizing

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetID.i_geometry) | Input socket: Geometry |
| [i_id](#nodebpy.nodes.geometry.SetID.i_id) | Input socket: ID |
| [i_selection](#nodebpy.nodes.geometry.SetID.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.SetID.o_geometry) | Output socket: Geometry |

### SetInstanceTransform { #nodebpy.nodes.geometry.SetInstanceTransform }

```python
nodes.geometry.SetInstanceTransform(
    instances=None,
    selection=True,
    transform=None,
    **kwargs,
)
```

Set the transformation matrix of every instance

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.SetInstanceTransform.i_instances) | Input socket: Instances |
| [i_selection](#nodebpy.nodes.geometry.SetInstanceTransform.i_selection) | Input socket: Selection |
| [i_transform](#nodebpy.nodes.geometry.SetInstanceTransform.i_transform) | Input socket: Transform |
| [o_instances](#nodebpy.nodes.geometry.SetInstanceTransform.o_instances) | Output socket: Instances |

### SetMaterial { #nodebpy.nodes.geometry.SetMaterial }

```python
nodes.geometry.SetMaterial(
    geometry=None,
    selection=True,
    material=None,
    **kwargs,
)
```

Assign a material to geometry elements

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetMaterial.i_geometry) | Input socket: Geometry |
| [i_material](#nodebpy.nodes.geometry.SetMaterial.i_material) | Input socket: Material |
| [i_selection](#nodebpy.nodes.geometry.SetMaterial.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.SetMaterial.o_geometry) | Output socket: Geometry |

### SetMaterialIndex { #nodebpy.nodes.geometry.SetMaterialIndex }

```python
nodes.geometry.SetMaterialIndex(
    geometry=None,
    selection=True,
    material_index=0,
    **kwargs,
)
```

Set the material index for each selected geometry element

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetMaterialIndex.i_geometry) | Input socket: Geometry |
| [i_material_index](#nodebpy.nodes.geometry.SetMaterialIndex.i_material_index) | Input socket: Material Index |
| [i_selection](#nodebpy.nodes.geometry.SetMaterialIndex.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.SetMaterialIndex.o_geometry) | Output socket: Geometry |

### SetPointRadius { #nodebpy.nodes.geometry.SetPointRadius }

```python
nodes.geometry.SetPointRadius(
    points=None,
    selection=True,
    radius=0.05000000074505806,
    **kwargs,
)
```

Set the display size of point cloud points

#### Attributes

| Name | Description |
| --- | --- |
| [i_points](#nodebpy.nodes.geometry.SetPointRadius.i_points) | Input socket: Points |
| [i_radius](#nodebpy.nodes.geometry.SetPointRadius.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.geometry.SetPointRadius.i_selection) | Input socket: Selection |
| [o_points](#nodebpy.nodes.geometry.SetPointRadius.o_points) | Output socket: Points |

### SetPosition { #nodebpy.nodes.geometry.SetPosition }

```python
nodes.geometry.SetPosition(
    geometry=None,
    selection=True,
    position=[0.0, 0.0, 0.0],
    offset=[0.0, 0.0, 0.0],
    **kwargs,
)
```

Set the location of each point

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetPosition.i_geometry) | Input socket: Geometry |
| [i_offset](#nodebpy.nodes.geometry.SetPosition.i_offset) | Input socket: Offset |
| [i_position](#nodebpy.nodes.geometry.SetPosition.i_position) | Input socket: Position |
| [i_selection](#nodebpy.nodes.geometry.SetPosition.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.SetPosition.o_geometry) | Output socket: Geometry |

### SetSelection { #nodebpy.nodes.geometry.SetSelection }

```python
nodes.geometry.SetSelection(
    geometry=None,
    selection=True,
    domain='POINT',
    selection_type='BOOLEAN',
    **kwargs,
)
```

Set selection of the edited geometry, for tool execution

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SetSelection.i_geometry) | Input socket: Geometry |
| [i_selection](#nodebpy.nodes.geometry.SetSelection.i_selection) | Input socket: Selection |
| [o_geometry](#nodebpy.nodes.geometry.SetSelection.o_geometry) | Output socket: Geometry |

### SetShadeSmooth { #nodebpy.nodes.geometry.SetShadeSmooth }

```python
nodes.geometry.SetShadeSmooth(
    geometry=None,
    selection=True,
    shade_smooth=True,
    domain='FACE',
    **kwargs,
)
```

Control the smoothness of mesh normals around each face by changing the "shade smooth" attribute

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.SetShadeSmooth.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SetShadeSmooth.i_selection) | Input socket: Selection |
| [i_shade_smooth](#nodebpy.nodes.geometry.SetShadeSmooth.i_shade_smooth) | Input socket: Shade Smooth |
| [o_mesh](#nodebpy.nodes.geometry.SetShadeSmooth.o_mesh) | Output socket: Mesh |

### SetSplineCyclic { #nodebpy.nodes.geometry.SetSplineCyclic }

```python
nodes.geometry.SetSplineCyclic(
    geometry=None,
    selection=True,
    cyclic=False,
    **kwargs,
)
```

Control whether each spline loops back on itself by changing the "cyclic" attribute

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetSplineCyclic.i_curve) | Input socket: Curve |
| [i_cyclic](#nodebpy.nodes.geometry.SetSplineCyclic.i_cyclic) | Input socket: Cyclic |
| [i_selection](#nodebpy.nodes.geometry.SetSplineCyclic.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.geometry.SetSplineCyclic.o_curve) | Output socket: Curve |

### SetSplineResolution { #nodebpy.nodes.geometry.SetSplineResolution }

```python
nodes.geometry.SetSplineResolution(
    geometry=None,
    selection=True,
    resolution=12,
    **kwargs,
)
```

Control how many evaluated points should be generated on every curve segment

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.geometry.SetSplineResolution.i_curve) | Input socket: Curve |
| [i_resolution](#nodebpy.nodes.geometry.SetSplineResolution.i_resolution) | Input socket: Resolution |
| [i_selection](#nodebpy.nodes.geometry.SetSplineResolution.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.geometry.SetSplineResolution.o_curve) | Output socket: Curve |

### SortElements { #nodebpy.nodes.geometry.SortElements }

```python
nodes.geometry.SortElements(
    geometry=None,
    selection=True,
    group_id=0,
    sort_weight=0.0,
    domain='POINT',
    **kwargs,
)
```

Rearrange geometry elements, changing their indices

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SortElements.i_geometry) | Input socket: Geometry |
| [i_group_id](#nodebpy.nodes.geometry.SortElements.i_group_id) | Input socket: Group ID |
| [i_selection](#nodebpy.nodes.geometry.SortElements.i_selection) | Input socket: Selection |
| [i_sort_weight](#nodebpy.nodes.geometry.SortElements.i_sort_weight) | Input socket: Sort Weight |
| [o_geometry](#nodebpy.nodes.geometry.SortElements.o_geometry) | Output socket: Geometry |

### SplineLength { #nodebpy.nodes.geometry.SplineLength }

```python
nodes.geometry.SplineLength(**kwargs)
```

Retrieve the total length of each spline, as a distance or as a number of points

#### Attributes

| Name | Description |
| --- | --- |
| [o_length](#nodebpy.nodes.geometry.SplineLength.o_length) | Output socket: Length |
| [o_point_count](#nodebpy.nodes.geometry.SplineLength.o_point_count) | Output socket: Point Count |

### SplineParameter { #nodebpy.nodes.geometry.SplineParameter }

```python
nodes.geometry.SplineParameter(**kwargs)
```

Retrieve how far along each spline a control point is

#### Attributes

| Name | Description |
| --- | --- |
| [o_factor](#nodebpy.nodes.geometry.SplineParameter.o_factor) | Output socket: Factor |
| [o_index](#nodebpy.nodes.geometry.SplineParameter.o_index) | Output socket: Index |
| [o_length](#nodebpy.nodes.geometry.SplineParameter.o_length) | Output socket: Length |

### SplitEdges { #nodebpy.nodes.geometry.SplitEdges }

```python
nodes.geometry.SplitEdges(mesh=None, selection=True, **kwargs)
```

Duplicate mesh edges and break connections with the surrounding faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.SplitEdges.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.geometry.SplitEdges.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.geometry.SplitEdges.o_mesh) | Output socket: Mesh |

### SplitToInstances { #nodebpy.nodes.geometry.SplitToInstances }

```python
nodes.geometry.SplitToInstances(
    geometry=None,
    selection=True,
    group_id=0,
    domain='POINT',
    **kwargs,
)
```

Create separate geometries containing the elements from the same group

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.SplitToInstances.i_geometry) | Input socket: Geometry |
| [i_group_id](#nodebpy.nodes.geometry.SplitToInstances.i_group_id) | Input socket: Group ID |
| [i_selection](#nodebpy.nodes.geometry.SplitToInstances.i_selection) | Input socket: Selection |
| [o_group_id](#nodebpy.nodes.geometry.SplitToInstances.o_group_id) | Output socket: Group ID |
| [o_instances](#nodebpy.nodes.geometry.SplitToInstances.o_instances) | Output socket: Instances |

### StoreNamedGrid { #nodebpy.nodes.geometry.StoreNamedGrid }

```python
nodes.geometry.StoreNamedGrid(
    volume=None,
    name='',
    grid=0.0,
    data_type='FLOAT',
    **kwargs,
)
```

Store grid data in a volume geometry with the specified name

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.StoreNamedGrid.i_grid) | Input socket: Grid |
| [i_name](#nodebpy.nodes.geometry.StoreNamedGrid.i_name) | Input socket: Name |
| [i_volume](#nodebpy.nodes.geometry.StoreNamedGrid.i_volume) | Input socket: Volume |
| [o_volume](#nodebpy.nodes.geometry.StoreNamedGrid.o_volume) | Output socket: Volume |

### SubdivisionSurface { #nodebpy.nodes.geometry.SubdivisionSurface }

```python
nodes.geometry.SubdivisionSurface(
    mesh=None,
    level=1,
    edge_crease=0.0,
    vertex_crease=0.0,
    limit_surface=True,
    uv_smooth='Keep Boundaries',
    boundary_smooth='All',
    **kwargs,
)
```

Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method

#### Attributes

| Name | Description |
| --- | --- |
| [i_boundary_smooth](#nodebpy.nodes.geometry.SubdivisionSurface.i_boundary_smooth) | Input socket: Boundary Smooth |
| [i_edge_crease](#nodebpy.nodes.geometry.SubdivisionSurface.i_edge_crease) | Input socket: Edge Crease |
| [i_level](#nodebpy.nodes.geometry.SubdivisionSurface.i_level) | Input socket: Level |
| [i_limit_surface](#nodebpy.nodes.geometry.SubdivisionSurface.i_limit_surface) | Input socket: Limit Surface |
| [i_mesh](#nodebpy.nodes.geometry.SubdivisionSurface.i_mesh) | Input socket: Mesh |
| [i_uv_smooth](#nodebpy.nodes.geometry.SubdivisionSurface.i_uv_smooth) | Input socket: UV Smooth |
| [i_vertex_crease](#nodebpy.nodes.geometry.SubdivisionSurface.i_vertex_crease) | Input socket: Vertex Crease |
| [o_mesh](#nodebpy.nodes.geometry.SubdivisionSurface.o_mesh) | Output socket: Mesh |

### Switch { #nodebpy.nodes.geometry.Switch }

```python
nodes.geometry.Switch(
    switch=False,
    false=None,
    true=None,
    input_type='GEOMETRY',
    **kwargs,
)
```

Switch between two inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_false](#nodebpy.nodes.geometry.Switch.i_false) | Input socket: False |
| [i_switch](#nodebpy.nodes.geometry.Switch.i_switch) | Input socket: Switch |
| [i_true](#nodebpy.nodes.geometry.Switch.i_true) | Input socket: True |
| [o_output](#nodebpy.nodes.geometry.Switch.o_output) | Output socket: Output |

### TransformGeometry { #nodebpy.nodes.geometry.TransformGeometry }

```python
nodes.geometry.TransformGeometry(
    geometry=None,
    mode='Components',
    translation=[0.0, 0.0, 0.0],
    rotation=[0.0, 0.0, 0.0],
    scale=[1.0, 1.0, 1.0],
    transform=None,
    **kwargs,
)
```

Translate, rotate or scale the geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_geometry](#nodebpy.nodes.geometry.TransformGeometry.i_geometry) | Input socket: Geometry |
| [i_mode](#nodebpy.nodes.geometry.TransformGeometry.i_mode) | Input socket: Mode |
| [i_rotation](#nodebpy.nodes.geometry.TransformGeometry.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.geometry.TransformGeometry.i_scale) | Input socket: Scale |
| [i_transform](#nodebpy.nodes.geometry.TransformGeometry.i_transform) | Input socket: Transform |
| [i_translation](#nodebpy.nodes.geometry.TransformGeometry.i_translation) | Input socket: Translation |
| [o_geometry](#nodebpy.nodes.geometry.TransformGeometry.o_geometry) | Output socket: Geometry |

### TransformGizmo { #nodebpy.nodes.geometry.TransformGizmo }

```python
nodes.geometry.TransformGizmo(
    value=None,
    position=[0.0, 0.0, 0.0],
    rotation=[0.0, 0.0, 0.0],
    use_translation_x=False,
    use_translation_y=False,
    use_translation_z=False,
    use_rotation_x=False,
    use_rotation_y=False,
    use_rotation_z=False,
    use_scale_x=False,
    use_scale_y=False,
    use_scale_z=False,
    **kwargs,
)
```

Show a transform gizmo in the viewport

#### Attributes

| Name | Description |
| --- | --- |
| [i_position](#nodebpy.nodes.geometry.TransformGizmo.i_position) | Input socket: Position |
| [i_rotation](#nodebpy.nodes.geometry.TransformGizmo.i_rotation) | Input socket: Rotation |
| [i_value](#nodebpy.nodes.geometry.TransformGizmo.i_value) | Input socket: Value |
| [o_transform](#nodebpy.nodes.geometry.TransformGizmo.o_transform) | Output socket: Transform |

### TranslateInstances { #nodebpy.nodes.geometry.TranslateInstances }

```python
nodes.geometry.TranslateInstances(
    instances=None,
    selection=True,
    translation=[0.0, 0.0, 0.0],
    local_space=True,
    **kwargs,
)
```

Move top-level geometry instances in local or global space

#### Attributes

| Name | Description |
| --- | --- |
| [i_instances](#nodebpy.nodes.geometry.TranslateInstances.i_instances) | Input socket: Instances |
| [i_local_space](#nodebpy.nodes.geometry.TranslateInstances.i_local_space) | Input socket: Local Space |
| [i_selection](#nodebpy.nodes.geometry.TranslateInstances.i_selection) | Input socket: Selection |
| [i_translation](#nodebpy.nodes.geometry.TranslateInstances.i_translation) | Input socket: Translation |
| [o_instances](#nodebpy.nodes.geometry.TranslateInstances.o_instances) | Output socket: Instances |

### Triangulate { #nodebpy.nodes.geometry.Triangulate }

```python
nodes.geometry.Triangulate(
    mesh=None,
    selection=True,
    quad_method='Shortest Diagonal',
    n_gon_method='Beauty',
    **kwargs,
)
```

Convert all faces in a mesh to triangular faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.geometry.Triangulate.i_mesh) | Input socket: Mesh |
| [i_n_gon_method](#nodebpy.nodes.geometry.Triangulate.i_n_gon_method) | Input socket: N-gon Method |
| [i_quad_method](#nodebpy.nodes.geometry.Triangulate.i_quad_method) | Input socket: Quad Method |
| [i_selection](#nodebpy.nodes.geometry.Triangulate.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.geometry.Triangulate.o_mesh) | Output socket: Mesh |

### UVTangent { #nodebpy.nodes.geometry.UVTangent }

```python
nodes.geometry.UVTangent(method='Exact', uv=[0.0, 0.0], **kwargs)
```

Generate tangent directions based on a UV map

#### Attributes

| Name | Description |
| --- | --- |
| [i_method](#nodebpy.nodes.geometry.UVTangent.i_method) | Input socket: Method |
| [i_uv](#nodebpy.nodes.geometry.UVTangent.i_uv) | Input socket: UV |
| [o_tangent](#nodebpy.nodes.geometry.UVTangent.o_tangent) | Output socket: Tangent |

### UVUnwrap { #nodebpy.nodes.geometry.UVUnwrap }

```python
nodes.geometry.UVUnwrap(
    selection=True,
    seam=False,
    margin=0.0010000000474974513,
    fill_holes=True,
    method='Angle Based',
    **kwargs,
)
```

Generate a UV map based on seam edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_fill_holes](#nodebpy.nodes.geometry.UVUnwrap.i_fill_holes) | Input socket: Fill Holes |
| [i_margin](#nodebpy.nodes.geometry.UVUnwrap.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.geometry.UVUnwrap.i_method) | Input socket: Method |
| [i_seam](#nodebpy.nodes.geometry.UVUnwrap.i_seam) | Input socket: Seam |
| [i_selection](#nodebpy.nodes.geometry.UVUnwrap.i_selection) | Input socket: Selection |
| [o_uv](#nodebpy.nodes.geometry.UVUnwrap.o_uv) | Output socket: UV |

### VertexOfCorner { #nodebpy.nodes.geometry.VertexOfCorner }

```python
nodes.geometry.VertexOfCorner(corner_index=0, **kwargs)
```

Retrieve the vertex each face corner is attached to

#### Attributes

| Name | Description |
| --- | --- |
| [i_corner_index](#nodebpy.nodes.geometry.VertexOfCorner.i_corner_index) | Input socket: Corner Index |
| [o_vertex_index](#nodebpy.nodes.geometry.VertexOfCorner.o_vertex_index) | Output socket: Vertex Index |

### Viewer { #nodebpy.nodes.geometry.Viewer }

```python
nodes.geometry.Viewer(
    extend=None,
    ui_shortcut=0,
    active_index=0,
    domain='AUTO',
    **kwargs,
)
```

Display the input data in the Spreadsheet Editor

#### Attributes

| Name | Description |
| --- | --- |
| [i_input_socket](#nodebpy.nodes.geometry.Viewer.i_input_socket) | Input socket: |

### ViewportTransform { #nodebpy.nodes.geometry.ViewportTransform }

```python
nodes.geometry.ViewportTransform(**kwargs)
```

Retrieve the view direction and location of the 3D viewport

#### Attributes

| Name | Description |
| --- | --- |
| [o_is_orthographic](#nodebpy.nodes.geometry.ViewportTransform.o_is_orthographic) | Output socket: Is Orthographic |
| [o_projection](#nodebpy.nodes.geometry.ViewportTransform.o_projection) | Output socket: Projection |
| [o_view](#nodebpy.nodes.geometry.ViewportTransform.o_view) | Output socket: View |

### VolumeCube { #nodebpy.nodes.geometry.VolumeCube }

```python
nodes.geometry.VolumeCube(
    density=1.0,
    background=0.0,
    min=[-1.0, -1.0, -1.0],
    max=[1.0, 1.0, 1.0],
    resolution_x=32,
    resolution_y=32,
    resolution_z=32,
    **kwargs,
)
```

Generate a dense volume with a field that controls the density at each grid voxel based on its position

#### Attributes

| Name | Description |
| --- | --- |
| [i_background](#nodebpy.nodes.geometry.VolumeCube.i_background) | Input socket: Background |
| [i_density](#nodebpy.nodes.geometry.VolumeCube.i_density) | Input socket: Density |
| [i_max](#nodebpy.nodes.geometry.VolumeCube.i_max) | Input socket: Max |
| [i_min](#nodebpy.nodes.geometry.VolumeCube.i_min) | Input socket: Min |
| [i_resolution_x](#nodebpy.nodes.geometry.VolumeCube.i_resolution_x) | Input socket: Resolution X |
| [i_resolution_y](#nodebpy.nodes.geometry.VolumeCube.i_resolution_y) | Input socket: Resolution Y |
| [i_resolution_z](#nodebpy.nodes.geometry.VolumeCube.i_resolution_z) | Input socket: Resolution Z |
| [o_volume](#nodebpy.nodes.geometry.VolumeCube.o_volume) | Output socket: Volume |

### VoxelizeGrid { #nodebpy.nodes.geometry.VoxelizeGrid }

```python
nodes.geometry.VoxelizeGrid(grid=0.0, data_type='FLOAT', **kwargs)
```

Remove sparseness from a volume grid by making the active tiles into voxels

#### Attributes

| Name | Description |
| --- | --- |
| [i_grid](#nodebpy.nodes.geometry.VoxelizeGrid.i_grid) | Input socket: Grid |
| [o_grid](#nodebpy.nodes.geometry.VoxelizeGrid.o_grid) | Output socket: Grid |

### Warning { #nodebpy.nodes.geometry.Warning }

```python
nodes.geometry.Warning(show=True, message='', warning_type='ERROR', **kwargs)
```

Create custom warnings in node groups

#### Attributes

| Name | Description |
| --- | --- |
| [i_message](#nodebpy.nodes.geometry.Warning.i_message) | Input socket: Message |
| [i_show](#nodebpy.nodes.geometry.Warning.i_show) | Input socket: Show |
| [o_show](#nodebpy.nodes.geometry.Warning.o_show) | Output socket: Show |