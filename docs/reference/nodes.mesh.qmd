# nodes.mesh { #nodebpy.nodes.mesh }

`nodes.mesh`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [Cone](#nodebpy.nodes.mesh.Cone) | Generate a cone mesh |
| [Cube](#nodebpy.nodes.mesh.Cube) | Generate a cuboid mesh with variable side lengths and subdivisions |
| [CurveToMesh](#nodebpy.nodes.mesh.CurveToMesh) | Convert curves into a mesh, optionally with a custom profile shape defined by curves |
| [Cylinder](#nodebpy.nodes.mesh.Cylinder) | Generate a cylinder mesh |
| [DualMesh](#nodebpy.nodes.mesh.DualMesh) | Convert Faces into vertices and vertices into faces |
| [EdgeAngle](#nodebpy.nodes.mesh.EdgeAngle) | The angle between the normals of connected manifold faces |
| [EdgeNeighbors](#nodebpy.nodes.mesh.EdgeNeighbors) | Retrieve the number of faces that use each edge as one of their sides |
| [EdgeVertices](#nodebpy.nodes.mesh.EdgeVertices) | Retrieve topology information relating to each edge of a mesh |
| [ExtrudeMesh](#nodebpy.nodes.mesh.ExtrudeMesh) | Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary |
| [FaceArea](#nodebpy.nodes.mesh.FaceArea) | Calculate the surface area of a mesh's faces |
| [FaceGroupBoundaries](#nodebpy.nodes.mesh.FaceGroupBoundaries) | Find edges on the boundaries between groups of faces with the same ID value |
| [FaceNeighbors](#nodebpy.nodes.mesh.FaceNeighbors) | Retrieve topology information relating to each face of a mesh |
| [Grid](#nodebpy.nodes.mesh.Grid) | Generate a planar mesh on the XY plane |
| [GridToMesh](#nodebpy.nodes.mesh.GridToMesh) | Generate a mesh on the "surface" of a volume grid |
| [IcoSphere](#nodebpy.nodes.mesh.IcoSphere) | Generate a spherical mesh that consists of equally sized triangles |
| [IsFacePlanar](#nodebpy.nodes.mesh.IsFacePlanar) | Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal |
| [MeshBoolean](#nodebpy.nodes.mesh.MeshBoolean) | Cut, subtract, or join multiple mesh inputs |
| [MeshCircle](#nodebpy.nodes.mesh.MeshCircle) | Generate a circular ring of edges |
| [MeshIsland](#nodebpy.nodes.mesh.MeshIsland) | Retrieve information about separate connected regions in a mesh |
| [MeshLine](#nodebpy.nodes.mesh.MeshLine) | Generate vertices in a line and connect them with edges |
| [MeshToCurve](#nodebpy.nodes.mesh.MeshToCurve) | Generate a curve from a mesh |
| [MeshToDensityGrid](#nodebpy.nodes.mesh.MeshToDensityGrid) | Create a filled volume grid from a mesh |
| [MeshToPoints](#nodebpy.nodes.mesh.MeshToPoints) | Generate a point cloud from a mesh's vertices |
| [MeshToSDFGrid](#nodebpy.nodes.mesh.MeshToSDFGrid) | Create a signed distance volume grid from a mesh |
| [MeshToVolume](#nodebpy.nodes.mesh.MeshToVolume) | Create a fog volume with the shape of the input mesh's surface |
| [SetMeshNormal](#nodebpy.nodes.mesh.SetMeshNormal) | Store a normal vector for each mesh element |
| [SubdivideMesh](#nodebpy.nodes.mesh.SubdivideMesh) | Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices |
| [UVSphere](#nodebpy.nodes.mesh.UVSphere) | Generate a spherical mesh with quads, except for triangles at the top and bottom |
| [VertexNeighbors](#nodebpy.nodes.mesh.VertexNeighbors) | Retrieve topology information relating to each vertex of a mesh |
| [VolumeToMesh](#nodebpy.nodes.mesh.VolumeToMesh) | Generate a mesh on the "surface" of a volume |

### Cone { #nodebpy.nodes.mesh.Cone }

```python
nodes.mesh.Cone(
    vertices=32,
    side_segments=1,
    fill_segments=1,
    radius_top=0.0,
    radius_bottom=1.0,
    depth=2.0,
    fill_type='NGON',
    **kwargs,
)
```

Generate a cone mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_depth](#nodebpy.nodes.mesh.Cone.i_depth) | Input socket: Depth |
| [i_fill_segments](#nodebpy.nodes.mesh.Cone.i_fill_segments) | Input socket: Fill Segments |
| [i_radius_bottom](#nodebpy.nodes.mesh.Cone.i_radius_bottom) | Input socket: Radius Bottom |
| [i_radius_top](#nodebpy.nodes.mesh.Cone.i_radius_top) | Input socket: Radius Top |
| [i_side_segments](#nodebpy.nodes.mesh.Cone.i_side_segments) | Input socket: Side Segments |
| [i_vertices](#nodebpy.nodes.mesh.Cone.i_vertices) | Input socket: Vertices |
| [o_bottom](#nodebpy.nodes.mesh.Cone.o_bottom) | Output socket: Bottom |
| [o_mesh](#nodebpy.nodes.mesh.Cone.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.mesh.Cone.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.mesh.Cone.o_top) | Output socket: Top |
| [o_uv_map](#nodebpy.nodes.mesh.Cone.o_uv_map) | Output socket: UV Map |

### Cube { #nodebpy.nodes.mesh.Cube }

```python
nodes.mesh.Cube(
    size=[1.0, 1.0, 1.0],
    vertices_x=2,
    vertices_y=2,
    vertices_z=2,
    **kwargs,
)
```

Generate a cuboid mesh with variable side lengths and subdivisions

#### Attributes

| Name | Description |
| --- | --- |
| [i_size](#nodebpy.nodes.mesh.Cube.i_size) | Input socket: Size |
| [i_vertices_x](#nodebpy.nodes.mesh.Cube.i_vertices_x) | Input socket: Vertices X |
| [i_vertices_y](#nodebpy.nodes.mesh.Cube.i_vertices_y) | Input socket: Vertices Y |
| [i_vertices_z](#nodebpy.nodes.mesh.Cube.i_vertices_z) | Input socket: Vertices Z |
| [o_mesh](#nodebpy.nodes.mesh.Cube.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.mesh.Cube.o_uv_map) | Output socket: UV Map |

### CurveToMesh { #nodebpy.nodes.mesh.CurveToMesh }

```python
nodes.mesh.CurveToMesh(
    curve=None,
    profile_curve=None,
    scale=1.0,
    fill_caps=False,
    **kwargs,
)
```

Convert curves into a mesh, optionally with a custom profile shape defined by curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.mesh.CurveToMesh.i_curve) | Input socket: Curve |
| [i_fill_caps](#nodebpy.nodes.mesh.CurveToMesh.i_fill_caps) | Input socket: Fill Caps |
| [i_profile_curve](#nodebpy.nodes.mesh.CurveToMesh.i_profile_curve) | Input socket: Profile Curve |
| [i_scale](#nodebpy.nodes.mesh.CurveToMesh.i_scale) | Input socket: Scale |
| [o_mesh](#nodebpy.nodes.mesh.CurveToMesh.o_mesh) | Output socket: Mesh |

### Cylinder { #nodebpy.nodes.mesh.Cylinder }

```python
nodes.mesh.Cylinder(
    vertices=32,
    side_segments=1,
    fill_segments=1,
    radius=1.0,
    depth=2.0,
    fill_type='NGON',
    **kwargs,
)
```

Generate a cylinder mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_depth](#nodebpy.nodes.mesh.Cylinder.i_depth) | Input socket: Depth |
| [i_fill_segments](#nodebpy.nodes.mesh.Cylinder.i_fill_segments) | Input socket: Fill Segments |
| [i_radius](#nodebpy.nodes.mesh.Cylinder.i_radius) | Input socket: Radius |
| [i_side_segments](#nodebpy.nodes.mesh.Cylinder.i_side_segments) | Input socket: Side Segments |
| [i_vertices](#nodebpy.nodes.mesh.Cylinder.i_vertices) | Input socket: Vertices |
| [o_bottom](#nodebpy.nodes.mesh.Cylinder.o_bottom) | Output socket: Bottom |
| [o_mesh](#nodebpy.nodes.mesh.Cylinder.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.mesh.Cylinder.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.mesh.Cylinder.o_top) | Output socket: Top |
| [o_uv_map](#nodebpy.nodes.mesh.Cylinder.o_uv_map) | Output socket: UV Map |

### DualMesh { #nodebpy.nodes.mesh.DualMesh }

```python
nodes.mesh.DualMesh(mesh=None, keep_boundaries=False, **kwargs)
```

Convert Faces into vertices and vertices into faces

#### Attributes

| Name | Description |
| --- | --- |
| [i_keep_boundaries](#nodebpy.nodes.mesh.DualMesh.i_keep_boundaries) | Input socket: Keep Boundaries |
| [i_mesh](#nodebpy.nodes.mesh.DualMesh.i_mesh) | Input socket: Mesh |
| [o_dual_mesh](#nodebpy.nodes.mesh.DualMesh.o_dual_mesh) | Output socket: Dual Mesh |

### EdgeAngle { #nodebpy.nodes.mesh.EdgeAngle }

```python
nodes.mesh.EdgeAngle(**kwargs)
```

The angle between the normals of connected manifold faces

#### Attributes

| Name | Description |
| --- | --- |
| [o_signed_angle](#nodebpy.nodes.mesh.EdgeAngle.o_signed_angle) | Output socket: Signed Angle |
| [o_unsigned_angle](#nodebpy.nodes.mesh.EdgeAngle.o_unsigned_angle) | Output socket: Unsigned Angle |

### EdgeNeighbors { #nodebpy.nodes.mesh.EdgeNeighbors }

```python
nodes.mesh.EdgeNeighbors(**kwargs)
```

Retrieve the number of faces that use each edge as one of their sides

#### Attributes

| Name | Description |
| --- | --- |
| [o_face_count](#nodebpy.nodes.mesh.EdgeNeighbors.o_face_count) | Output socket: Face Count |

### EdgeVertices { #nodebpy.nodes.mesh.EdgeVertices }

```python
nodes.mesh.EdgeVertices(**kwargs)
```

Retrieve topology information relating to each edge of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [o_position_1](#nodebpy.nodes.mesh.EdgeVertices.o_position_1) | Output socket: Position 1 |
| [o_position_2](#nodebpy.nodes.mesh.EdgeVertices.o_position_2) | Output socket: Position 2 |
| [o_vertex_index_1](#nodebpy.nodes.mesh.EdgeVertices.o_vertex_index_1) | Output socket: Vertex Index 1 |
| [o_vertex_index_2](#nodebpy.nodes.mesh.EdgeVertices.o_vertex_index_2) | Output socket: Vertex Index 2 |

### ExtrudeMesh { #nodebpy.nodes.mesh.ExtrudeMesh }

```python
nodes.mesh.ExtrudeMesh(
    mesh=None,
    selection=True,
    offset=[0.0, 0.0, 0.0],
    offset_scale=1.0,
    individual=True,
    mode='FACES',
    **kwargs,
)
```

Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary

#### Attributes

| Name | Description |
| --- | --- |
| [i_individual](#nodebpy.nodes.mesh.ExtrudeMesh.i_individual) | Input socket: Individual |
| [i_mesh](#nodebpy.nodes.mesh.ExtrudeMesh.i_mesh) | Input socket: Mesh |
| [i_offset](#nodebpy.nodes.mesh.ExtrudeMesh.i_offset) | Input socket: Offset |
| [i_offset_scale](#nodebpy.nodes.mesh.ExtrudeMesh.i_offset_scale) | Input socket: Offset Scale |
| [i_selection](#nodebpy.nodes.mesh.ExtrudeMesh.i_selection) | Input socket: Selection |
| [o_mesh](#nodebpy.nodes.mesh.ExtrudeMesh.o_mesh) | Output socket: Mesh |
| [o_side](#nodebpy.nodes.mesh.ExtrudeMesh.o_side) | Output socket: Side |
| [o_top](#nodebpy.nodes.mesh.ExtrudeMesh.o_top) | Output socket: Top |

### FaceArea { #nodebpy.nodes.mesh.FaceArea }

```python
nodes.mesh.FaceArea(**kwargs)
```

Calculate the surface area of a mesh's faces

#### Attributes

| Name | Description |
| --- | --- |
| [o_area](#nodebpy.nodes.mesh.FaceArea.o_area) | Output socket: Area |

### FaceGroupBoundaries { #nodebpy.nodes.mesh.FaceGroupBoundaries }

```python
nodes.mesh.FaceGroupBoundaries(face_set=0, **kwargs)
```

Find edges on the boundaries between groups of faces with the same ID value

#### Attributes

| Name | Description |
| --- | --- |
| [i_face_group_id](#nodebpy.nodes.mesh.FaceGroupBoundaries.i_face_group_id) | Input socket: Face Group ID |
| [o_boundary_edges](#nodebpy.nodes.mesh.FaceGroupBoundaries.o_boundary_edges) | Output socket: Boundary Edges |

### FaceNeighbors { #nodebpy.nodes.mesh.FaceNeighbors }

```python
nodes.mesh.FaceNeighbors(**kwargs)
```

Retrieve topology information relating to each face of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [o_face_count](#nodebpy.nodes.mesh.FaceNeighbors.o_face_count) | Output socket: Face Count |
| [o_vertex_count](#nodebpy.nodes.mesh.FaceNeighbors.o_vertex_count) | Output socket: Vertex Count |

### Grid { #nodebpy.nodes.mesh.Grid }

```python
nodes.mesh.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3, **kwargs)
```

Generate a planar mesh on the XY plane

#### Attributes

| Name | Description |
| --- | --- |
| [i_size_x](#nodebpy.nodes.mesh.Grid.i_size_x) | Input socket: Size X |
| [i_size_y](#nodebpy.nodes.mesh.Grid.i_size_y) | Input socket: Size Y |
| [i_vertices_x](#nodebpy.nodes.mesh.Grid.i_vertices_x) | Input socket: Vertices X |
| [i_vertices_y](#nodebpy.nodes.mesh.Grid.i_vertices_y) | Input socket: Vertices Y |
| [o_mesh](#nodebpy.nodes.mesh.Grid.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.mesh.Grid.o_uv_map) | Output socket: UV Map |

### GridToMesh { #nodebpy.nodes.mesh.GridToMesh }

```python
nodes.mesh.GridToMesh(
    grid=0.0,
    threshold=0.10000000149011612,
    adaptivity=0.0,
    **kwargs,
)
```

Generate a mesh on the "surface" of a volume grid

#### Attributes

| Name | Description |
| --- | --- |
| [i_adaptivity](#nodebpy.nodes.mesh.GridToMesh.i_adaptivity) | Input socket: Adaptivity |
| [i_grid](#nodebpy.nodes.mesh.GridToMesh.i_grid) | Input socket: Grid |
| [i_threshold](#nodebpy.nodes.mesh.GridToMesh.i_threshold) | Input socket: Threshold |
| [o_mesh](#nodebpy.nodes.mesh.GridToMesh.o_mesh) | Output socket: Mesh |

### IcoSphere { #nodebpy.nodes.mesh.IcoSphere }

```python
nodes.mesh.IcoSphere(radius=1.0, subdivisions=1, **kwargs)
```

Generate a spherical mesh that consists of equally sized triangles

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.mesh.IcoSphere.i_radius) | Input socket: Radius |
| [i_subdivisions](#nodebpy.nodes.mesh.IcoSphere.i_subdivisions) | Input socket: Subdivisions |
| [o_mesh](#nodebpy.nodes.mesh.IcoSphere.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.mesh.IcoSphere.o_uv_map) | Output socket: UV Map |

### IsFacePlanar { #nodebpy.nodes.mesh.IsFacePlanar }

```python
nodes.mesh.IsFacePlanar(threshold=0.009999999776482582, **kwargs)
```

Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal

#### Attributes

| Name | Description |
| --- | --- |
| [i_threshold](#nodebpy.nodes.mesh.IsFacePlanar.i_threshold) | Input socket: Threshold |
| [o_planar](#nodebpy.nodes.mesh.IsFacePlanar.o_planar) | Output socket: Planar |

### MeshBoolean { #nodebpy.nodes.mesh.MeshBoolean }

```python
nodes.mesh.MeshBoolean(
    mesh_1=None,
    mesh_2=None,
    operation='DIFFERENCE',
    solver='FLOAT',
    **kwargs,
)
```

Cut, subtract, or join multiple mesh inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh_1](#nodebpy.nodes.mesh.MeshBoolean.i_mesh_1) | Input socket: Mesh 1 |
| [i_mesh_2](#nodebpy.nodes.mesh.MeshBoolean.i_mesh_2) | Input socket: Mesh 2 |
| [o_mesh](#nodebpy.nodes.mesh.MeshBoolean.o_mesh) | Output socket: Mesh |

#### Methods

| Name | Description |
| --- | --- |
| [difference](#nodebpy.nodes.mesh.MeshBoolean.difference) | Create Mesh Boolean with operation 'Difference'. |
| [intersect](#nodebpy.nodes.mesh.MeshBoolean.intersect) | Create Mesh Boolean with operation 'Intersect'. |
| [union](#nodebpy.nodes.mesh.MeshBoolean.union) | Create Mesh Boolean with operation 'Union'. |

##### difference { #nodebpy.nodes.mesh.MeshBoolean.difference }

```python
nodes.mesh.MeshBoolean.difference(mesh_1=None, mesh_2=None)
```

Create Mesh Boolean with operation 'Difference'.

##### intersect { #nodebpy.nodes.mesh.MeshBoolean.intersect }

```python
nodes.mesh.MeshBoolean.intersect(mesh_1=None, mesh_2=None)
```

Create Mesh Boolean with operation 'Intersect'.

##### union { #nodebpy.nodes.mesh.MeshBoolean.union }

```python
nodes.mesh.MeshBoolean.union(mesh_1=None, mesh_2=None)
```

Create Mesh Boolean with operation 'Union'.

### MeshCircle { #nodebpy.nodes.mesh.MeshCircle }

```python
nodes.mesh.MeshCircle(vertices=32, radius=1.0, fill_type='NONE', **kwargs)
```

Generate a circular ring of edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.mesh.MeshCircle.i_radius) | Input socket: Radius |
| [i_vertices](#nodebpy.nodes.mesh.MeshCircle.i_vertices) | Input socket: Vertices |
| [o_mesh](#nodebpy.nodes.mesh.MeshCircle.o_mesh) | Output socket: Mesh |

### MeshIsland { #nodebpy.nodes.mesh.MeshIsland }

```python
nodes.mesh.MeshIsland(**kwargs)
```

Retrieve information about separate connected regions in a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [o_island_count](#nodebpy.nodes.mesh.MeshIsland.o_island_count) | Output socket: Island Count |
| [o_island_index](#nodebpy.nodes.mesh.MeshIsland.o_island_index) | Output socket: Island Index |

### MeshLine { #nodebpy.nodes.mesh.MeshLine }

```python
nodes.mesh.MeshLine(
    count=10,
    start_location=[0.0, 0.0, 0.0],
    offset=[0.0, 0.0, 1.0],
    mode='OFFSET',
    count_mode='TOTAL',
    **kwargs,
)
```

Generate vertices in a line and connect them with edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.mesh.MeshLine.i_count) | Input socket: Count |
| [i_offset](#nodebpy.nodes.mesh.MeshLine.i_offset) | Input socket: Offset |
| [i_start_location](#nodebpy.nodes.mesh.MeshLine.i_start_location) | Input socket: Start Location |
| [o_mesh](#nodebpy.nodes.mesh.MeshLine.o_mesh) | Output socket: Mesh |

### MeshToCurve { #nodebpy.nodes.mesh.MeshToCurve }

```python
nodes.mesh.MeshToCurve(mesh=None, selection=True, mode='EDGES', **kwargs)
```

Generate a curve from a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.mesh.MeshToCurve.i_mesh) | Input socket: Mesh |
| [i_selection](#nodebpy.nodes.mesh.MeshToCurve.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.mesh.MeshToCurve.o_curve) | Output socket: Curve |

### MeshToDensityGrid { #nodebpy.nodes.mesh.MeshToDensityGrid }

```python
nodes.mesh.MeshToDensityGrid(
    mesh=None,
    density=1.0,
    voxel_size=0.30000001192092896,
    gradient_width=0.20000000298023224,
    **kwargs,
)
```

Create a filled volume grid from a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.mesh.MeshToDensityGrid.i_density) | Input socket: Density |
| [i_gradient_width](#nodebpy.nodes.mesh.MeshToDensityGrid.i_gradient_width) | Input socket: Gradient Width |
| [i_mesh](#nodebpy.nodes.mesh.MeshToDensityGrid.i_mesh) | Input socket: Mesh |
| [i_voxel_size](#nodebpy.nodes.mesh.MeshToDensityGrid.i_voxel_size) | Input socket: Voxel Size |
| [o_density_grid](#nodebpy.nodes.mesh.MeshToDensityGrid.o_density_grid) | Output socket: Density Grid |

### MeshToPoints { #nodebpy.nodes.mesh.MeshToPoints }

```python
nodes.mesh.MeshToPoints(
    mesh=None,
    selection=True,
    position=[0.0, 0.0, 0.0],
    radius=0.05000000074505806,
    mode='VERTICES',
    **kwargs,
)
```

Generate a point cloud from a mesh's vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.mesh.MeshToPoints.i_mesh) | Input socket: Mesh |
| [i_position](#nodebpy.nodes.mesh.MeshToPoints.i_position) | Input socket: Position |
| [i_radius](#nodebpy.nodes.mesh.MeshToPoints.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.mesh.MeshToPoints.i_selection) | Input socket: Selection |
| [o_points](#nodebpy.nodes.mesh.MeshToPoints.o_points) | Output socket: Points |

### MeshToSDFGrid { #nodebpy.nodes.mesh.MeshToSDFGrid }

```python
nodes.mesh.MeshToSDFGrid(
    mesh=None,
    voxel_size=0.30000001192092896,
    band_width=3,
    **kwargs,
)
```

Create a signed distance volume grid from a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_band_width](#nodebpy.nodes.mesh.MeshToSDFGrid.i_band_width) | Input socket: Band Width |
| [i_mesh](#nodebpy.nodes.mesh.MeshToSDFGrid.i_mesh) | Input socket: Mesh |
| [i_voxel_size](#nodebpy.nodes.mesh.MeshToSDFGrid.i_voxel_size) | Input socket: Voxel Size |
| [o_sdf_grid](#nodebpy.nodes.mesh.MeshToSDFGrid.o_sdf_grid) | Output socket: SDF Grid |

### MeshToVolume { #nodebpy.nodes.mesh.MeshToVolume }

```python
nodes.mesh.MeshToVolume(
    mesh=None,
    density=1.0,
    resolution_mode='Amount',
    voxel_size=0.30000001192092896,
    voxel_amount=64.0,
    interior_band_width=0.20000000298023224,
    **kwargs,
)
```

Create a fog volume with the shape of the input mesh's surface

#### Attributes

| Name | Description |
| --- | --- |
| [i_density](#nodebpy.nodes.mesh.MeshToVolume.i_density) | Input socket: Density |
| [i_interior_band_width](#nodebpy.nodes.mesh.MeshToVolume.i_interior_band_width) | Input socket: Interior Band Width |
| [i_mesh](#nodebpy.nodes.mesh.MeshToVolume.i_mesh) | Input socket: Mesh |
| [i_resolution_mode](#nodebpy.nodes.mesh.MeshToVolume.i_resolution_mode) | Input socket: Resolution Mode |
| [i_voxel_amount](#nodebpy.nodes.mesh.MeshToVolume.i_voxel_amount) | Input socket: Voxel Amount |
| [i_voxel_size](#nodebpy.nodes.mesh.MeshToVolume.i_voxel_size) | Input socket: Voxel Size |
| [o_volume](#nodebpy.nodes.mesh.MeshToVolume.o_volume) | Output socket: Volume |

### SetMeshNormal { #nodebpy.nodes.mesh.SetMeshNormal }

```python
nodes.mesh.SetMeshNormal(
    mesh=None,
    remove_custom=True,
    edge_sharpness=False,
    face_sharpness=False,
    mode='SHARPNESS',
    domain='POINT',
    **kwargs,
)
```

Store a normal vector for each mesh element

#### Attributes

| Name | Description |
| --- | --- |
| [i_edge_sharpness](#nodebpy.nodes.mesh.SetMeshNormal.i_edge_sharpness) | Input socket: Edge Sharpness |
| [i_face_sharpness](#nodebpy.nodes.mesh.SetMeshNormal.i_face_sharpness) | Input socket: Face Sharpness |
| [i_mesh](#nodebpy.nodes.mesh.SetMeshNormal.i_mesh) | Input socket: Mesh |
| [i_remove_custom](#nodebpy.nodes.mesh.SetMeshNormal.i_remove_custom) | Input socket: Remove Custom |
| [o_mesh](#nodebpy.nodes.mesh.SetMeshNormal.o_mesh) | Output socket: Mesh |

### SubdivideMesh { #nodebpy.nodes.mesh.SubdivideMesh }

```python
nodes.mesh.SubdivideMesh(mesh=None, level=1, **kwargs)
```

Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices

#### Attributes

| Name | Description |
| --- | --- |
| [i_level](#nodebpy.nodes.mesh.SubdivideMesh.i_level) | Input socket: Level |
| [i_mesh](#nodebpy.nodes.mesh.SubdivideMesh.i_mesh) | Input socket: Mesh |
| [o_mesh](#nodebpy.nodes.mesh.SubdivideMesh.o_mesh) | Output socket: Mesh |

### UVSphere { #nodebpy.nodes.mesh.UVSphere }

```python
nodes.mesh.UVSphere(segments=32, rings=16, radius=1.0, **kwargs)
```

Generate a spherical mesh with quads, except for triangles at the top and bottom

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.mesh.UVSphere.i_radius) | Input socket: Radius |
| [i_rings](#nodebpy.nodes.mesh.UVSphere.i_rings) | Input socket: Rings |
| [i_segments](#nodebpy.nodes.mesh.UVSphere.i_segments) | Input socket: Segments |
| [o_mesh](#nodebpy.nodes.mesh.UVSphere.o_mesh) | Output socket: Mesh |
| [o_uv_map](#nodebpy.nodes.mesh.UVSphere.o_uv_map) | Output socket: UV Map |

### VertexNeighbors { #nodebpy.nodes.mesh.VertexNeighbors }

```python
nodes.mesh.VertexNeighbors(**kwargs)
```

Retrieve topology information relating to each vertex of a mesh

#### Attributes

| Name | Description |
| --- | --- |
| [o_face_count](#nodebpy.nodes.mesh.VertexNeighbors.o_face_count) | Output socket: Face Count |
| [o_vertex_count](#nodebpy.nodes.mesh.VertexNeighbors.o_vertex_count) | Output socket: Vertex Count |

### VolumeToMesh { #nodebpy.nodes.mesh.VolumeToMesh }

```python
nodes.mesh.VolumeToMesh(
    volume=None,
    resolution_mode='Grid',
    voxel_size=0.30000001192092896,
    voxel_amount=64.0,
    threshold=0.10000000149011612,
    adaptivity=0.0,
    **kwargs,
)
```

Generate a mesh on the "surface" of a volume

#### Attributes

| Name | Description |
| --- | --- |
| [i_adaptivity](#nodebpy.nodes.mesh.VolumeToMesh.i_adaptivity) | Input socket: Adaptivity |
| [i_resolution_mode](#nodebpy.nodes.mesh.VolumeToMesh.i_resolution_mode) | Input socket: Resolution Mode |
| [i_threshold](#nodebpy.nodes.mesh.VolumeToMesh.i_threshold) | Input socket: Threshold |
| [i_volume](#nodebpy.nodes.mesh.VolumeToMesh.i_volume) | Input socket: Volume |
| [i_voxel_amount](#nodebpy.nodes.mesh.VolumeToMesh.i_voxel_amount) | Input socket: Voxel Amount |
| [i_voxel_size](#nodebpy.nodes.mesh.VolumeToMesh.i_voxel_size) | Input socket: Voxel Size |
| [o_mesh](#nodebpy.nodes.mesh.VolumeToMesh.o_mesh) | Output socket: Mesh |