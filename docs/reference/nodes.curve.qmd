# nodes.curve { #nodebpy.nodes.curve }

`nodes.curve`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [Arc](#nodebpy.nodes.curve.Arc) | Generate a poly spline arc |
| [BezierSegment](#nodebpy.nodes.curve.BezierSegment) | Generate a 2D Bézier spline from the given control points and handles |
| [CurveCircle](#nodebpy.nodes.curve.CurveCircle) | Generate a poly spline circle |
| [CurveHandlePositions](#nodebpy.nodes.curve.CurveHandlePositions) | Retrieve the position of each Bézier control point's handles |
| [CurveLength](#nodebpy.nodes.curve.CurveLength) | Retrieve the length of all splines added together |
| [CurveLine](#nodebpy.nodes.curve.CurveLine) | Generate a poly spline line with two points |
| [CurveOfPoint](#nodebpy.nodes.curve.CurveOfPoint) | Retrieve the curve a control point is part of |
| [CurveTilt](#nodebpy.nodes.curve.CurveTilt) | Retrieve the angle at each control point used to twist the curve's normal around its tangent |
| [CurveToPoints](#nodebpy.nodes.curve.CurveToPoints) | Generate a point cloud by sampling positions along curves |
| [CurvesToGreasePencil](#nodebpy.nodes.curve.CurvesToGreasePencil) | Convert the curves in each top-level instance into Grease Pencil layer |
| [DeformCurvesOnSurface](#nodebpy.nodes.curve.DeformCurvesOnSurface) | Translate and rotate curves based on changes between the object's original and evaluated surface mesh |
| [EdgePathsToCurves](#nodebpy.nodes.curve.EdgePathsToCurves) | Output curves following paths across mesh edges |
| [EndpointSelection](#nodebpy.nodes.curve.EndpointSelection) | Provide a selection for an arbitrary number of endpoints in each spline |
| [FillCurve](#nodebpy.nodes.curve.FillCurve) | Generate a mesh on the XY plane with faces on the inside of input curves |
| [FilletCurve](#nodebpy.nodes.curve.FilletCurve) | Round corners by generating circular arcs on each control point |
| [FloatCurve](#nodebpy.nodes.curve.FloatCurve) | Map an input float to a curve and outputs a float value |
| [GreasePencilToCurves](#nodebpy.nodes.curve.GreasePencilToCurves) | Convert Grease Pencil layers into curve instances |
| [HandleTypeSelection](#nodebpy.nodes.curve.HandleTypeSelection) | Provide a selection based on the handle types of Bézier control points |
| [InterpolateCurves](#nodebpy.nodes.curve.InterpolateCurves) | Generate new curves on points by interpolating between existing curves |
| [OffsetPointInCurve](#nodebpy.nodes.curve.OffsetPointInCurve) | Offset a control point index within its curve |
| [PointsOfCurve](#nodebpy.nodes.curve.PointsOfCurve) | Retrieve a point index within a curve |
| [PointsToCurves](#nodebpy.nodes.curve.PointsToCurves) | Split all points to curve by its group ID and reorder by weight |
| [QuadraticBezier](#nodebpy.nodes.curve.QuadraticBezier) | Generate a poly spline in a parabola shape with control points positions |
| [Quadrilateral](#nodebpy.nodes.curve.Quadrilateral) | Generate a polygon with four points |
| [ResampleCurve](#nodebpy.nodes.curve.ResampleCurve) | Generate a poly spline for each input spline |
| [ReverseCurve](#nodebpy.nodes.curve.ReverseCurve) | Change the direction of curves by swapping their start and end data |
| [RgbCurves](#nodebpy.nodes.curve.RgbCurves) | Apply color corrections for each color channel |
| [SampleCurve](#nodebpy.nodes.curve.SampleCurve) | Retrieve data from a point on a curve at a certain distance from its start |
| [SetCurveNormal](#nodebpy.nodes.curve.SetCurveNormal) | Set the evaluation mode for curve normals |
| [SetCurveRadius](#nodebpy.nodes.curve.SetCurveRadius) | Set the radius of the curve at each control point |
| [SetCurveTilt](#nodebpy.nodes.curve.SetCurveTilt) | Set the tilt angle at each curve control point |
| [SetHandlePositions](#nodebpy.nodes.curve.SetHandlePositions) | Set the positions for the handles of Bézier curves |
| [SetHandleType](#nodebpy.nodes.curve.SetHandleType) | Set the handle type for the control points of a Bézier curve |
| [SetSplineType](#nodebpy.nodes.curve.SetSplineType) | Change the type of curves |
| [Spiral](#nodebpy.nodes.curve.Spiral) | Generate a poly spline in a spiral shape |
| [Star](#nodebpy.nodes.curve.Star) | Generate a poly spline in a star pattern by connecting alternating points of two circles |
| [StringToCurves](#nodebpy.nodes.curve.StringToCurves) | Generate a paragraph of text with a specific font, using a curve instance to store each character |
| [SubdivideCurve](#nodebpy.nodes.curve.SubdivideCurve) | Dividing each curve segment into a specified number of pieces |
| [TrimCurve](#nodebpy.nodes.curve.TrimCurve) | Shorten curves by removing portions at the start or end |

### Arc { #nodebpy.nodes.curve.Arc }

```python
nodes.curve.Arc(
    resolution=16,
    radius=1.0,
    start_angle=0.0,
    sweep_angle=5.497786998748779,
    connect_center=False,
    invert_arc=False,
    mode='RADIUS',
    **kwargs,
)
```

Generate a poly spline arc

#### Attributes

| Name | Description |
| --- | --- |
| [i_connect_center](#nodebpy.nodes.curve.Arc.i_connect_center) | Input socket: Connect Center |
| [i_invert_arc](#nodebpy.nodes.curve.Arc.i_invert_arc) | Input socket: Invert Arc |
| [i_radius](#nodebpy.nodes.curve.Arc.i_radius) | Input socket: Radius |
| [i_resolution](#nodebpy.nodes.curve.Arc.i_resolution) | Input socket: Resolution |
| [i_start_angle](#nodebpy.nodes.curve.Arc.i_start_angle) | Input socket: Start Angle |
| [i_sweep_angle](#nodebpy.nodes.curve.Arc.i_sweep_angle) | Input socket: Sweep Angle |
| [o_curve](#nodebpy.nodes.curve.Arc.o_curve) | Output socket: Curve |

### BezierSegment { #nodebpy.nodes.curve.BezierSegment }

```python
nodes.curve.BezierSegment(
    resolution=16,
    start=[-1.0, 0.0, 0.0],
    start_handle=[-0.5, 0.5, 0.0],
    end_handle=[0.0, 0.0, 0.0],
    end=[1.0, 0.0, 0.0],
    mode='POSITION',
    **kwargs,
)
```

Generate a 2D Bézier spline from the given control points and handles

#### Attributes

| Name | Description |
| --- | --- |
| [i_end](#nodebpy.nodes.curve.BezierSegment.i_end) | Input socket: End |
| [i_end_handle](#nodebpy.nodes.curve.BezierSegment.i_end_handle) | Input socket: End Handle |
| [i_resolution](#nodebpy.nodes.curve.BezierSegment.i_resolution) | Input socket: Resolution |
| [i_start](#nodebpy.nodes.curve.BezierSegment.i_start) | Input socket: Start |
| [i_start_handle](#nodebpy.nodes.curve.BezierSegment.i_start_handle) | Input socket: Start Handle |
| [o_curve](#nodebpy.nodes.curve.BezierSegment.o_curve) | Output socket: Curve |

### CurveCircle { #nodebpy.nodes.curve.CurveCircle }

```python
nodes.curve.CurveCircle(resolution=32, radius=1.0, mode='RADIUS', **kwargs)
```

Generate a poly spline circle

#### Attributes

| Name | Description |
| --- | --- |
| [i_radius](#nodebpy.nodes.curve.CurveCircle.i_radius) | Input socket: Radius |
| [i_resolution](#nodebpy.nodes.curve.CurveCircle.i_resolution) | Input socket: Resolution |
| [o_curve](#nodebpy.nodes.curve.CurveCircle.o_curve) | Output socket: Curve |

### CurveHandlePositions { #nodebpy.nodes.curve.CurveHandlePositions }

```python
nodes.curve.CurveHandlePositions(relative=False, **kwargs)
```

Retrieve the position of each Bézier control point's handles

#### Attributes

| Name | Description |
| --- | --- |
| [i_relative](#nodebpy.nodes.curve.CurveHandlePositions.i_relative) | Input socket: Relative |
| [o_left](#nodebpy.nodes.curve.CurveHandlePositions.o_left) | Output socket: Left |
| [o_right](#nodebpy.nodes.curve.CurveHandlePositions.o_right) | Output socket: Right |

### CurveLength { #nodebpy.nodes.curve.CurveLength }

```python
nodes.curve.CurveLength(curve=None, **kwargs)
```

Retrieve the length of all splines added together

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.CurveLength.i_curve) | Input socket: Curve |
| [o_length](#nodebpy.nodes.curve.CurveLength.o_length) | Output socket: Length |

### CurveLine { #nodebpy.nodes.curve.CurveLine }

```python
nodes.curve.CurveLine(
    start=[0.0, 0.0, 0.0],
    end=[0.0, 0.0, 1.0],
    mode='POINTS',
    **kwargs,
)
```

Generate a poly spline line with two points

#### Attributes

| Name | Description |
| --- | --- |
| [i_end](#nodebpy.nodes.curve.CurveLine.i_end) | Input socket: End |
| [i_start](#nodebpy.nodes.curve.CurveLine.i_start) | Input socket: Start |
| [o_curve](#nodebpy.nodes.curve.CurveLine.o_curve) | Output socket: Curve |

### CurveOfPoint { #nodebpy.nodes.curve.CurveOfPoint }

```python
nodes.curve.CurveOfPoint(point_index=0, **kwargs)
```

Retrieve the curve a control point is part of

#### Attributes

| Name | Description |
| --- | --- |
| [i_point_index](#nodebpy.nodes.curve.CurveOfPoint.i_point_index) | Input socket: Point Index |
| [o_curve_index](#nodebpy.nodes.curve.CurveOfPoint.o_curve_index) | Output socket: Curve Index |
| [o_index_in_curve](#nodebpy.nodes.curve.CurveOfPoint.o_index_in_curve) | Output socket: Index in Curve |

### CurveTilt { #nodebpy.nodes.curve.CurveTilt }

```python
nodes.curve.CurveTilt(**kwargs)
```

Retrieve the angle at each control point used to twist the curve's normal around its tangent

#### Attributes

| Name | Description |
| --- | --- |
| [o_tilt](#nodebpy.nodes.curve.CurveTilt.o_tilt) | Output socket: Tilt |

### CurveToPoints { #nodebpy.nodes.curve.CurveToPoints }

```python
nodes.curve.CurveToPoints(curve=None, count=10, mode='COUNT', **kwargs)
```

Generate a point cloud by sampling positions along curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.curve.CurveToPoints.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.curve.CurveToPoints.i_curve) | Input socket: Curve |
| [o_normal](#nodebpy.nodes.curve.CurveToPoints.o_normal) | Output socket: Normal |
| [o_points](#nodebpy.nodes.curve.CurveToPoints.o_points) | Output socket: Points |
| [o_rotation](#nodebpy.nodes.curve.CurveToPoints.o_rotation) | Output socket: Rotation |
| [o_tangent](#nodebpy.nodes.curve.CurveToPoints.o_tangent) | Output socket: Tangent |

### CurvesToGreasePencil { #nodebpy.nodes.curve.CurvesToGreasePencil }

```python
nodes.curve.CurvesToGreasePencil(
    curves=None,
    selection=True,
    instances_as_layers=True,
    **kwargs,
)
```

Convert the curves in each top-level instance into Grease Pencil layer

#### Attributes

| Name | Description |
| --- | --- |
| [i_curves](#nodebpy.nodes.curve.CurvesToGreasePencil.i_curves) | Input socket: Curves |
| [i_instances_as_layers](#nodebpy.nodes.curve.CurvesToGreasePencil.i_instances_as_layers) | Input socket: Instances as Layers |
| [i_selection](#nodebpy.nodes.curve.CurvesToGreasePencil.i_selection) | Input socket: Selection |
| [o_grease_pencil](#nodebpy.nodes.curve.CurvesToGreasePencil.o_grease_pencil) | Output socket: Grease Pencil |

### DeformCurvesOnSurface { #nodebpy.nodes.curve.DeformCurvesOnSurface }

```python
nodes.curve.DeformCurvesOnSurface(curves=None, **kwargs)
```

Translate and rotate curves based on changes between the object's original and evaluated surface mesh

#### Attributes

| Name | Description |
| --- | --- |
| [i_curves](#nodebpy.nodes.curve.DeformCurvesOnSurface.i_curves) | Input socket: Curves |
| [o_curves](#nodebpy.nodes.curve.DeformCurvesOnSurface.o_curves) | Output socket: Curves |

### EdgePathsToCurves { #nodebpy.nodes.curve.EdgePathsToCurves }

```python
nodes.curve.EdgePathsToCurves(
    mesh=None,
    start_vertices=True,
    next_vertex_index=-1,
    **kwargs,
)
```

Output curves following paths across mesh edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_mesh](#nodebpy.nodes.curve.EdgePathsToCurves.i_mesh) | Input socket: Mesh |
| [i_next_vertex_index](#nodebpy.nodes.curve.EdgePathsToCurves.i_next_vertex_index) | Input socket: Next Vertex Index |
| [i_start_vertices](#nodebpy.nodes.curve.EdgePathsToCurves.i_start_vertices) | Input socket: Start Vertices |
| [o_curves](#nodebpy.nodes.curve.EdgePathsToCurves.o_curves) | Output socket: Curves |

### EndpointSelection { #nodebpy.nodes.curve.EndpointSelection }

```python
nodes.curve.EndpointSelection(start_size=1, end_size=1, **kwargs)
```

Provide a selection for an arbitrary number of endpoints in each spline

#### Attributes

| Name | Description |
| --- | --- |
| [i_end_size](#nodebpy.nodes.curve.EndpointSelection.i_end_size) | Input socket: End Size |
| [i_start_size](#nodebpy.nodes.curve.EndpointSelection.i_start_size) | Input socket: Start Size |
| [o_selection](#nodebpy.nodes.curve.EndpointSelection.o_selection) | Output socket: Selection |

### FillCurve { #nodebpy.nodes.curve.FillCurve }

```python
nodes.curve.FillCurve(curve=None, group_id=0, mode='Triangles', **kwargs)
```

Generate a mesh on the XY plane with faces on the inside of input curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.FillCurve.i_curve) | Input socket: Curve |
| [i_group_id](#nodebpy.nodes.curve.FillCurve.i_group_id) | Input socket: Group ID |
| [i_mode](#nodebpy.nodes.curve.FillCurve.i_mode) | Input socket: Mode |
| [o_mesh](#nodebpy.nodes.curve.FillCurve.o_mesh) | Output socket: Mesh |

### FilletCurve { #nodebpy.nodes.curve.FilletCurve }

```python
nodes.curve.FilletCurve(
    curve=None,
    radius=0.25,
    limit_radius=False,
    mode='Bézier',
    count=1,
    **kwargs,
)
```

Round corners by generating circular arcs on each control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.curve.FilletCurve.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.curve.FilletCurve.i_curve) | Input socket: Curve |
| [i_limit_radius](#nodebpy.nodes.curve.FilletCurve.i_limit_radius) | Input socket: Limit Radius |
| [i_mode](#nodebpy.nodes.curve.FilletCurve.i_mode) | Input socket: Mode |
| [i_radius](#nodebpy.nodes.curve.FilletCurve.i_radius) | Input socket: Radius |
| [o_curve](#nodebpy.nodes.curve.FilletCurve.o_curve) | Output socket: Curve |

### FloatCurve { #nodebpy.nodes.curve.FloatCurve }

```python
nodes.curve.FloatCurve(factor=1.0, value=1.0, **kwargs)
```

Map an input float to a curve and outputs a float value

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.curve.FloatCurve.i_factor) | Input socket: Factor |
| [i_value](#nodebpy.nodes.curve.FloatCurve.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.curve.FloatCurve.o_value) | Output socket: Value |

### GreasePencilToCurves { #nodebpy.nodes.curve.GreasePencilToCurves }

```python
nodes.curve.GreasePencilToCurves(
    grease_pencil=None,
    selection=True,
    layers_as_instances=True,
    **kwargs,
)
```

Convert Grease Pencil layers into curve instances

#### Attributes

| Name | Description |
| --- | --- |
| [i_grease_pencil](#nodebpy.nodes.curve.GreasePencilToCurves.i_grease_pencil) | Input socket: Grease Pencil |
| [i_layers_as_instances](#nodebpy.nodes.curve.GreasePencilToCurves.i_layers_as_instances) | Input socket: Layers as Instances |
| [i_selection](#nodebpy.nodes.curve.GreasePencilToCurves.i_selection) | Input socket: Selection |
| [o_curves](#nodebpy.nodes.curve.GreasePencilToCurves.o_curves) | Output socket: Curves |

### HandleTypeSelection { #nodebpy.nodes.curve.HandleTypeSelection }

```python
nodes.curve.HandleTypeSelection(
    handle_type='AUTO',
    mode="{'LEFT', 'RIGHT'}",
    **kwargs,
)
```

Provide a selection based on the handle types of Bézier control points

#### Attributes

| Name | Description |
| --- | --- |
| [o_selection](#nodebpy.nodes.curve.HandleTypeSelection.o_selection) | Output socket: Selection |

### InterpolateCurves { #nodebpy.nodes.curve.InterpolateCurves }

```python
nodes.curve.InterpolateCurves(
    guide_curves=None,
    guide_up=[0.0, 0.0, 0.0],
    guide_group_id=0,
    points=None,
    point_up=[0.0, 0.0, 0.0],
    point_group_id=0,
    max_neighbors=4,
    **kwargs,
)
```

Generate new curves on points by interpolating between existing curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_guide_curves](#nodebpy.nodes.curve.InterpolateCurves.i_guide_curves) | Input socket: Guide Curves |
| [i_guide_group_id](#nodebpy.nodes.curve.InterpolateCurves.i_guide_group_id) | Input socket: Guide Group ID |
| [i_guide_up](#nodebpy.nodes.curve.InterpolateCurves.i_guide_up) | Input socket: Guide Up |
| [i_max_neighbors](#nodebpy.nodes.curve.InterpolateCurves.i_max_neighbors) | Input socket: Max Neighbors |
| [i_point_group_id](#nodebpy.nodes.curve.InterpolateCurves.i_point_group_id) | Input socket: Point Group ID |
| [i_point_up](#nodebpy.nodes.curve.InterpolateCurves.i_point_up) | Input socket: Point Up |
| [i_points](#nodebpy.nodes.curve.InterpolateCurves.i_points) | Input socket: Points |
| [o_closest_index](#nodebpy.nodes.curve.InterpolateCurves.o_closest_index) | Output socket: Closest Index |
| [o_closest_weight](#nodebpy.nodes.curve.InterpolateCurves.o_closest_weight) | Output socket: Closest Weight |
| [o_curves](#nodebpy.nodes.curve.InterpolateCurves.o_curves) | Output socket: Curves |

### OffsetPointInCurve { #nodebpy.nodes.curve.OffsetPointInCurve }

```python
nodes.curve.OffsetPointInCurve(point_index=0, offset=0, **kwargs)
```

Offset a control point index within its curve

#### Attributes

| Name | Description |
| --- | --- |
| [i_offset](#nodebpy.nodes.curve.OffsetPointInCurve.i_offset) | Input socket: Offset |
| [i_point_index](#nodebpy.nodes.curve.OffsetPointInCurve.i_point_index) | Input socket: Point Index |
| [o_is_valid_offset](#nodebpy.nodes.curve.OffsetPointInCurve.o_is_valid_offset) | Output socket: Is Valid Offset |
| [o_point_index](#nodebpy.nodes.curve.OffsetPointInCurve.o_point_index) | Output socket: Point Index |

### PointsOfCurve { #nodebpy.nodes.curve.PointsOfCurve }

```python
nodes.curve.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0, **kwargs)
```

Retrieve a point index within a curve

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve_index](#nodebpy.nodes.curve.PointsOfCurve.i_curve_index) | Input socket: Curve Index |
| [i_sort_index](#nodebpy.nodes.curve.PointsOfCurve.i_sort_index) | Input socket: Sort Index |
| [i_weights](#nodebpy.nodes.curve.PointsOfCurve.i_weights) | Input socket: Weights |
| [o_point_index](#nodebpy.nodes.curve.PointsOfCurve.o_point_index) | Output socket: Point Index |
| [o_total](#nodebpy.nodes.curve.PointsOfCurve.o_total) | Output socket: Total |

### PointsToCurves { #nodebpy.nodes.curve.PointsToCurves }

```python
nodes.curve.PointsToCurves(points=None, curve_group_id=0, weight=0.0, **kwargs)
```

Split all points to curve by its group ID and reorder by weight

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve_group_id](#nodebpy.nodes.curve.PointsToCurves.i_curve_group_id) | Input socket: Curve Group ID |
| [i_points](#nodebpy.nodes.curve.PointsToCurves.i_points) | Input socket: Points |
| [i_weight](#nodebpy.nodes.curve.PointsToCurves.i_weight) | Input socket: Weight |
| [o_curves](#nodebpy.nodes.curve.PointsToCurves.o_curves) | Output socket: Curves |

### QuadraticBezier { #nodebpy.nodes.curve.QuadraticBezier }

```python
nodes.curve.QuadraticBezier(
    resolution=16,
    start=[-1.0, 0.0, 0.0],
    middle=[0.0, 2.0, 0.0],
    end=[1.0, 0.0, 0.0],
    **kwargs,
)
```

Generate a poly spline in a parabola shape with control points positions

#### Attributes

| Name | Description |
| --- | --- |
| [i_end](#nodebpy.nodes.curve.QuadraticBezier.i_end) | Input socket: End |
| [i_middle](#nodebpy.nodes.curve.QuadraticBezier.i_middle) | Input socket: Middle |
| [i_resolution](#nodebpy.nodes.curve.QuadraticBezier.i_resolution) | Input socket: Resolution |
| [i_start](#nodebpy.nodes.curve.QuadraticBezier.i_start) | Input socket: Start |
| [o_curve](#nodebpy.nodes.curve.QuadraticBezier.o_curve) | Output socket: Curve |

### Quadrilateral { #nodebpy.nodes.curve.Quadrilateral }

```python
nodes.curve.Quadrilateral(width=2.0, height=2.0, mode='RECTANGLE', **kwargs)
```

Generate a polygon with four points

#### Attributes

| Name | Description |
| --- | --- |
| [i_height](#nodebpy.nodes.curve.Quadrilateral.i_height) | Input socket: Height |
| [i_width](#nodebpy.nodes.curve.Quadrilateral.i_width) | Input socket: Width |
| [o_curve](#nodebpy.nodes.curve.Quadrilateral.o_curve) | Output socket: Curve |

### ResampleCurve { #nodebpy.nodes.curve.ResampleCurve }

```python
nodes.curve.ResampleCurve(
    curve=None,
    selection=True,
    mode='Count',
    count=10,
    length=0.10000000149011612,
    keep_last_segment=False,
    **kwargs,
)
```

Generate a poly spline for each input spline

#### Attributes

| Name | Description |
| --- | --- |
| [i_count](#nodebpy.nodes.curve.ResampleCurve.i_count) | Input socket: Count |
| [i_curve](#nodebpy.nodes.curve.ResampleCurve.i_curve) | Input socket: Curve |
| [i_length](#nodebpy.nodes.curve.ResampleCurve.i_length) | Input socket: Length |
| [i_mode](#nodebpy.nodes.curve.ResampleCurve.i_mode) | Input socket: Mode |
| [i_selection](#nodebpy.nodes.curve.ResampleCurve.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.ResampleCurve.o_curve) | Output socket: Curve |

### ReverseCurve { #nodebpy.nodes.curve.ReverseCurve }

```python
nodes.curve.ReverseCurve(curve=None, selection=True, **kwargs)
```

Change the direction of curves by swapping their start and end data

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.ReverseCurve.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.curve.ReverseCurve.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.ReverseCurve.o_curve) | Output socket: Curve |

### RgbCurves { #nodebpy.nodes.curve.RgbCurves }

```python
nodes.curve.RgbCurves(fac=1.0, color=[1.0, 1.0, 1.0, 1.0], **kwargs)
```

Apply color corrections for each color channel

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.curve.RgbCurves.i_color) | Input socket: Color |
| [i_factor](#nodebpy.nodes.curve.RgbCurves.i_factor) | Input socket: Factor |
| [o_color](#nodebpy.nodes.curve.RgbCurves.o_color) | Output socket: Color |

### SampleCurve { #nodebpy.nodes.curve.SampleCurve }

```python
nodes.curve.SampleCurve(
    curves=None,
    value=0.0,
    factor=0.0,
    curve_index=0,
    mode='FACTOR',
    use_all_curves=False,
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve data from a point on a curve at a certain distance from its start

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve_index](#nodebpy.nodes.curve.SampleCurve.i_curve_index) | Input socket: Curve Index |
| [i_curves](#nodebpy.nodes.curve.SampleCurve.i_curves) | Input socket: Curves |
| [i_factor](#nodebpy.nodes.curve.SampleCurve.i_factor) | Input socket: Factor |
| [i_value](#nodebpy.nodes.curve.SampleCurve.i_value) | Input socket: Value |
| [o_normal](#nodebpy.nodes.curve.SampleCurve.o_normal) | Output socket: Normal |
| [o_position](#nodebpy.nodes.curve.SampleCurve.o_position) | Output socket: Position |
| [o_tangent](#nodebpy.nodes.curve.SampleCurve.o_tangent) | Output socket: Tangent |
| [o_value](#nodebpy.nodes.curve.SampleCurve.o_value) | Output socket: Value |

### SetCurveNormal { #nodebpy.nodes.curve.SetCurveNormal }

```python
nodes.curve.SetCurveNormal(
    curve=None,
    selection=True,
    mode='Minimum Twist',
    normal=[0.0, 0.0, 1.0],
    **kwargs,
)
```

Set the evaluation mode for curve normals

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetCurveNormal.i_curve) | Input socket: Curve |
| [i_mode](#nodebpy.nodes.curve.SetCurveNormal.i_mode) | Input socket: Mode |
| [i_normal](#nodebpy.nodes.curve.SetCurveNormal.i_normal) | Input socket: Normal |
| [i_selection](#nodebpy.nodes.curve.SetCurveNormal.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.SetCurveNormal.o_curve) | Output socket: Curve |

### SetCurveRadius { #nodebpy.nodes.curve.SetCurveRadius }

```python
nodes.curve.SetCurveRadius(
    curve=None,
    selection=True,
    radius=0.004999999888241291,
    **kwargs,
)
```

Set the radius of the curve at each control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetCurveRadius.i_curve) | Input socket: Curve |
| [i_radius](#nodebpy.nodes.curve.SetCurveRadius.i_radius) | Input socket: Radius |
| [i_selection](#nodebpy.nodes.curve.SetCurveRadius.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.SetCurveRadius.o_curve) | Output socket: Curve |

### SetCurveTilt { #nodebpy.nodes.curve.SetCurveTilt }

```python
nodes.curve.SetCurveTilt(curve=None, selection=True, tilt=0.0, **kwargs)
```

Set the tilt angle at each curve control point

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetCurveTilt.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.curve.SetCurveTilt.i_selection) | Input socket: Selection |
| [i_tilt](#nodebpy.nodes.curve.SetCurveTilt.i_tilt) | Input socket: Tilt |
| [o_curve](#nodebpy.nodes.curve.SetCurveTilt.o_curve) | Output socket: Curve |

### SetHandlePositions { #nodebpy.nodes.curve.SetHandlePositions }

```python
nodes.curve.SetHandlePositions(
    curve=None,
    selection=True,
    position=[0.0, 0.0, 0.0],
    offset=[0.0, 0.0, 0.0],
    mode='LEFT',
    **kwargs,
)
```

Set the positions for the handles of Bézier curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetHandlePositions.i_curve) | Input socket: Curve |
| [i_offset](#nodebpy.nodes.curve.SetHandlePositions.i_offset) | Input socket: Offset |
| [i_position](#nodebpy.nodes.curve.SetHandlePositions.i_position) | Input socket: Position |
| [i_selection](#nodebpy.nodes.curve.SetHandlePositions.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.SetHandlePositions.o_curve) | Output socket: Curve |

### SetHandleType { #nodebpy.nodes.curve.SetHandleType }

```python
nodes.curve.SetHandleType(
    curve=None,
    selection=True,
    handle_type='AUTO',
    mode="{'LEFT', 'RIGHT'}",
    **kwargs,
)
```

Set the handle type for the control points of a Bézier curve

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetHandleType.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.curve.SetHandleType.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.SetHandleType.o_curve) | Output socket: Curve |

### SetSplineType { #nodebpy.nodes.curve.SetSplineType }

```python
nodes.curve.SetSplineType(
    curve=None,
    selection=True,
    spline_type='POLY',
    **kwargs,
)
```

Change the type of curves

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SetSplineType.i_curve) | Input socket: Curve |
| [i_selection](#nodebpy.nodes.curve.SetSplineType.i_selection) | Input socket: Selection |
| [o_curve](#nodebpy.nodes.curve.SetSplineType.o_curve) | Output socket: Curve |

### Spiral { #nodebpy.nodes.curve.Spiral }

```python
nodes.curve.Spiral(
    resolution=32,
    rotations=2.0,
    start_radius=1.0,
    end_radius=2.0,
    height=2.0,
    reverse=False,
    **kwargs,
)
```

Generate a poly spline in a spiral shape

#### Attributes

| Name | Description |
| --- | --- |
| [i_end_radius](#nodebpy.nodes.curve.Spiral.i_end_radius) | Input socket: End Radius |
| [i_height](#nodebpy.nodes.curve.Spiral.i_height) | Input socket: Height |
| [i_resolution](#nodebpy.nodes.curve.Spiral.i_resolution) | Input socket: Resolution |
| [i_reverse](#nodebpy.nodes.curve.Spiral.i_reverse) | Input socket: Reverse |
| [i_rotations](#nodebpy.nodes.curve.Spiral.i_rotations) | Input socket: Rotations |
| [i_start_radius](#nodebpy.nodes.curve.Spiral.i_start_radius) | Input socket: Start Radius |
| [o_curve](#nodebpy.nodes.curve.Spiral.o_curve) | Output socket: Curve |

### Star { #nodebpy.nodes.curve.Star }

```python
nodes.curve.Star(
    points=8,
    inner_radius=1.0,
    outer_radius=2.0,
    twist=0.0,
    **kwargs,
)
```

Generate a poly spline in a star pattern by connecting alternating points of two circles

#### Attributes

| Name | Description |
| --- | --- |
| [i_inner_radius](#nodebpy.nodes.curve.Star.i_inner_radius) | Input socket: Inner Radius |
| [i_outer_radius](#nodebpy.nodes.curve.Star.i_outer_radius) | Input socket: Outer Radius |
| [i_points](#nodebpy.nodes.curve.Star.i_points) | Input socket: Points |
| [i_twist](#nodebpy.nodes.curve.Star.i_twist) | Input socket: Twist |
| [o_curve](#nodebpy.nodes.curve.Star.o_curve) | Output socket: Curve |
| [o_outer_points](#nodebpy.nodes.curve.Star.o_outer_points) | Output socket: Outer Points |

### StringToCurves { #nodebpy.nodes.curve.StringToCurves }

```python
nodes.curve.StringToCurves(
    string='',
    size=1.0,
    character_spacing=1.0,
    word_spacing=1.0,
    line_spacing=1.0,
    text_box_width=0.0,
    overflow='OVERFLOW',
    align_x='LEFT',
    align_y='TOP_BASELINE',
    pivot_mode='BOTTOM_LEFT',
    **kwargs,
)
```

Generate a paragraph of text with a specific font, using a curve instance to store each character

#### Attributes

| Name | Description |
| --- | --- |
| [i_character_spacing](#nodebpy.nodes.curve.StringToCurves.i_character_spacing) | Input socket: Character Spacing |
| [i_line_spacing](#nodebpy.nodes.curve.StringToCurves.i_line_spacing) | Input socket: Line Spacing |
| [i_size](#nodebpy.nodes.curve.StringToCurves.i_size) | Input socket: Size |
| [i_string](#nodebpy.nodes.curve.StringToCurves.i_string) | Input socket: String |
| [i_text_box_width](#nodebpy.nodes.curve.StringToCurves.i_text_box_width) | Input socket: Text Box Width |
| [i_word_spacing](#nodebpy.nodes.curve.StringToCurves.i_word_spacing) | Input socket: Word Spacing |
| [o_curve_instances](#nodebpy.nodes.curve.StringToCurves.o_curve_instances) | Output socket: Curve Instances |
| [o_line](#nodebpy.nodes.curve.StringToCurves.o_line) | Output socket: Line |
| [o_pivot_point](#nodebpy.nodes.curve.StringToCurves.o_pivot_point) | Output socket: Pivot Point |

### SubdivideCurve { #nodebpy.nodes.curve.SubdivideCurve }

```python
nodes.curve.SubdivideCurve(curve=None, cuts=1, **kwargs)
```

Dividing each curve segment into a specified number of pieces

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.SubdivideCurve.i_curve) | Input socket: Curve |
| [i_cuts](#nodebpy.nodes.curve.SubdivideCurve.i_cuts) | Input socket: Cuts |
| [o_curve](#nodebpy.nodes.curve.SubdivideCurve.o_curve) | Output socket: Curve |

### TrimCurve { #nodebpy.nodes.curve.TrimCurve }

```python
nodes.curve.TrimCurve(
    curve=None,
    selection=True,
    start=0.0,
    end=1.0,
    mode='FACTOR',
    **kwargs,
)
```

Shorten curves by removing portions at the start or end

#### Attributes

| Name | Description |
| --- | --- |
| [i_curve](#nodebpy.nodes.curve.TrimCurve.i_curve) | Input socket: Curve |
| [i_end](#nodebpy.nodes.curve.TrimCurve.i_end) | Input socket: End |
| [i_selection](#nodebpy.nodes.curve.TrimCurve.i_selection) | Input socket: Selection |
| [i_start](#nodebpy.nodes.curve.TrimCurve.i_start) | Input socket: Start |
| [o_curve](#nodebpy.nodes.curve.TrimCurve.o_curve) | Output socket: Curve |