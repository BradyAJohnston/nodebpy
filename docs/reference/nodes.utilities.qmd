# nodes.utilities { #nodebpy.nodes.utilities }

`nodes.utilities`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [Clamp](#nodebpy.nodes.utilities.Clamp) | Clamp a value between a minimum and a maximum |
| [Gamma](#nodebpy.nodes.utilities.Gamma) | Apply a gamma correction |
| [IntegerMath](#nodebpy.nodes.utilities.IntegerMath) | Perform various math operations on the given integer inputs |
| [InvertMatrix](#nodebpy.nodes.utilities.InvertMatrix) | Compute the inverse of the given matrix, if one exists |
| [InvertRotation](#nodebpy.nodes.utilities.InvertRotation) | Compute the inverse of the given rotation |
| [MapRange](#nodebpy.nodes.utilities.MapRange) | Remap a value from a range to a target range |
| [MatchString](#nodebpy.nodes.utilities.MatchString) | Check if a given string exists within another string |
| [MatrixDeterminant](#nodebpy.nodes.utilities.MatrixDeterminant) | Compute the determinant of the given matrix |
| [MultiplyMatrices](#nodebpy.nodes.utilities.MultiplyMatrices) | Perform a matrix multiplication on two input matrices |
| [ProjectPoint](#nodebpy.nodes.utilities.ProjectPoint) | Project a point using a matrix, using location, rotation, scale, and perspective divide |
| [QuaternionToRotation](#nodebpy.nodes.utilities.QuaternionToRotation) | Build a rotation from quaternion components |
| [ReplaceString](#nodebpy.nodes.utilities.ReplaceString) | Replace a given string segment with another |
| [RotateEuler](#nodebpy.nodes.utilities.RotateEuler) | Apply a secondary Euler rotation to a given Euler rotation |
| [RotateRotation](#nodebpy.nodes.utilities.RotateRotation) | Apply a secondary rotation to a given rotation value |
| [RotateVector](#nodebpy.nodes.utilities.RotateVector) | Apply a rotation to a given vector |
| [RotationToAxisAngle](#nodebpy.nodes.utilities.RotationToAxisAngle) | Convert a rotation to axis angle components |
| [RotationToEuler](#nodebpy.nodes.utilities.RotationToEuler) | Convert a standard rotation value to an Euler rotation |
| [RotationToQuaternion](#nodebpy.nodes.utilities.RotationToQuaternion) | Retrieve the quaternion components representing a rotation |
| [SeparateColor](#nodebpy.nodes.utilities.SeparateColor) | Split a color into separate channels, based on a particular color model |
| [SeparateMatrix](#nodebpy.nodes.utilities.SeparateMatrix) | Split a 4x4 matrix into its individual values |
| [SeparateTransform](#nodebpy.nodes.utilities.SeparateTransform) | Split a transformation matrix into a translation vector, a rotation, and a scale vector |
| [SliceString](#nodebpy.nodes.utilities.SliceString) | Extract a string segment from a larger string |
| [StringLength](#nodebpy.nodes.utilities.StringLength) | Output the number of characters in the given string |
| [StringToValue](#nodebpy.nodes.utilities.StringToValue) | Derive a numeric value from a given string representation |
| [TransformDirection](#nodebpy.nodes.utilities.TransformDirection) | Apply a transformation matrix (excluding translation) to the given vector |
| [TransformPoint](#nodebpy.nodes.utilities.TransformPoint) | Apply a transformation matrix to the given vector |
| [TransposeMatrix](#nodebpy.nodes.utilities.TransposeMatrix) | Flip a matrix over its diagonal, turning columns into rows and vice-versa |
| [ValueToString](#nodebpy.nodes.utilities.ValueToString) | Generate a string representation of the given input value |

### Clamp { #nodebpy.nodes.utilities.Clamp }

```python
nodes.utilities.Clamp(
    value=1.0,
    min=0.0,
    max=1.0,
    clamp_type='MINMAX',
    **kwargs,
)
```

Clamp a value between a minimum and a maximum

#### Attributes

| Name | Description |
| --- | --- |
| [i_max](#nodebpy.nodes.utilities.Clamp.i_max) | Input socket: Max |
| [i_min](#nodebpy.nodes.utilities.Clamp.i_min) | Input socket: Min |
| [i_value](#nodebpy.nodes.utilities.Clamp.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.utilities.Clamp.o_result) | Output socket: Result |

### Gamma { #nodebpy.nodes.utilities.Gamma }

```python
nodes.utilities.Gamma(color=[1.0, 1.0, 1.0, 1.0], gamma=1.0, **kwargs)
```

Apply a gamma correction

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.utilities.Gamma.i_color) | Input socket: Color |
| [i_gamma](#nodebpy.nodes.utilities.Gamma.i_gamma) | Input socket: Gamma |
| [o_color](#nodebpy.nodes.utilities.Gamma.o_color) | Output socket: Color |

### IntegerMath { #nodebpy.nodes.utilities.IntegerMath }

```python
nodes.utilities.IntegerMath(value=0, value_001=0, operation='ADD', **kwargs)
```

Perform various math operations on the given integer inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.utilities.IntegerMath.i_value) | Input socket: Value |
| [i_value_001](#nodebpy.nodes.utilities.IntegerMath.i_value_001) | Input socket: Value |
| [o_value](#nodebpy.nodes.utilities.IntegerMath.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.utilities.IntegerMath.absolute) | Create Integer Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.utilities.IntegerMath.add) | Create Integer Math with operation 'Add'. |
| [divide](#nodebpy.nodes.utilities.IntegerMath.divide) | Create Integer Math with operation 'Divide'. |
| [divideceil](#nodebpy.nodes.utilities.IntegerMath.divideceil) | Create Integer Math with operation 'Divide Ceiling'. |
| [dividefloor](#nodebpy.nodes.utilities.IntegerMath.dividefloor) | Create Integer Math with operation 'Divide Floor'. |
| [divideround](#nodebpy.nodes.utilities.IntegerMath.divideround) | Create Integer Math with operation 'Divide Round'. |
| [flooredmodulo](#nodebpy.nodes.utilities.IntegerMath.flooredmodulo) | Create Integer Math with operation 'Floored Modulo'. |
| [gcd](#nodebpy.nodes.utilities.IntegerMath.gcd) | Create Integer Math with operation 'Greatest Common Divisor'. |
| [lcm](#nodebpy.nodes.utilities.IntegerMath.lcm) | Create Integer Math with operation 'Least Common Multiple'. |
| [maximum](#nodebpy.nodes.utilities.IntegerMath.maximum) | Create Integer Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.utilities.IntegerMath.minimum) | Create Integer Math with operation 'Minimum'. |
| [modulo](#nodebpy.nodes.utilities.IntegerMath.modulo) | Create Integer Math with operation 'Modulo'. |
| [multiply](#nodebpy.nodes.utilities.IntegerMath.multiply) | Create Integer Math with operation 'Multiply'. |
| [multiplyadd](#nodebpy.nodes.utilities.IntegerMath.multiplyadd) | Create Integer Math with operation 'Multiply Add'. |
| [negate](#nodebpy.nodes.utilities.IntegerMath.negate) | Create Integer Math with operation 'Negate'. |
| [power](#nodebpy.nodes.utilities.IntegerMath.power) | Create Integer Math with operation 'Power'. |
| [sign](#nodebpy.nodes.utilities.IntegerMath.sign) | Create Integer Math with operation 'Sign'. |
| [subtract](#nodebpy.nodes.utilities.IntegerMath.subtract) | Create Integer Math with operation 'Subtract'. |

##### absolute { #nodebpy.nodes.utilities.IntegerMath.absolute }

```python
nodes.utilities.IntegerMath.absolute(value=0, value_001=0)
```

Create Integer Math with operation 'Absolute'.

##### add { #nodebpy.nodes.utilities.IntegerMath.add }

```python
nodes.utilities.IntegerMath.add(value=0, value_001=0)
```

Create Integer Math with operation 'Add'.

##### divide { #nodebpy.nodes.utilities.IntegerMath.divide }

```python
nodes.utilities.IntegerMath.divide(value=0, value_001=0)
```

Create Integer Math with operation 'Divide'.

##### divideceil { #nodebpy.nodes.utilities.IntegerMath.divideceil }

```python
nodes.utilities.IntegerMath.divideceil(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Ceiling'.

##### dividefloor { #nodebpy.nodes.utilities.IntegerMath.dividefloor }

```python
nodes.utilities.IntegerMath.dividefloor(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Floor'.

##### divideround { #nodebpy.nodes.utilities.IntegerMath.divideround }

```python
nodes.utilities.IntegerMath.divideround(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Round'.

##### flooredmodulo { #nodebpy.nodes.utilities.IntegerMath.flooredmodulo }

```python
nodes.utilities.IntegerMath.flooredmodulo(value=0, value_001=0)
```

Create Integer Math with operation 'Floored Modulo'.

##### gcd { #nodebpy.nodes.utilities.IntegerMath.gcd }

```python
nodes.utilities.IntegerMath.gcd(value=0, value_001=0)
```

Create Integer Math with operation 'Greatest Common Divisor'.

##### lcm { #nodebpy.nodes.utilities.IntegerMath.lcm }

```python
nodes.utilities.IntegerMath.lcm(value=0, value_001=0)
```

Create Integer Math with operation 'Least Common Multiple'.

##### maximum { #nodebpy.nodes.utilities.IntegerMath.maximum }

```python
nodes.utilities.IntegerMath.maximum(value=0, value_001=0)
```

Create Integer Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.utilities.IntegerMath.minimum }

```python
nodes.utilities.IntegerMath.minimum(value=0, value_001=0)
```

Create Integer Math with operation 'Minimum'.

##### modulo { #nodebpy.nodes.utilities.IntegerMath.modulo }

```python
nodes.utilities.IntegerMath.modulo(value=0, value_001=0)
```

Create Integer Math with operation 'Modulo'.

##### multiply { #nodebpy.nodes.utilities.IntegerMath.multiply }

```python
nodes.utilities.IntegerMath.multiply(value=0, value_001=0)
```

Create Integer Math with operation 'Multiply'.

##### multiplyadd { #nodebpy.nodes.utilities.IntegerMath.multiplyadd }

```python
nodes.utilities.IntegerMath.multiplyadd(value=0, value_001=0)
```

Create Integer Math with operation 'Multiply Add'.

##### negate { #nodebpy.nodes.utilities.IntegerMath.negate }

```python
nodes.utilities.IntegerMath.negate(value=0, value_001=0)
```

Create Integer Math with operation 'Negate'.

##### power { #nodebpy.nodes.utilities.IntegerMath.power }

```python
nodes.utilities.IntegerMath.power(value=0, value_001=0)
```

Create Integer Math with operation 'Power'.

##### sign { #nodebpy.nodes.utilities.IntegerMath.sign }

```python
nodes.utilities.IntegerMath.sign(value=0, value_001=0)
```

Create Integer Math with operation 'Sign'.

##### subtract { #nodebpy.nodes.utilities.IntegerMath.subtract }

```python
nodes.utilities.IntegerMath.subtract(value=0, value_001=0)
```

Create Integer Math with operation 'Subtract'.

### InvertMatrix { #nodebpy.nodes.utilities.InvertMatrix }

```python
nodes.utilities.InvertMatrix(matrix=None, **kwargs)
```

Compute the inverse of the given matrix, if one exists

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.InvertMatrix.i_matrix) | Input socket: Matrix |
| [o_invertible](#nodebpy.nodes.utilities.InvertMatrix.o_invertible) | Output socket: Invertible |
| [o_matrix](#nodebpy.nodes.utilities.InvertMatrix.o_matrix) | Output socket: Matrix |

### InvertRotation { #nodebpy.nodes.utilities.InvertRotation }

```python
nodes.utilities.InvertRotation(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Compute the inverse of the given rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.InvertRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.InvertRotation.o_rotation) | Output socket: Rotation |

### MapRange { #nodebpy.nodes.utilities.MapRange }

```python
nodes.utilities.MapRange(
    value=1.0,
    from_min=0.0,
    from_max=1.0,
    to_min=0.0,
    to_max=1.0,
    clamp=False,
    interpolation_type='LINEAR',
    data_type='FLOAT',
    **kwargs,
)
```

Remap a value from a range to a target range

#### Attributes

| Name | Description |
| --- | --- |
| [i_from_max](#nodebpy.nodes.utilities.MapRange.i_from_max) | Input socket: From Max |
| [i_from_min](#nodebpy.nodes.utilities.MapRange.i_from_min) | Input socket: From Min |
| [i_to_max](#nodebpy.nodes.utilities.MapRange.i_to_max) | Input socket: To Max |
| [i_to_min](#nodebpy.nodes.utilities.MapRange.i_to_min) | Input socket: To Min |
| [i_value](#nodebpy.nodes.utilities.MapRange.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.utilities.MapRange.o_result) | Output socket: Result |

### MatchString { #nodebpy.nodes.utilities.MatchString }

```python
nodes.utilities.MatchString(
    string='',
    operation='Starts With',
    key='',
    **kwargs,
)
```

Check if a given string exists within another string

#### Attributes

| Name | Description |
| --- | --- |
| [i_key](#nodebpy.nodes.utilities.MatchString.i_key) | Input socket: Key |
| [i_operation](#nodebpy.nodes.utilities.MatchString.i_operation) | Input socket: Operation |
| [i_string](#nodebpy.nodes.utilities.MatchString.i_string) | Input socket: String |
| [o_result](#nodebpy.nodes.utilities.MatchString.o_result) | Output socket: Result |

### MatrixDeterminant { #nodebpy.nodes.utilities.MatrixDeterminant }

```python
nodes.utilities.MatrixDeterminant(matrix=None, **kwargs)
```

Compute the determinant of the given matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.MatrixDeterminant.i_matrix) | Input socket: Matrix |
| [o_determinant](#nodebpy.nodes.utilities.MatrixDeterminant.o_determinant) | Output socket: Determinant |

### MultiplyMatrices { #nodebpy.nodes.utilities.MultiplyMatrices }

```python
nodes.utilities.MultiplyMatrices(matrix=None, matrix_001=None, **kwargs)
```

Perform a matrix multiplication on two input matrices

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.MultiplyMatrices.i_matrix) | Input socket: Matrix |
| [i_matrix_001](#nodebpy.nodes.utilities.MultiplyMatrices.i_matrix_001) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.utilities.MultiplyMatrices.o_matrix) | Output socket: Matrix |

### ProjectPoint { #nodebpy.nodes.utilities.ProjectPoint }

```python
nodes.utilities.ProjectPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)
```

Project a point using a matrix, using location, rotation, scale, and perspective divide

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.ProjectPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.utilities.ProjectPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.ProjectPoint.o_vector) | Output socket: Vector |

### QuaternionToRotation { #nodebpy.nodes.utilities.QuaternionToRotation }

```python
nodes.utilities.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0, **kwargs)
```

Build a rotation from quaternion components

#### Attributes

| Name | Description |
| --- | --- |
| [i_w](#nodebpy.nodes.utilities.QuaternionToRotation.i_w) | Input socket: W |
| [i_x](#nodebpy.nodes.utilities.QuaternionToRotation.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.utilities.QuaternionToRotation.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.utilities.QuaternionToRotation.i_z) | Input socket: Z |
| [o_rotation](#nodebpy.nodes.utilities.QuaternionToRotation.o_rotation) | Output socket: Rotation |

### ReplaceString { #nodebpy.nodes.utilities.ReplaceString }

```python
nodes.utilities.ReplaceString(string='', find='', replace='', **kwargs)
```

Replace a given string segment with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_find](#nodebpy.nodes.utilities.ReplaceString.i_find) | Input socket: Find |
| [i_replace](#nodebpy.nodes.utilities.ReplaceString.i_replace) | Input socket: Replace |
| [i_string](#nodebpy.nodes.utilities.ReplaceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.utilities.ReplaceString.o_string) | Output socket: String |

### RotateEuler { #nodebpy.nodes.utilities.RotateEuler }

```python
nodes.utilities.RotateEuler(
    rotation=[0.0, 0.0, 0.0],
    rotate_by=[0.0, 0.0, 0.0],
    rotation_type='EULER',
    space='OBJECT',
    **kwargs,
)
```

Apply a secondary Euler rotation to a given Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.utilities.RotateEuler.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.utilities.RotateEuler.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.RotateEuler.o_rotation) | Output socket: Rotation |

### RotateRotation { #nodebpy.nodes.utilities.RotateRotation }

```python
nodes.utilities.RotateRotation(
    rotation=[0.0, 0.0, 0.0],
    rotate_by=[0.0, 0.0, 0.0],
    rotation_space='GLOBAL',
    **kwargs,
)
```

Apply a secondary rotation to a given rotation value

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.utilities.RotateRotation.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.utilities.RotateRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.RotateRotation.o_rotation) | Output socket: Rotation |

### RotateVector { #nodebpy.nodes.utilities.RotateVector }

```python
nodes.utilities.RotateVector(
    vector=[0.0, 0.0, 0.0],
    rotation=[0.0, 0.0, 0.0],
    **kwargs,
)
```

Apply a rotation to a given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotateVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.utilities.RotateVector.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.RotateVector.o_vector) | Output socket: Vector |

### RotationToAxisAngle { #nodebpy.nodes.utilities.RotationToAxisAngle }

```python
nodes.utilities.RotationToAxisAngle(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Convert a rotation to axis angle components

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToAxisAngle.i_rotation) | Input socket: Rotation |
| [o_angle](#nodebpy.nodes.utilities.RotationToAxisAngle.o_angle) | Output socket: Angle |
| [o_axis](#nodebpy.nodes.utilities.RotationToAxisAngle.o_axis) | Output socket: Axis |

### RotationToEuler { #nodebpy.nodes.utilities.RotationToEuler }

```python
nodes.utilities.RotationToEuler(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Convert a standard rotation value to an Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToEuler.i_rotation) | Input socket: Rotation |
| [o_euler](#nodebpy.nodes.utilities.RotationToEuler.o_euler) | Output socket: Euler |

### RotationToQuaternion { #nodebpy.nodes.utilities.RotationToQuaternion }

```python
nodes.utilities.RotationToQuaternion(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Retrieve the quaternion components representing a rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToQuaternion.i_rotation) | Input socket: Rotation |
| [o_w](#nodebpy.nodes.utilities.RotationToQuaternion.o_w) | Output socket: W |
| [o_x](#nodebpy.nodes.utilities.RotationToQuaternion.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.utilities.RotationToQuaternion.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.utilities.RotationToQuaternion.o_z) | Output socket: Z |

### SeparateColor { #nodebpy.nodes.utilities.SeparateColor }

```python
nodes.utilities.SeparateColor(color=[1.0, 1.0, 1.0, 1.0], mode='RGB', **kwargs)
```

Split a color into separate channels, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.utilities.SeparateColor.i_color) | Input socket: Color |
| [o_alpha](#nodebpy.nodes.utilities.SeparateColor.o_alpha) | Output socket: Alpha |
| [o_blue](#nodebpy.nodes.utilities.SeparateColor.o_blue) | Output socket: Blue |
| [o_green](#nodebpy.nodes.utilities.SeparateColor.o_green) | Output socket: Green |
| [o_red](#nodebpy.nodes.utilities.SeparateColor.o_red) | Output socket: Red |

### SeparateMatrix { #nodebpy.nodes.utilities.SeparateMatrix }

```python
nodes.utilities.SeparateMatrix(matrix=None, **kwargs)
```

Split a 4x4 matrix into its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.SeparateMatrix.i_matrix) | Input socket: Matrix |
| [o_column_1_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_1) | Output socket: Column 1 Row 1 |
| [o_column_1_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_2) | Output socket: Column 1 Row 2 |
| [o_column_1_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_3) | Output socket: Column 1 Row 3 |
| [o_column_1_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_4) | Output socket: Column 1 Row 4 |
| [o_column_2_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_1) | Output socket: Column 2 Row 1 |
| [o_column_2_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_2) | Output socket: Column 2 Row 2 |
| [o_column_2_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_3) | Output socket: Column 2 Row 3 |
| [o_column_2_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_4) | Output socket: Column 2 Row 4 |
| [o_column_3_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_1) | Output socket: Column 3 Row 1 |
| [o_column_3_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_2) | Output socket: Column 3 Row 2 |
| [o_column_3_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_3) | Output socket: Column 3 Row 3 |
| [o_column_3_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_4) | Output socket: Column 3 Row 4 |
| [o_column_4_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_1) | Output socket: Column 4 Row 1 |
| [o_column_4_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_2) | Output socket: Column 4 Row 2 |
| [o_column_4_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_3) | Output socket: Column 4 Row 3 |
| [o_column_4_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_4) | Output socket: Column 4 Row 4 |

### SeparateTransform { #nodebpy.nodes.utilities.SeparateTransform }

```python
nodes.utilities.SeparateTransform(transform=None, **kwargs)
```

Split a transformation matrix into a translation vector, a rotation, and a scale vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.SeparateTransform.i_transform) | Input socket: Transform |
| [o_rotation](#nodebpy.nodes.utilities.SeparateTransform.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.utilities.SeparateTransform.o_scale) | Output socket: Scale |
| [o_translation](#nodebpy.nodes.utilities.SeparateTransform.o_translation) | Output socket: Translation |

### SliceString { #nodebpy.nodes.utilities.SliceString }

```python
nodes.utilities.SliceString(string='', position=0, length=10, **kwargs)
```

Extract a string segment from a larger string

#### Attributes

| Name | Description |
| --- | --- |
| [i_length](#nodebpy.nodes.utilities.SliceString.i_length) | Input socket: Length |
| [i_position](#nodebpy.nodes.utilities.SliceString.i_position) | Input socket: Position |
| [i_string](#nodebpy.nodes.utilities.SliceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.utilities.SliceString.o_string) | Output socket: String |

### StringLength { #nodebpy.nodes.utilities.StringLength }

```python
nodes.utilities.StringLength(string='', **kwargs)
```

Output the number of characters in the given string

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.utilities.StringLength.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.utilities.StringLength.o_length) | Output socket: Length |

### StringToValue { #nodebpy.nodes.utilities.StringToValue }

```python
nodes.utilities.StringToValue(string='', data_type='FLOAT', **kwargs)
```

Derive a numeric value from a given string representation

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.utilities.StringToValue.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.utilities.StringToValue.o_length) | Output socket: Length |
| [o_value](#nodebpy.nodes.utilities.StringToValue.o_value) | Output socket: Value |

### TransformDirection { #nodebpy.nodes.utilities.TransformDirection }

```python
nodes.utilities.TransformDirection(
    direction=[0.0, 0.0, 0.0],
    transform=None,
    **kwargs,
)
```

Apply a transformation matrix (excluding translation) to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.utilities.TransformDirection.i_direction) | Input socket: Direction |
| [i_transform](#nodebpy.nodes.utilities.TransformDirection.i_transform) | Input socket: Transform |
| [o_direction](#nodebpy.nodes.utilities.TransformDirection.o_direction) | Output socket: Direction |

### TransformPoint { #nodebpy.nodes.utilities.TransformPoint }

```python
nodes.utilities.TransformPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)
```

Apply a transformation matrix to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.TransformPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.utilities.TransformPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.TransformPoint.o_vector) | Output socket: Vector |

### TransposeMatrix { #nodebpy.nodes.utilities.TransposeMatrix }

```python
nodes.utilities.TransposeMatrix(matrix=None, **kwargs)
```

Flip a matrix over its diagonal, turning columns into rows and vice-versa

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.TransposeMatrix.i_matrix) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.utilities.TransposeMatrix.o_matrix) | Output socket: Matrix |

### ValueToString { #nodebpy.nodes.utilities.ValueToString }

```python
nodes.utilities.ValueToString(
    value=0.0,
    decimals=0,
    data_type='FLOAT',
    **kwargs,
)
```

Generate a string representation of the given input value

#### Attributes

| Name | Description |
| --- | --- |
| [i_decimals](#nodebpy.nodes.utilities.ValueToString.i_decimals) | Input socket: Decimals |
| [i_value](#nodebpy.nodes.utilities.ValueToString.i_value) | Input socket: Value |
| [o_string](#nodebpy.nodes.utilities.ValueToString.o_string) | Output socket: String |