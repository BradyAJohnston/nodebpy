# nodes.utilities { #nodebpy.nodes.utilities }

`nodes.utilities`

Auto-generated Blender Geometry Node classes.

DO NOT EDIT THIS FILE MANUALLY.
This file is generated by molecularnodes/nodes/generator.py

To regenerate: Run generator.py from within Blender

KNOWN LIMITATIONS:
- Dynamic multi-input/output sockets are not yet supported
  (these are the unnamed sockets that appear in the UI for nodes like
  "Evaluate Closure", "Join Geometry", etc. that allow dragging in
  multiple connections)
- TODO: Add support for dynamic socket creation

## Classes

| Name | Description |
| --- | --- |
| [AlignEulerToVector](#nodebpy.nodes.utilities.AlignEulerToVector) | Orient an Euler rotation along the given direction |
| [AlignRotationToVector](#nodebpy.nodes.utilities.AlignRotationToVector) | Orient a rotation along the given direction |
| [AxesToRotation](#nodebpy.nodes.utilities.AxesToRotation) | Create a rotation from a primary and (ideally orthogonal) secondary axis |
| [AxisAngleToRotation](#nodebpy.nodes.utilities.AxisAngleToRotation) | Build a rotation from an axis and a rotation around that axis |
| [BitMath](#nodebpy.nodes.utilities.BitMath) | Perform bitwise operations on 32-bit integers |
| [Clamp](#nodebpy.nodes.utilities.Clamp) | Clamp a value between a minimum and a maximum |
| [CombineColor](#nodebpy.nodes.utilities.CombineColor) | Combine four channels into a single color, based on a particular color model |
| [CombineMatrix](#nodebpy.nodes.utilities.CombineMatrix) | Construct a 4x4 matrix from its individual values |
| [CombineTransform](#nodebpy.nodes.utilities.CombineTransform) | Combine a translation vector, a rotation, and a scale vector into a transformation matrix |
| [Compare](#nodebpy.nodes.utilities.Compare) | Perform a comparison operation on the two given inputs |
| [EulerToRotation](#nodebpy.nodes.utilities.EulerToRotation) | Build a rotation from separate angles around each axis |
| [FindInString](#nodebpy.nodes.utilities.FindInString) | Find the number of times a given string occurs in another string and the position of the first match |
| [FloatToInteger](#nodebpy.nodes.utilities.FloatToInteger) | Convert the given floating-point number to an integer, with a choice of methods |
| [FormatString](#nodebpy.nodes.utilities.FormatString) | Insert values into a string using a Python and path template compatible formatting syntax |
| [Gamma](#nodebpy.nodes.utilities.Gamma) | Apply a gamma correction |
| [HashValue](#nodebpy.nodes.utilities.HashValue) | Generate a randomized integer using the given input value as a seed |
| [IntegerMath](#nodebpy.nodes.utilities.IntegerMath) | Perform various math operations on the given integer inputs |
| [InvertMatrix](#nodebpy.nodes.utilities.InvertMatrix) | Compute the inverse of the given matrix, if one exists |
| [InvertRotation](#nodebpy.nodes.utilities.InvertRotation) | Compute the inverse of the given rotation |
| [MapRange](#nodebpy.nodes.utilities.MapRange) | Remap a value from a range to a target range |
| [MatchString](#nodebpy.nodes.utilities.MatchString) | Check if a given string exists within another string |
| [MatrixDeterminant](#nodebpy.nodes.utilities.MatrixDeterminant) | Compute the determinant of the given matrix |
| [MultiplyMatrices](#nodebpy.nodes.utilities.MultiplyMatrices) | Perform a matrix multiplication on two input matrices |
| [ProjectPoint](#nodebpy.nodes.utilities.ProjectPoint) | Project a point using a matrix, using location, rotation, scale, and perspective divide |
| [QuaternionToRotation](#nodebpy.nodes.utilities.QuaternionToRotation) | Build a rotation from quaternion components |
| [ReplaceString](#nodebpy.nodes.utilities.ReplaceString) | Replace a given string segment with another |
| [RotateEuler](#nodebpy.nodes.utilities.RotateEuler) | Apply a secondary Euler rotation to a given Euler rotation |
| [RotateRotation](#nodebpy.nodes.utilities.RotateRotation) | Apply a secondary rotation to a given rotation value |
| [RotateVector](#nodebpy.nodes.utilities.RotateVector) | Apply a rotation to a given vector |
| [RotationToAxisAngle](#nodebpy.nodes.utilities.RotationToAxisAngle) | Convert a rotation to axis angle components |
| [RotationToEuler](#nodebpy.nodes.utilities.RotationToEuler) | Convert a standard rotation value to an Euler rotation |
| [RotationToQuaternion](#nodebpy.nodes.utilities.RotationToQuaternion) | Retrieve the quaternion components representing a rotation |
| [SeparateColor](#nodebpy.nodes.utilities.SeparateColor) | Split a color into separate channels, based on a particular color model |
| [SeparateMatrix](#nodebpy.nodes.utilities.SeparateMatrix) | Split a 4x4 matrix into its individual values |
| [SeparateTransform](#nodebpy.nodes.utilities.SeparateTransform) | Split a transformation matrix into a translation vector, a rotation, and a scale vector |
| [SliceString](#nodebpy.nodes.utilities.SliceString) | Extract a string segment from a larger string |
| [StringLength](#nodebpy.nodes.utilities.StringLength) | Output the number of characters in the given string |
| [StringToValue](#nodebpy.nodes.utilities.StringToValue) | Derive a numeric value from a given string representation |
| [TransformDirection](#nodebpy.nodes.utilities.TransformDirection) | Apply a transformation matrix (excluding translation) to the given vector |
| [TransformPoint](#nodebpy.nodes.utilities.TransformPoint) | Apply a transformation matrix to the given vector |
| [TransposeMatrix](#nodebpy.nodes.utilities.TransposeMatrix) | Flip a matrix over its diagonal, turning columns into rows and vice-versa |
| [ValueToString](#nodebpy.nodes.utilities.ValueToString) | Generate a string representation of the given input value |

### AlignEulerToVector { #nodebpy.nodes.utilities.AlignEulerToVector }

```python
nodes.utilities.AlignEulerToVector(
    rotation=[0.0, 0.0, 0.0],
    factor=1.0,
    vector=[0.0, 0.0, 1.0],
    axis='X',
    pivot_axis='AUTO',
    **kwargs,
)
```

Orient an Euler rotation along the given direction

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.utilities.AlignEulerToVector.i_factor) | Input socket: Factor |
| [i_rotation](#nodebpy.nodes.utilities.AlignEulerToVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.utilities.AlignEulerToVector.i_vector) | Input socket: Vector |
| [o_rotation](#nodebpy.nodes.utilities.AlignEulerToVector.o_rotation) | Output socket: Rotation |

### AlignRotationToVector { #nodebpy.nodes.utilities.AlignRotationToVector }

```python
nodes.utilities.AlignRotationToVector(
    rotation=[0.0, 0.0, 0.0],
    factor=1.0,
    vector=[0.0, 0.0, 1.0],
    axis='Z',
    pivot_axis='AUTO',
    **kwargs,
)
```

Orient a rotation along the given direction

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.utilities.AlignRotationToVector.i_factor) | Input socket: Factor |
| [i_rotation](#nodebpy.nodes.utilities.AlignRotationToVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.utilities.AlignRotationToVector.i_vector) | Input socket: Vector |
| [o_rotation](#nodebpy.nodes.utilities.AlignRotationToVector.o_rotation) | Output socket: Rotation |

### AxesToRotation { #nodebpy.nodes.utilities.AxesToRotation }

```python
nodes.utilities.AxesToRotation(
    primary_axis=[0.0, 0.0, 1.0],
    secondary_axis=[1.0, 0.0, 0.0],
    primary_axis_axis='Z',
    secondary_axis_axis='X',
    **kwargs,
)
```

Create a rotation from a primary and (ideally orthogonal) secondary axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_primary_axis](#nodebpy.nodes.utilities.AxesToRotation.i_primary_axis) | Input socket: Primary Axis |
| [i_secondary_axis](#nodebpy.nodes.utilities.AxesToRotation.i_secondary_axis) | Input socket: Secondary Axis |
| [o_rotation](#nodebpy.nodes.utilities.AxesToRotation.o_rotation) | Output socket: Rotation |

### AxisAngleToRotation { #nodebpy.nodes.utilities.AxisAngleToRotation }

```python
nodes.utilities.AxisAngleToRotation(axis=[0.0, 0.0, 1.0], angle=0.0, **kwargs)
```

Build a rotation from an axis and a rotation around that axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_angle](#nodebpy.nodes.utilities.AxisAngleToRotation.i_angle) | Input socket: Angle |
| [i_axis](#nodebpy.nodes.utilities.AxisAngleToRotation.i_axis) | Input socket: Axis |
| [o_rotation](#nodebpy.nodes.utilities.AxisAngleToRotation.o_rotation) | Output socket: Rotation |

### BitMath { #nodebpy.nodes.utilities.BitMath }

```python
nodes.utilities.BitMath(a=0, b=0, operation='AND', **kwargs)
```

Perform bitwise operations on 32-bit integers

#### Attributes

| Name | Description |
| --- | --- |
| [i_a](#nodebpy.nodes.utilities.BitMath.i_a) | Input socket: A |
| [i_b](#nodebpy.nodes.utilities.BitMath.i_b) | Input socket: B |
| [o_value](#nodebpy.nodes.utilities.BitMath.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [l_and](#nodebpy.nodes.utilities.BitMath.l_and) | Create Bit Math with operation 'And'. |
| [l_not](#nodebpy.nodes.utilities.BitMath.l_not) | Create Bit Math with operation 'Not'. |
| [l_or](#nodebpy.nodes.utilities.BitMath.l_or) | Create Bit Math with operation 'Or'. |
| [rotate](#nodebpy.nodes.utilities.BitMath.rotate) | Create Bit Math with operation 'Rotate'. |
| [shift](#nodebpy.nodes.utilities.BitMath.shift) | Create Bit Math with operation 'Shift'. |
| [xor](#nodebpy.nodes.utilities.BitMath.xor) | Create Bit Math with operation 'Exclusive Or'. |

##### l_and { #nodebpy.nodes.utilities.BitMath.l_and }

```python
nodes.utilities.BitMath.l_and(a=0, b=0)
```

Create Bit Math with operation 'And'.

##### l_not { #nodebpy.nodes.utilities.BitMath.l_not }

```python
nodes.utilities.BitMath.l_not(a=0, b=0)
```

Create Bit Math with operation 'Not'.

##### l_or { #nodebpy.nodes.utilities.BitMath.l_or }

```python
nodes.utilities.BitMath.l_or(a=0, b=0)
```

Create Bit Math with operation 'Or'.

##### rotate { #nodebpy.nodes.utilities.BitMath.rotate }

```python
nodes.utilities.BitMath.rotate(a=0, b=0)
```

Create Bit Math with operation 'Rotate'.

##### shift { #nodebpy.nodes.utilities.BitMath.shift }

```python
nodes.utilities.BitMath.shift(a=0, b=0)
```

Create Bit Math with operation 'Shift'.

##### xor { #nodebpy.nodes.utilities.BitMath.xor }

```python
nodes.utilities.BitMath.xor(a=0, b=0)
```

Create Bit Math with operation 'Exclusive Or'.

### Clamp { #nodebpy.nodes.utilities.Clamp }

```python
nodes.utilities.Clamp(
    value=1.0,
    min=0.0,
    max=1.0,
    clamp_type='MINMAX',
    **kwargs,
)
```

Clamp a value between a minimum and a maximum

#### Attributes

| Name | Description |
| --- | --- |
| [i_max](#nodebpy.nodes.utilities.Clamp.i_max) | Input socket: Max |
| [i_min](#nodebpy.nodes.utilities.Clamp.i_min) | Input socket: Min |
| [i_value](#nodebpy.nodes.utilities.Clamp.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.utilities.Clamp.o_result) | Output socket: Result |

### CombineColor { #nodebpy.nodes.utilities.CombineColor }

```python
nodes.utilities.CombineColor(
    red=0.0,
    green=0.0,
    blue=0.0,
    alpha=1.0,
    mode='RGB',
    **kwargs,
)
```

Combine four channels into a single color, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_alpha](#nodebpy.nodes.utilities.CombineColor.i_alpha) | Input socket: Alpha |
| [i_blue](#nodebpy.nodes.utilities.CombineColor.i_blue) | Input socket: Blue |
| [i_green](#nodebpy.nodes.utilities.CombineColor.i_green) | Input socket: Green |
| [i_red](#nodebpy.nodes.utilities.CombineColor.i_red) | Input socket: Red |
| [o_color](#nodebpy.nodes.utilities.CombineColor.o_color) | Output socket: Color |

### CombineMatrix { #nodebpy.nodes.utilities.CombineMatrix }

```python
nodes.utilities.CombineMatrix(
    column_1_row_1=1.0,
    column_1_row_2=0.0,
    column_1_row_3=0.0,
    column_1_row_4=0.0,
    column_2_row_1=0.0,
    column_2_row_2=1.0,
    column_2_row_3=0.0,
    column_2_row_4=0.0,
    column_3_row_1=0.0,
    column_3_row_2=0.0,
    column_3_row_3=1.0,
    column_3_row_4=0.0,
    column_4_row_1=0.0,
    column_4_row_2=0.0,
    column_4_row_3=0.0,
    column_4_row_4=1.0,
    **kwargs,
)
```

Construct a 4x4 matrix from its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_column_1_row_1](#nodebpy.nodes.utilities.CombineMatrix.i_column_1_row_1) | Input socket: Column 1 Row 1 |
| [i_column_1_row_2](#nodebpy.nodes.utilities.CombineMatrix.i_column_1_row_2) | Input socket: Column 1 Row 2 |
| [i_column_1_row_3](#nodebpy.nodes.utilities.CombineMatrix.i_column_1_row_3) | Input socket: Column 1 Row 3 |
| [i_column_1_row_4](#nodebpy.nodes.utilities.CombineMatrix.i_column_1_row_4) | Input socket: Column 1 Row 4 |
| [i_column_2_row_1](#nodebpy.nodes.utilities.CombineMatrix.i_column_2_row_1) | Input socket: Column 2 Row 1 |
| [i_column_2_row_2](#nodebpy.nodes.utilities.CombineMatrix.i_column_2_row_2) | Input socket: Column 2 Row 2 |
| [i_column_2_row_3](#nodebpy.nodes.utilities.CombineMatrix.i_column_2_row_3) | Input socket: Column 2 Row 3 |
| [i_column_2_row_4](#nodebpy.nodes.utilities.CombineMatrix.i_column_2_row_4) | Input socket: Column 2 Row 4 |
| [i_column_3_row_1](#nodebpy.nodes.utilities.CombineMatrix.i_column_3_row_1) | Input socket: Column 3 Row 1 |
| [i_column_3_row_2](#nodebpy.nodes.utilities.CombineMatrix.i_column_3_row_2) | Input socket: Column 3 Row 2 |
| [i_column_3_row_3](#nodebpy.nodes.utilities.CombineMatrix.i_column_3_row_3) | Input socket: Column 3 Row 3 |
| [i_column_3_row_4](#nodebpy.nodes.utilities.CombineMatrix.i_column_3_row_4) | Input socket: Column 3 Row 4 |
| [i_column_4_row_1](#nodebpy.nodes.utilities.CombineMatrix.i_column_4_row_1) | Input socket: Column 4 Row 1 |
| [i_column_4_row_2](#nodebpy.nodes.utilities.CombineMatrix.i_column_4_row_2) | Input socket: Column 4 Row 2 |
| [i_column_4_row_3](#nodebpy.nodes.utilities.CombineMatrix.i_column_4_row_3) | Input socket: Column 4 Row 3 |
| [i_column_4_row_4](#nodebpy.nodes.utilities.CombineMatrix.i_column_4_row_4) | Input socket: Column 4 Row 4 |
| [o_matrix](#nodebpy.nodes.utilities.CombineMatrix.o_matrix) | Output socket: Matrix |

### CombineTransform { #nodebpy.nodes.utilities.CombineTransform }

```python
nodes.utilities.CombineTransform(
    translation=[0.0, 0.0, 0.0],
    rotation=[0.0, 0.0, 0.0],
    scale=[1.0, 1.0, 1.0],
    **kwargs,
)
```

Combine a translation vector, a rotation, and a scale vector into a transformation matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.CombineTransform.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.utilities.CombineTransform.i_scale) | Input socket: Scale |
| [i_translation](#nodebpy.nodes.utilities.CombineTransform.i_translation) | Input socket: Translation |
| [o_transform](#nodebpy.nodes.utilities.CombineTransform.o_transform) | Output socket: Transform |

### Compare { #nodebpy.nodes.utilities.Compare }

```python
nodes.utilities.Compare(
    a=0.0,
    b=0.0,
    operation='GREATER_THAN',
    data_type='FLOAT',
    mode='ELEMENT',
    **kwargs,
)
```

Perform a comparison operation on the two given inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_a](#nodebpy.nodes.utilities.Compare.i_a) | Input socket: A |
| [i_b](#nodebpy.nodes.utilities.Compare.i_b) | Input socket: B |
| [o_result](#nodebpy.nodes.utilities.Compare.o_result) | Output socket: Result |

#### Methods

| Name | Description |
| --- | --- |
| [brighter](#nodebpy.nodes.utilities.Compare.brighter) | Create Compare with operation 'Brighter'. |
| [darker](#nodebpy.nodes.utilities.Compare.darker) | Create Compare with operation 'Darker'. |
| [equal](#nodebpy.nodes.utilities.Compare.equal) | Create Compare with operation 'Equal'. |
| [greaterequal](#nodebpy.nodes.utilities.Compare.greaterequal) | Create Compare with operation 'Greater Than or Equal'. |
| [greaterthan](#nodebpy.nodes.utilities.Compare.greaterthan) | Create Compare with operation 'Greater Than'. |
| [lessequal](#nodebpy.nodes.utilities.Compare.lessequal) | Create Compare with operation 'Less Than or Equal'. |
| [lessthan](#nodebpy.nodes.utilities.Compare.lessthan) | Create Compare with operation 'Less Than'. |
| [notequal](#nodebpy.nodes.utilities.Compare.notequal) | Create Compare with operation 'Not Equal'. |

##### brighter { #nodebpy.nodes.utilities.Compare.brighter }

```python
nodes.utilities.Compare.brighter(a=0.0, b=0.0)
```

Create Compare with operation 'Brighter'.

##### darker { #nodebpy.nodes.utilities.Compare.darker }

```python
nodes.utilities.Compare.darker(a=0.0, b=0.0)
```

Create Compare with operation 'Darker'.

##### equal { #nodebpy.nodes.utilities.Compare.equal }

```python
nodes.utilities.Compare.equal(a=0.0, b=0.0)
```

Create Compare with operation 'Equal'.

##### greaterequal { #nodebpy.nodes.utilities.Compare.greaterequal }

```python
nodes.utilities.Compare.greaterequal(a=0.0, b=0.0)
```

Create Compare with operation 'Greater Than or Equal'.

##### greaterthan { #nodebpy.nodes.utilities.Compare.greaterthan }

```python
nodes.utilities.Compare.greaterthan(a=0.0, b=0.0)
```

Create Compare with operation 'Greater Than'.

##### lessequal { #nodebpy.nodes.utilities.Compare.lessequal }

```python
nodes.utilities.Compare.lessequal(a=0.0, b=0.0)
```

Create Compare with operation 'Less Than or Equal'.

##### lessthan { #nodebpy.nodes.utilities.Compare.lessthan }

```python
nodes.utilities.Compare.lessthan(a=0.0, b=0.0)
```

Create Compare with operation 'Less Than'.

##### notequal { #nodebpy.nodes.utilities.Compare.notequal }

```python
nodes.utilities.Compare.notequal(a=0.0, b=0.0)
```

Create Compare with operation 'Not Equal'.

### EulerToRotation { #nodebpy.nodes.utilities.EulerToRotation }

```python
nodes.utilities.EulerToRotation(euler=[0.0, 0.0, 0.0], **kwargs)
```

Build a rotation from separate angles around each axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_euler](#nodebpy.nodes.utilities.EulerToRotation.i_euler) | Input socket: Euler |
| [o_rotation](#nodebpy.nodes.utilities.EulerToRotation.o_rotation) | Output socket: Rotation |

### FindInString { #nodebpy.nodes.utilities.FindInString }

```python
nodes.utilities.FindInString(string='', search='', **kwargs)
```

Find the number of times a given string occurs in another string and the position of the first match

#### Attributes

| Name | Description |
| --- | --- |
| [i_search](#nodebpy.nodes.utilities.FindInString.i_search) | Input socket: Search |
| [i_string](#nodebpy.nodes.utilities.FindInString.i_string) | Input socket: String |
| [o_count](#nodebpy.nodes.utilities.FindInString.o_count) | Output socket: Count |
| [o_first_found](#nodebpy.nodes.utilities.FindInString.o_first_found) | Output socket: First Found |

### FloatToInteger { #nodebpy.nodes.utilities.FloatToInteger }

```python
nodes.utilities.FloatToInteger(float=0.0, rounding_mode='ROUND', **kwargs)
```

Convert the given floating-point number to an integer, with a choice of methods

#### Attributes

| Name | Description |
| --- | --- |
| [i_float](#nodebpy.nodes.utilities.FloatToInteger.i_float) | Input socket: Float |
| [o_integer](#nodebpy.nodes.utilities.FloatToInteger.o_integer) | Output socket: Integer |

### FormatString { #nodebpy.nodes.utilities.FormatString }

```python
nodes.utilities.FormatString(format='', extend=None, active_index=0, **kwargs)
```

Insert values into a string using a Python and path template compatible formatting syntax

#### Attributes

| Name | Description |
| --- | --- |
| [i_format](#nodebpy.nodes.utilities.FormatString.i_format) | Input socket: Format |
| [i_input_socket](#nodebpy.nodes.utilities.FormatString.i_input_socket) | Input socket: |
| [o_string](#nodebpy.nodes.utilities.FormatString.o_string) | Output socket: String |

### Gamma { #nodebpy.nodes.utilities.Gamma }

```python
nodes.utilities.Gamma(color=[1.0, 1.0, 1.0, 1.0], gamma=1.0, **kwargs)
```

Apply a gamma correction

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.utilities.Gamma.i_color) | Input socket: Color |
| [i_gamma](#nodebpy.nodes.utilities.Gamma.i_gamma) | Input socket: Gamma |
| [o_color](#nodebpy.nodes.utilities.Gamma.o_color) | Output socket: Color |

### HashValue { #nodebpy.nodes.utilities.HashValue }

```python
nodes.utilities.HashValue(value=0, seed=0, data_type='INT', **kwargs)
```

Generate a randomized integer using the given input value as a seed

#### Attributes

| Name | Description |
| --- | --- |
| [i_seed](#nodebpy.nodes.utilities.HashValue.i_seed) | Input socket: Seed |
| [i_value](#nodebpy.nodes.utilities.HashValue.i_value) | Input socket: Value |
| [o_hash](#nodebpy.nodes.utilities.HashValue.o_hash) | Output socket: Hash |

### IntegerMath { #nodebpy.nodes.utilities.IntegerMath }

```python
nodes.utilities.IntegerMath(value=0, value_001=0, operation='ADD', **kwargs)
```

Perform various math operations on the given integer inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.utilities.IntegerMath.i_value) | Input socket: Value |
| [i_value_001](#nodebpy.nodes.utilities.IntegerMath.i_value_001) | Input socket: Value |
| [o_value](#nodebpy.nodes.utilities.IntegerMath.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.utilities.IntegerMath.absolute) | Create Integer Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.utilities.IntegerMath.add) | Create Integer Math with operation 'Add'. |
| [divide](#nodebpy.nodes.utilities.IntegerMath.divide) | Create Integer Math with operation 'Divide'. |
| [divideceil](#nodebpy.nodes.utilities.IntegerMath.divideceil) | Create Integer Math with operation 'Divide Ceiling'. |
| [dividefloor](#nodebpy.nodes.utilities.IntegerMath.dividefloor) | Create Integer Math with operation 'Divide Floor'. |
| [divideround](#nodebpy.nodes.utilities.IntegerMath.divideround) | Create Integer Math with operation 'Divide Round'. |
| [flooredmodulo](#nodebpy.nodes.utilities.IntegerMath.flooredmodulo) | Create Integer Math with operation 'Floored Modulo'. |
| [gcd](#nodebpy.nodes.utilities.IntegerMath.gcd) | Create Integer Math with operation 'Greatest Common Divisor'. |
| [lcm](#nodebpy.nodes.utilities.IntegerMath.lcm) | Create Integer Math with operation 'Least Common Multiple'. |
| [maximum](#nodebpy.nodes.utilities.IntegerMath.maximum) | Create Integer Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.utilities.IntegerMath.minimum) | Create Integer Math with operation 'Minimum'. |
| [modulo](#nodebpy.nodes.utilities.IntegerMath.modulo) | Create Integer Math with operation 'Modulo'. |
| [multiply](#nodebpy.nodes.utilities.IntegerMath.multiply) | Create Integer Math with operation 'Multiply'. |
| [multiplyadd](#nodebpy.nodes.utilities.IntegerMath.multiplyadd) | Create Integer Math with operation 'Multiply Add'. |
| [negate](#nodebpy.nodes.utilities.IntegerMath.negate) | Create Integer Math with operation 'Negate'. |
| [power](#nodebpy.nodes.utilities.IntegerMath.power) | Create Integer Math with operation 'Power'. |
| [sign](#nodebpy.nodes.utilities.IntegerMath.sign) | Create Integer Math with operation 'Sign'. |
| [subtract](#nodebpy.nodes.utilities.IntegerMath.subtract) | Create Integer Math with operation 'Subtract'. |

##### absolute { #nodebpy.nodes.utilities.IntegerMath.absolute }

```python
nodes.utilities.IntegerMath.absolute(value=0, value_001=0)
```

Create Integer Math with operation 'Absolute'.

##### add { #nodebpy.nodes.utilities.IntegerMath.add }

```python
nodes.utilities.IntegerMath.add(value=0, value_001=0)
```

Create Integer Math with operation 'Add'.

##### divide { #nodebpy.nodes.utilities.IntegerMath.divide }

```python
nodes.utilities.IntegerMath.divide(value=0, value_001=0)
```

Create Integer Math with operation 'Divide'.

##### divideceil { #nodebpy.nodes.utilities.IntegerMath.divideceil }

```python
nodes.utilities.IntegerMath.divideceil(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Ceiling'.

##### dividefloor { #nodebpy.nodes.utilities.IntegerMath.dividefloor }

```python
nodes.utilities.IntegerMath.dividefloor(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Floor'.

##### divideround { #nodebpy.nodes.utilities.IntegerMath.divideround }

```python
nodes.utilities.IntegerMath.divideround(value=0, value_001=0)
```

Create Integer Math with operation 'Divide Round'.

##### flooredmodulo { #nodebpy.nodes.utilities.IntegerMath.flooredmodulo }

```python
nodes.utilities.IntegerMath.flooredmodulo(value=0, value_001=0)
```

Create Integer Math with operation 'Floored Modulo'.

##### gcd { #nodebpy.nodes.utilities.IntegerMath.gcd }

```python
nodes.utilities.IntegerMath.gcd(value=0, value_001=0)
```

Create Integer Math with operation 'Greatest Common Divisor'.

##### lcm { #nodebpy.nodes.utilities.IntegerMath.lcm }

```python
nodes.utilities.IntegerMath.lcm(value=0, value_001=0)
```

Create Integer Math with operation 'Least Common Multiple'.

##### maximum { #nodebpy.nodes.utilities.IntegerMath.maximum }

```python
nodes.utilities.IntegerMath.maximum(value=0, value_001=0)
```

Create Integer Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.utilities.IntegerMath.minimum }

```python
nodes.utilities.IntegerMath.minimum(value=0, value_001=0)
```

Create Integer Math with operation 'Minimum'.

##### modulo { #nodebpy.nodes.utilities.IntegerMath.modulo }

```python
nodes.utilities.IntegerMath.modulo(value=0, value_001=0)
```

Create Integer Math with operation 'Modulo'.

##### multiply { #nodebpy.nodes.utilities.IntegerMath.multiply }

```python
nodes.utilities.IntegerMath.multiply(value=0, value_001=0)
```

Create Integer Math with operation 'Multiply'.

##### multiplyadd { #nodebpy.nodes.utilities.IntegerMath.multiplyadd }

```python
nodes.utilities.IntegerMath.multiplyadd(value=0, value_001=0)
```

Create Integer Math with operation 'Multiply Add'.

##### negate { #nodebpy.nodes.utilities.IntegerMath.negate }

```python
nodes.utilities.IntegerMath.negate(value=0, value_001=0)
```

Create Integer Math with operation 'Negate'.

##### power { #nodebpy.nodes.utilities.IntegerMath.power }

```python
nodes.utilities.IntegerMath.power(value=0, value_001=0)
```

Create Integer Math with operation 'Power'.

##### sign { #nodebpy.nodes.utilities.IntegerMath.sign }

```python
nodes.utilities.IntegerMath.sign(value=0, value_001=0)
```

Create Integer Math with operation 'Sign'.

##### subtract { #nodebpy.nodes.utilities.IntegerMath.subtract }

```python
nodes.utilities.IntegerMath.subtract(value=0, value_001=0)
```

Create Integer Math with operation 'Subtract'.

### InvertMatrix { #nodebpy.nodes.utilities.InvertMatrix }

```python
nodes.utilities.InvertMatrix(matrix=None, **kwargs)
```

Compute the inverse of the given matrix, if one exists

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.InvertMatrix.i_matrix) | Input socket: Matrix |
| [o_invertible](#nodebpy.nodes.utilities.InvertMatrix.o_invertible) | Output socket: Invertible |
| [o_matrix](#nodebpy.nodes.utilities.InvertMatrix.o_matrix) | Output socket: Matrix |

### InvertRotation { #nodebpy.nodes.utilities.InvertRotation }

```python
nodes.utilities.InvertRotation(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Compute the inverse of the given rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.InvertRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.InvertRotation.o_rotation) | Output socket: Rotation |

### MapRange { #nodebpy.nodes.utilities.MapRange }

```python
nodes.utilities.MapRange(
    value=1.0,
    from_min=0.0,
    from_max=1.0,
    to_min=0.0,
    to_max=1.0,
    clamp=False,
    interpolation_type='LINEAR',
    data_type='FLOAT',
    **kwargs,
)
```

Remap a value from a range to a target range

#### Attributes

| Name | Description |
| --- | --- |
| [i_from_max](#nodebpy.nodes.utilities.MapRange.i_from_max) | Input socket: From Max |
| [i_from_min](#nodebpy.nodes.utilities.MapRange.i_from_min) | Input socket: From Min |
| [i_to_max](#nodebpy.nodes.utilities.MapRange.i_to_max) | Input socket: To Max |
| [i_to_min](#nodebpy.nodes.utilities.MapRange.i_to_min) | Input socket: To Min |
| [i_value](#nodebpy.nodes.utilities.MapRange.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.utilities.MapRange.o_result) | Output socket: Result |

### MatchString { #nodebpy.nodes.utilities.MatchString }

```python
nodes.utilities.MatchString(
    string='',
    operation='Starts With',
    key='',
    **kwargs,
)
```

Check if a given string exists within another string

#### Attributes

| Name | Description |
| --- | --- |
| [i_key](#nodebpy.nodes.utilities.MatchString.i_key) | Input socket: Key |
| [i_operation](#nodebpy.nodes.utilities.MatchString.i_operation) | Input socket: Operation |
| [i_string](#nodebpy.nodes.utilities.MatchString.i_string) | Input socket: String |
| [o_result](#nodebpy.nodes.utilities.MatchString.o_result) | Output socket: Result |

### MatrixDeterminant { #nodebpy.nodes.utilities.MatrixDeterminant }

```python
nodes.utilities.MatrixDeterminant(matrix=None, **kwargs)
```

Compute the determinant of the given matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.MatrixDeterminant.i_matrix) | Input socket: Matrix |
| [o_determinant](#nodebpy.nodes.utilities.MatrixDeterminant.o_determinant) | Output socket: Determinant |

### MultiplyMatrices { #nodebpy.nodes.utilities.MultiplyMatrices }

```python
nodes.utilities.MultiplyMatrices(matrix=None, matrix_001=None, **kwargs)
```

Perform a matrix multiplication on two input matrices

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.MultiplyMatrices.i_matrix) | Input socket: Matrix |
| [i_matrix_001](#nodebpy.nodes.utilities.MultiplyMatrices.i_matrix_001) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.utilities.MultiplyMatrices.o_matrix) | Output socket: Matrix |

### ProjectPoint { #nodebpy.nodes.utilities.ProjectPoint }

```python
nodes.utilities.ProjectPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)
```

Project a point using a matrix, using location, rotation, scale, and perspective divide

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.ProjectPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.utilities.ProjectPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.ProjectPoint.o_vector) | Output socket: Vector |

### QuaternionToRotation { #nodebpy.nodes.utilities.QuaternionToRotation }

```python
nodes.utilities.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0, **kwargs)
```

Build a rotation from quaternion components

#### Attributes

| Name | Description |
| --- | --- |
| [i_w](#nodebpy.nodes.utilities.QuaternionToRotation.i_w) | Input socket: W |
| [i_x](#nodebpy.nodes.utilities.QuaternionToRotation.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.utilities.QuaternionToRotation.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.utilities.QuaternionToRotation.i_z) | Input socket: Z |
| [o_rotation](#nodebpy.nodes.utilities.QuaternionToRotation.o_rotation) | Output socket: Rotation |

### ReplaceString { #nodebpy.nodes.utilities.ReplaceString }

```python
nodes.utilities.ReplaceString(string='', find='', replace='', **kwargs)
```

Replace a given string segment with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_find](#nodebpy.nodes.utilities.ReplaceString.i_find) | Input socket: Find |
| [i_replace](#nodebpy.nodes.utilities.ReplaceString.i_replace) | Input socket: Replace |
| [i_string](#nodebpy.nodes.utilities.ReplaceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.utilities.ReplaceString.o_string) | Output socket: String |

### RotateEuler { #nodebpy.nodes.utilities.RotateEuler }

```python
nodes.utilities.RotateEuler(
    rotation=[0.0, 0.0, 0.0],
    rotate_by=[0.0, 0.0, 0.0],
    rotation_type='EULER',
    space='OBJECT',
    **kwargs,
)
```

Apply a secondary Euler rotation to a given Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.utilities.RotateEuler.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.utilities.RotateEuler.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.RotateEuler.o_rotation) | Output socket: Rotation |

### RotateRotation { #nodebpy.nodes.utilities.RotateRotation }

```python
nodes.utilities.RotateRotation(
    rotation=[0.0, 0.0, 0.0],
    rotate_by=[0.0, 0.0, 0.0],
    rotation_space='GLOBAL',
    **kwargs,
)
```

Apply a secondary rotation to a given rotation value

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.utilities.RotateRotation.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.utilities.RotateRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.utilities.RotateRotation.o_rotation) | Output socket: Rotation |

### RotateVector { #nodebpy.nodes.utilities.RotateVector }

```python
nodes.utilities.RotateVector(
    vector=[0.0, 0.0, 0.0],
    rotation=[0.0, 0.0, 0.0],
    **kwargs,
)
```

Apply a rotation to a given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotateVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.utilities.RotateVector.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.RotateVector.o_vector) | Output socket: Vector |

### RotationToAxisAngle { #nodebpy.nodes.utilities.RotationToAxisAngle }

```python
nodes.utilities.RotationToAxisAngle(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Convert a rotation to axis angle components

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToAxisAngle.i_rotation) | Input socket: Rotation |
| [o_angle](#nodebpy.nodes.utilities.RotationToAxisAngle.o_angle) | Output socket: Angle |
| [o_axis](#nodebpy.nodes.utilities.RotationToAxisAngle.o_axis) | Output socket: Axis |

### RotationToEuler { #nodebpy.nodes.utilities.RotationToEuler }

```python
nodes.utilities.RotationToEuler(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Convert a standard rotation value to an Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToEuler.i_rotation) | Input socket: Rotation |
| [o_euler](#nodebpy.nodes.utilities.RotationToEuler.o_euler) | Output socket: Euler |

### RotationToQuaternion { #nodebpy.nodes.utilities.RotationToQuaternion }

```python
nodes.utilities.RotationToQuaternion(rotation=[0.0, 0.0, 0.0], **kwargs)
```

Retrieve the quaternion components representing a rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.utilities.RotationToQuaternion.i_rotation) | Input socket: Rotation |
| [o_w](#nodebpy.nodes.utilities.RotationToQuaternion.o_w) | Output socket: W |
| [o_x](#nodebpy.nodes.utilities.RotationToQuaternion.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.utilities.RotationToQuaternion.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.utilities.RotationToQuaternion.o_z) | Output socket: Z |

### SeparateColor { #nodebpy.nodes.utilities.SeparateColor }

```python
nodes.utilities.SeparateColor(color=[1.0, 1.0, 1.0, 1.0], mode='RGB', **kwargs)
```

Split a color into separate channels, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.utilities.SeparateColor.i_color) | Input socket: Color |
| [o_alpha](#nodebpy.nodes.utilities.SeparateColor.o_alpha) | Output socket: Alpha |
| [o_blue](#nodebpy.nodes.utilities.SeparateColor.o_blue) | Output socket: Blue |
| [o_green](#nodebpy.nodes.utilities.SeparateColor.o_green) | Output socket: Green |
| [o_red](#nodebpy.nodes.utilities.SeparateColor.o_red) | Output socket: Red |

### SeparateMatrix { #nodebpy.nodes.utilities.SeparateMatrix }

```python
nodes.utilities.SeparateMatrix(matrix=None, **kwargs)
```

Split a 4x4 matrix into its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.SeparateMatrix.i_matrix) | Input socket: Matrix |
| [o_column_1_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_1) | Output socket: Column 1 Row 1 |
| [o_column_1_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_2) | Output socket: Column 1 Row 2 |
| [o_column_1_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_3) | Output socket: Column 1 Row 3 |
| [o_column_1_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_1_row_4) | Output socket: Column 1 Row 4 |
| [o_column_2_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_1) | Output socket: Column 2 Row 1 |
| [o_column_2_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_2) | Output socket: Column 2 Row 2 |
| [o_column_2_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_3) | Output socket: Column 2 Row 3 |
| [o_column_2_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_2_row_4) | Output socket: Column 2 Row 4 |
| [o_column_3_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_1) | Output socket: Column 3 Row 1 |
| [o_column_3_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_2) | Output socket: Column 3 Row 2 |
| [o_column_3_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_3) | Output socket: Column 3 Row 3 |
| [o_column_3_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_3_row_4) | Output socket: Column 3 Row 4 |
| [o_column_4_row_1](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_1) | Output socket: Column 4 Row 1 |
| [o_column_4_row_2](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_2) | Output socket: Column 4 Row 2 |
| [o_column_4_row_3](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_3) | Output socket: Column 4 Row 3 |
| [o_column_4_row_4](#nodebpy.nodes.utilities.SeparateMatrix.o_column_4_row_4) | Output socket: Column 4 Row 4 |

### SeparateTransform { #nodebpy.nodes.utilities.SeparateTransform }

```python
nodes.utilities.SeparateTransform(transform=None, **kwargs)
```

Split a transformation matrix into a translation vector, a rotation, and a scale vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.SeparateTransform.i_transform) | Input socket: Transform |
| [o_rotation](#nodebpy.nodes.utilities.SeparateTransform.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.utilities.SeparateTransform.o_scale) | Output socket: Scale |
| [o_translation](#nodebpy.nodes.utilities.SeparateTransform.o_translation) | Output socket: Translation |

### SliceString { #nodebpy.nodes.utilities.SliceString }

```python
nodes.utilities.SliceString(string='', position=0, length=10, **kwargs)
```

Extract a string segment from a larger string

#### Attributes

| Name | Description |
| --- | --- |
| [i_length](#nodebpy.nodes.utilities.SliceString.i_length) | Input socket: Length |
| [i_position](#nodebpy.nodes.utilities.SliceString.i_position) | Input socket: Position |
| [i_string](#nodebpy.nodes.utilities.SliceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.utilities.SliceString.o_string) | Output socket: String |

### StringLength { #nodebpy.nodes.utilities.StringLength }

```python
nodes.utilities.StringLength(string='', **kwargs)
```

Output the number of characters in the given string

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.utilities.StringLength.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.utilities.StringLength.o_length) | Output socket: Length |

### StringToValue { #nodebpy.nodes.utilities.StringToValue }

```python
nodes.utilities.StringToValue(string='', data_type='FLOAT', **kwargs)
```

Derive a numeric value from a given string representation

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.utilities.StringToValue.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.utilities.StringToValue.o_length) | Output socket: Length |
| [o_value](#nodebpy.nodes.utilities.StringToValue.o_value) | Output socket: Value |

### TransformDirection { #nodebpy.nodes.utilities.TransformDirection }

```python
nodes.utilities.TransformDirection(
    direction=[0.0, 0.0, 0.0],
    transform=None,
    **kwargs,
)
```

Apply a transformation matrix (excluding translation) to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.utilities.TransformDirection.i_direction) | Input socket: Direction |
| [i_transform](#nodebpy.nodes.utilities.TransformDirection.i_transform) | Input socket: Transform |
| [o_direction](#nodebpy.nodes.utilities.TransformDirection.o_direction) | Output socket: Direction |

### TransformPoint { #nodebpy.nodes.utilities.TransformPoint }

```python
nodes.utilities.TransformPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)
```

Apply a transformation matrix to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.utilities.TransformPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.utilities.TransformPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.utilities.TransformPoint.o_vector) | Output socket: Vector |

### TransposeMatrix { #nodebpy.nodes.utilities.TransposeMatrix }

```python
nodes.utilities.TransposeMatrix(matrix=None, **kwargs)
```

Flip a matrix over its diagonal, turning columns into rows and vice-versa

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.utilities.TransposeMatrix.i_matrix) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.utilities.TransposeMatrix.o_matrix) | Output socket: Matrix |

### ValueToString { #nodebpy.nodes.utilities.ValueToString }

```python
nodes.utilities.ValueToString(
    value=0.0,
    decimals=0,
    data_type='FLOAT',
    **kwargs,
)
```

Generate a string representation of the given input value

#### Attributes

| Name | Description |
| --- | --- |
| [i_decimals](#nodebpy.nodes.utilities.ValueToString.i_decimals) | Input socket: Decimals |
| [i_value](#nodebpy.nodes.utilities.ValueToString.i_value) | Input socket: Value |
| [o_string](#nodebpy.nodes.utilities.ValueToString.o_string) | Output socket: String |