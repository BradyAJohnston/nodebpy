# nodes.converter { #nodebpy.nodes.converter }

`nodes.converter`



## Classes

| Name | Description |
| --- | --- |
| [AccumulateField](#nodebpy.nodes.converter.AccumulateField) | Add the values of an evaluated field together and output the running total for each element |
| [AlignRotationToVector](#nodebpy.nodes.converter.AlignRotationToVector) | Orient a rotation along the given direction |
| [AxesToRotation](#nodebpy.nodes.converter.AxesToRotation) | Create a rotation from a primary and (ideally orthogonal) secondary axis |
| [AxisAngleToRotation](#nodebpy.nodes.converter.AxisAngleToRotation) | Build a rotation from an axis and a rotation around that axis |
| [BitMath](#nodebpy.nodes.converter.BitMath) | Perform bitwise operations on 32-bit integers |
| [BooleanMath](#nodebpy.nodes.converter.BooleanMath) | Boolean Math node |
| [Clamp](#nodebpy.nodes.converter.Clamp) | Clamp a value between a minimum and a maximum |
| [CombineColor](#nodebpy.nodes.converter.CombineColor) | Combine four channels into a single color, based on a particular color model |
| [CombineMatrix](#nodebpy.nodes.converter.CombineMatrix) | Construct a 4x4 matrix from its individual values |
| [CombineTransform](#nodebpy.nodes.converter.CombineTransform) | Combine a translation vector, a rotation, and a scale vector into a transformation matrix |
| [CombineXYZ](#nodebpy.nodes.converter.CombineXYZ) | Create a vector from X, Y, and Z components |
| [Compare](#nodebpy.nodes.converter.Compare) | Perform a comparison operation on the two given inputs |
| [EulerToRotation](#nodebpy.nodes.converter.EulerToRotation) | Build a rotation from separate angles around each axis |
| [EvaluateAtIndex](#nodebpy.nodes.converter.EvaluateAtIndex) | Retrieve data of other elements in the context's geometry |
| [EvaluateOnDomain](#nodebpy.nodes.converter.EvaluateOnDomain) | Retrieve values from a field on a different domain besides the domain from the context |
| [FieldAverage](#nodebpy.nodes.converter.FieldAverage) | Calculate the mean and median of a given field |
| [FieldMinMax](#nodebpy.nodes.converter.FieldMinMax) | Calculate the minimum and maximum of a given field |
| [FieldVariance](#nodebpy.nodes.converter.FieldVariance) | Calculate the standard deviation and variance of a given field |
| [FindInString](#nodebpy.nodes.converter.FindInString) | Find the number of times a given string occurs in another string and the position of the first match |
| [FloatCurve](#nodebpy.nodes.converter.FloatCurve) | Map an input float to a curve and outputs a float value |
| [FloatToInteger](#nodebpy.nodes.converter.FloatToInteger) | Convert the given floating-point number to an integer, with a choice of methods |
| [FormatString](#nodebpy.nodes.converter.FormatString) | Insert values into a string using a Python and path template compatible formatting syntax |
| [HashValue](#nodebpy.nodes.converter.HashValue) | Generate a randomized integer using the given input value as a seed |
| [IndexOfNearest](#nodebpy.nodes.converter.IndexOfNearest) | Find the nearest element in a group. Similar to the "Sample Nearest" node |
| [IndexSwitch](#nodebpy.nodes.converter.IndexSwitch) | Node builder for the Index Switch node |
| [IntegerMath](#nodebpy.nodes.converter.IntegerMath) | Perform various math operations on the given integer inputs |
| [InvertMatrix](#nodebpy.nodes.converter.InvertMatrix) | Compute the inverse of the given matrix, if one exists |
| [InvertRotation](#nodebpy.nodes.converter.InvertRotation) | Compute the inverse of the given rotation |
| [JoinStrings](#nodebpy.nodes.converter.JoinStrings) | Combine any number of input strings |
| [MapRange](#nodebpy.nodes.converter.MapRange) | Remap a value from a range to a target range |
| [MatchString](#nodebpy.nodes.converter.MatchString) | Check if a given string exists within another string |
| [Math](#nodebpy.nodes.converter.Math) | Perform math operations |
| [MatrixDeterminant](#nodebpy.nodes.converter.MatrixDeterminant) | Compute the determinant of the given matrix |
| [MenuSwitch](#nodebpy.nodes.converter.MenuSwitch) | Node builder for the Index Switch node |
| [Mix](#nodebpy.nodes.converter.Mix) | Mix values by a factor |
| [MultiplyMatrices](#nodebpy.nodes.converter.MultiplyMatrices) | Perform a matrix multiplication on two input matrices |
| [PackUVIslands](#nodebpy.nodes.converter.PackUVIslands) | Scale islands of a UV map and move them so they fill the UV space as much as possible |
| [ProjectPoint](#nodebpy.nodes.converter.ProjectPoint) | Project a point using a matrix, using location, rotation, scale, and perspective divide |
| [QuaternionToRotation](#nodebpy.nodes.converter.QuaternionToRotation) | Build a rotation from quaternion components |
| [RandomValue](#nodebpy.nodes.converter.RandomValue) | Random Value node |
| [ReplaceString](#nodebpy.nodes.converter.ReplaceString) | Replace a given string segment with another |
| [RotateEuler](#nodebpy.nodes.converter.RotateEuler) | Apply a secondary Euler rotation to a given Euler rotation |
| [RotateRotation](#nodebpy.nodes.converter.RotateRotation) | Apply a secondary rotation to a given rotation value |
| [RotateVector](#nodebpy.nodes.converter.RotateVector) | Apply a rotation to a given vector |
| [RotationToAxisAngle](#nodebpy.nodes.converter.RotationToAxisAngle) | Convert a rotation to axis angle components |
| [RotationToEuler](#nodebpy.nodes.converter.RotationToEuler) | Convert a standard rotation value to an Euler rotation |
| [RotationToQuaternion](#nodebpy.nodes.converter.RotationToQuaternion) | Retrieve the quaternion components representing a rotation |
| [SeparateColor](#nodebpy.nodes.converter.SeparateColor) | Split a color into separate channels, based on a particular color model |
| [SeparateMatrix](#nodebpy.nodes.converter.SeparateMatrix) | Split a 4x4 matrix into its individual values |
| [SeparateTransform](#nodebpy.nodes.converter.SeparateTransform) | Split a transformation matrix into a translation vector, a rotation, and a scale vector |
| [SeparateXYZ](#nodebpy.nodes.converter.SeparateXYZ) | Split a vector into its X, Y, and Z components |
| [SliceString](#nodebpy.nodes.converter.SliceString) | Extract a string segment from a larger string |
| [StringLength](#nodebpy.nodes.converter.StringLength) | Output the number of characters in the given string |
| [StringToValue](#nodebpy.nodes.converter.StringToValue) | Derive a numeric value from a given string representation |
| [Switch](#nodebpy.nodes.converter.Switch) | Switch between two inputs |
| [TransformDirection](#nodebpy.nodes.converter.TransformDirection) | Apply a transformation matrix (excluding translation) to the given vector |
| [TransformPoint](#nodebpy.nodes.converter.TransformPoint) | Apply a transformation matrix to the given vector |
| [TransposeMatrix](#nodebpy.nodes.converter.TransposeMatrix) | Flip a matrix over its diagonal, turning columns into rows and vice-versa |
| [UVUnwrap](#nodebpy.nodes.converter.UVUnwrap) | Generate a UV map based on seam edges |
| [ValueToString](#nodebpy.nodes.converter.ValueToString) | Generate a string representation of the given input value |
| [VectorMath](#nodebpy.nodes.converter.VectorMath) | Perform vector math operation |

### AccumulateField { #nodebpy.nodes.converter.AccumulateField }

```python
nodes.converter.AccumulateField(
    value=1.0,
    group_index=0,
    data_type='FLOAT',
    domain='POINT',
    **kwargs,
)
```

Add the values of an evaluated field together and output the running total for each element

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.AccumulateField.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.converter.AccumulateField.i_value) | Input socket: Value |
| [o_leading](#nodebpy.nodes.converter.AccumulateField.o_leading) | Output socket: Leading |
| [o_total](#nodebpy.nodes.converter.AccumulateField.o_total) | Output socket: Total |
| [o_trailing](#nodebpy.nodes.converter.AccumulateField.o_trailing) | Output socket: Trailing |

### AlignRotationToVector { #nodebpy.nodes.converter.AlignRotationToVector }

```python
nodes.converter.AlignRotationToVector(
    rotation=(0.0, 0.0, 0.0),
    factor=1.0,
    vector=(0.0, 0.0, 1.0),
    axis='Z',
    pivot_axis='AUTO',
    **kwargs,
)
```

Orient a rotation along the given direction

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.converter.AlignRotationToVector.i_factor) | Input socket: Factor |
| [i_rotation](#nodebpy.nodes.converter.AlignRotationToVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.converter.AlignRotationToVector.i_vector) | Input socket: Vector |
| [o_rotation](#nodebpy.nodes.converter.AlignRotationToVector.o_rotation) | Output socket: Rotation |

### AxesToRotation { #nodebpy.nodes.converter.AxesToRotation }

```python
nodes.converter.AxesToRotation(
    primary_axis_vector=(0.0, 0.0, 1.0),
    secondary_axis_vector=(1.0, 0.0, 0.0),
    primary_axis='Z',
    secondary_axis='X',
    **kwargs,
)
```

Create a rotation from a primary and (ideally orthogonal) secondary axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_primary_axis](#nodebpy.nodes.converter.AxesToRotation.i_primary_axis) | Input socket: Primary Axis |
| [i_secondary_axis](#nodebpy.nodes.converter.AxesToRotation.i_secondary_axis) | Input socket: Secondary Axis |
| [o_rotation](#nodebpy.nodes.converter.AxesToRotation.o_rotation) | Output socket: Rotation |

### AxisAngleToRotation { #nodebpy.nodes.converter.AxisAngleToRotation }

```python
nodes.converter.AxisAngleToRotation(axis=(0.0, 0.0, 1.0), angle=0.0, **kwargs)
```

Build a rotation from an axis and a rotation around that axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_angle](#nodebpy.nodes.converter.AxisAngleToRotation.i_angle) | Input socket: Angle |
| [i_axis](#nodebpy.nodes.converter.AxisAngleToRotation.i_axis) | Input socket: Axis |
| [o_rotation](#nodebpy.nodes.converter.AxisAngleToRotation.o_rotation) | Output socket: Rotation |

### BitMath { #nodebpy.nodes.converter.BitMath }

```python
nodes.converter.BitMath(a=0, b=0, operation='AND', **kwargs)
```

Perform bitwise operations on 32-bit integers

#### Attributes

| Name | Description |
| --- | --- |
| [i_a](#nodebpy.nodes.converter.BitMath.i_a) | Input socket: A |
| [i_b](#nodebpy.nodes.converter.BitMath.i_b) | Input socket: B |
| [o_value](#nodebpy.nodes.converter.BitMath.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [l_and](#nodebpy.nodes.converter.BitMath.l_and) | Create Bit Math with operation 'And'. |
| [l_exclusive_or](#nodebpy.nodes.converter.BitMath.l_exclusive_or) | Create Bit Math with operation 'XOR'. |
| [l_not](#nodebpy.nodes.converter.BitMath.l_not) | Create Bit Math with operation 'Not'. |
| [l_or](#nodebpy.nodes.converter.BitMath.l_or) | Create Bit Math with operation 'Or'. |
| [rotate](#nodebpy.nodes.converter.BitMath.rotate) | Create Bit Math with operation 'Rotate'. |
| [shift](#nodebpy.nodes.converter.BitMath.shift) | Create Bit Math with operation 'Shift'. |

##### l_and { #nodebpy.nodes.converter.BitMath.l_and }

```python
nodes.converter.BitMath.l_and(a=0, b=0)
```

Create Bit Math with operation 'And'.

##### l_exclusive_or { #nodebpy.nodes.converter.BitMath.l_exclusive_or }

```python
nodes.converter.BitMath.l_exclusive_or(a=0, b=0)
```

Create Bit Math with operation 'XOR'.

##### l_not { #nodebpy.nodes.converter.BitMath.l_not }

```python
nodes.converter.BitMath.l_not(a=0)
```

Create Bit Math with operation 'Not'.

##### l_or { #nodebpy.nodes.converter.BitMath.l_or }

```python
nodes.converter.BitMath.l_or(a=0, b=0)
```

Create Bit Math with operation 'Or'.

##### rotate { #nodebpy.nodes.converter.BitMath.rotate }

```python
nodes.converter.BitMath.rotate(a=0, shift=0)
```

Create Bit Math with operation 'Rotate'.

##### shift { #nodebpy.nodes.converter.BitMath.shift }

```python
nodes.converter.BitMath.shift(a=0, shift=0)
```

Create Bit Math with operation 'Shift'.

### BooleanMath { #nodebpy.nodes.converter.BooleanMath }

```python
nodes.converter.BooleanMath(operation='AND', **kwargs)
```

Boolean Math node

#### Methods

| Name | Description |
| --- | --- |
| [l_and](#nodebpy.nodes.converter.BooleanMath.l_and) | Create Boolean Math with operation 'AND'. |
| [l_equal](#nodebpy.nodes.converter.BooleanMath.l_equal) | Create Boolean Math with operation 'XNOR'. |
| [l_imply](#nodebpy.nodes.converter.BooleanMath.l_imply) | Create Boolean Math with operation 'IMPLY'. |
| [l_nor](#nodebpy.nodes.converter.BooleanMath.l_nor) | Create Boolean Math with operation 'NOR'. |
| [l_not](#nodebpy.nodes.converter.BooleanMath.l_not) | Create Boolean Math with operation 'NOT'. |
| [l_not_and](#nodebpy.nodes.converter.BooleanMath.l_not_and) | Create Boolean Math with operation 'NAND'. |
| [l_not_equal](#nodebpy.nodes.converter.BooleanMath.l_not_equal) | Create Boolean Math with operation 'XOR'. |
| [l_or](#nodebpy.nodes.converter.BooleanMath.l_or) | Create Boolean Math with operation 'OR'. |
| [l_subtract](#nodebpy.nodes.converter.BooleanMath.l_subtract) | Create Boolean Math with operation 'NIMPLY'. |

##### l_and { #nodebpy.nodes.converter.BooleanMath.l_and }

```python
nodes.converter.BooleanMath.l_and(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'AND'.

##### l_equal { #nodebpy.nodes.converter.BooleanMath.l_equal }

```python
nodes.converter.BooleanMath.l_equal(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'XNOR'.

##### l_imply { #nodebpy.nodes.converter.BooleanMath.l_imply }

```python
nodes.converter.BooleanMath.l_imply(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'IMPLY'.

##### l_nor { #nodebpy.nodes.converter.BooleanMath.l_nor }

```python
nodes.converter.BooleanMath.l_nor(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'NOR'.

##### l_not { #nodebpy.nodes.converter.BooleanMath.l_not }

```python
nodes.converter.BooleanMath.l_not(boolean=False)
```

Create Boolean Math with operation 'NOT'.

##### l_not_and { #nodebpy.nodes.converter.BooleanMath.l_not_and }

```python
nodes.converter.BooleanMath.l_not_and(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'NAND'.

##### l_not_equal { #nodebpy.nodes.converter.BooleanMath.l_not_equal }

```python
nodes.converter.BooleanMath.l_not_equal(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'XOR'.

##### l_or { #nodebpy.nodes.converter.BooleanMath.l_or }

```python
nodes.converter.BooleanMath.l_or(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'OR'.

##### l_subtract { #nodebpy.nodes.converter.BooleanMath.l_subtract }

```python
nodes.converter.BooleanMath.l_subtract(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'NIMPLY'.

### Clamp { #nodebpy.nodes.converter.Clamp }

```python
nodes.converter.Clamp(value=1.0, min=0.0, max=1.0, *, clamp_type='MINMAX')
```

Clamp a value between a minimum and a maximum

#### Attributes

| Name | Description |
| --- | --- |
| [i_max](#nodebpy.nodes.converter.Clamp.i_max) | Input socket: Max |
| [i_min](#nodebpy.nodes.converter.Clamp.i_min) | Input socket: Min |
| [i_value](#nodebpy.nodes.converter.Clamp.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.converter.Clamp.o_result) | Output socket: Result |

### CombineColor { #nodebpy.nodes.converter.CombineColor }

```python
nodes.converter.CombineColor(
    red=0.0,
    green=0.0,
    blue=0.0,
    alpha=1.0,
    mode='RGB',
)
```

Combine four channels into a single color, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_alpha](#nodebpy.nodes.converter.CombineColor.i_alpha) | Input socket: Alpha |
| [i_blue](#nodebpy.nodes.converter.CombineColor.i_blue) | Input socket: Blue |
| [i_green](#nodebpy.nodes.converter.CombineColor.i_green) | Input socket: Green |
| [i_red](#nodebpy.nodes.converter.CombineColor.i_red) | Input socket: Red |
| [o_color](#nodebpy.nodes.converter.CombineColor.o_color) | Output socket: Color |

### CombineMatrix { #nodebpy.nodes.converter.CombineMatrix }

```python
nodes.converter.CombineMatrix(
    column_1_row_1=1.0,
    column_1_row_2=0.0,
    column_1_row_3=0.0,
    column_1_row_4=0.0,
    column_2_row_1=0.0,
    column_2_row_2=1.0,
    column_2_row_3=0.0,
    column_2_row_4=0.0,
    column_3_row_1=0.0,
    column_3_row_2=0.0,
    column_3_row_3=1.0,
    column_3_row_4=0.0,
    column_4_row_1=0.0,
    column_4_row_2=0.0,
    column_4_row_3=0.0,
    column_4_row_4=1.0,
    **kwargs,
)
```

Construct a 4x4 matrix from its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_column_1_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_1) | Input socket: Column 1 Row 1 |
| [i_column_1_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_2) | Input socket: Column 1 Row 2 |
| [i_column_1_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_3) | Input socket: Column 1 Row 3 |
| [i_column_1_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_4) | Input socket: Column 1 Row 4 |
| [i_column_2_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_1) | Input socket: Column 2 Row 1 |
| [i_column_2_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_2) | Input socket: Column 2 Row 2 |
| [i_column_2_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_3) | Input socket: Column 2 Row 3 |
| [i_column_2_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_4) | Input socket: Column 2 Row 4 |
| [i_column_3_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_1) | Input socket: Column 3 Row 1 |
| [i_column_3_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_2) | Input socket: Column 3 Row 2 |
| [i_column_3_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_3) | Input socket: Column 3 Row 3 |
| [i_column_3_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_4) | Input socket: Column 3 Row 4 |
| [i_column_4_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_1) | Input socket: Column 4 Row 1 |
| [i_column_4_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_2) | Input socket: Column 4 Row 2 |
| [i_column_4_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_3) | Input socket: Column 4 Row 3 |
| [i_column_4_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_4) | Input socket: Column 4 Row 4 |
| [o_matrix](#nodebpy.nodes.converter.CombineMatrix.o_matrix) | Output socket: Matrix |

### CombineTransform { #nodebpy.nodes.converter.CombineTransform }

```python
nodes.converter.CombineTransform(
    translation=(0.0, 0.0, 0.0),
    rotation=(0.0, 0.0, 0.0),
    scale=(1.0, 1.0, 1.0),
    **kwargs,
)
```

Combine a translation vector, a rotation, and a scale vector into a transformation matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.CombineTransform.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.converter.CombineTransform.i_scale) | Input socket: Scale |
| [i_translation](#nodebpy.nodes.converter.CombineTransform.i_translation) | Input socket: Translation |
| [o_transform](#nodebpy.nodes.converter.CombineTransform.o_transform) | Output socket: Transform |

### CombineXYZ { #nodebpy.nodes.converter.CombineXYZ }

```python
nodes.converter.CombineXYZ(x=0.0, y=0.0, z=0.0)
```

Create a vector from X, Y, and Z components

#### Attributes

| Name | Description |
| --- | --- |
| [i_x](#nodebpy.nodes.converter.CombineXYZ.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.converter.CombineXYZ.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.converter.CombineXYZ.i_z) | Input socket: Z |
| [o_vector](#nodebpy.nodes.converter.CombineXYZ.o_vector) | Output socket: Vector |

### Compare { #nodebpy.nodes.converter.Compare }

```python
nodes.converter.Compare(operation='GREATER_THAN', data_type='FLOAT', **kwargs)
```

Perform a comparison operation on the two given inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_a](#nodebpy.nodes.converter.Compare.i_a) | Input socket: A |
| [i_b](#nodebpy.nodes.converter.Compare.i_b) | Input socket: B |
| [o_result](#nodebpy.nodes.converter.Compare.o_result) | Output socket: Result |

#### Methods

| Name | Description |
| --- | --- |
| [color](#nodebpy.nodes.converter.Compare.color) | Create Compare with operation 'Color'. |
| [string](#nodebpy.nodes.converter.Compare.string) | Create Compare with operation 'String'. |

##### color { #nodebpy.nodes.converter.Compare.color }

```python
nodes.converter.Compare.color(
    a=None,
    b=None,
    operation='EQUAL',
    *,
    epsilon=None,
)
```

Create Compare with operation 'Color'.

##### string { #nodebpy.nodes.converter.Compare.string }

```python
nodes.converter.Compare.string(a, b)
```

Create Compare with operation 'String'.

### EulerToRotation { #nodebpy.nodes.converter.EulerToRotation }

```python
nodes.converter.EulerToRotation(euler=(0.0, 0.0, 0.0))
```

Build a rotation from separate angles around each axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_euler](#nodebpy.nodes.converter.EulerToRotation.i_euler) | Input socket: Euler |
| [o_rotation](#nodebpy.nodes.converter.EulerToRotation.o_rotation) | Output socket: Rotation |

### EvaluateAtIndex { #nodebpy.nodes.converter.EvaluateAtIndex }

```python
nodes.converter.EvaluateAtIndex(
    value=None,
    index=0,
    *,
    domain='POINT',
    data_type='FLOAT',
    **kwargs,
)
```

Retrieve data of other elements in the context's geometry

#### Attributes

| Name | Description |
| --- | --- |
| [i_index](#nodebpy.nodes.converter.EvaluateAtIndex.i_index) | Input socket: Index |
| [i_value](#nodebpy.nodes.converter.EvaluateAtIndex.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.converter.EvaluateAtIndex.o_value) | Output socket: Value |

### EvaluateOnDomain { #nodebpy.nodes.converter.EvaluateOnDomain }

```python
nodes.converter.EvaluateOnDomain(
    value=None,
    *,
    domain='POINT',
    data_type='FLOAT',
)
```

Retrieve values from a field on a different domain besides the domain from the context

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.converter.EvaluateOnDomain.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.converter.EvaluateOnDomain.o_value) | Output socket: Value |

### FieldAverage { #nodebpy.nodes.converter.FieldAverage }

```python
nodes.converter.FieldAverage(
    value=None,
    group_index=0,
    *,
    data_type='FLOAT',
    domain='POINT',
)
```

Calculate the mean and median of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.FieldAverage.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.converter.FieldAverage.i_value) | Input socket: Value |
| [o_mean](#nodebpy.nodes.converter.FieldAverage.o_mean) | Output socket: Mean |
| [o_median](#nodebpy.nodes.converter.FieldAverage.o_median) | Output socket: Median |

### FieldMinMax { #nodebpy.nodes.converter.FieldMinMax }

```python
nodes.converter.FieldMinMax(
    value=None,
    group_index=None,
    *,
    data_type='FLOAT',
    domain='POINT',
)
```

Calculate the minimum and maximum of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.FieldMinMax.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.converter.FieldMinMax.i_value) | Input socket: Value |
| [o_max](#nodebpy.nodes.converter.FieldMinMax.o_max) | Output socket: Max |
| [o_min](#nodebpy.nodes.converter.FieldMinMax.o_min) | Output socket: Min |

### FieldVariance { #nodebpy.nodes.converter.FieldVariance }

```python
nodes.converter.FieldVariance(
    value=None,
    group_index=None,
    *,
    data_type='FLOAT',
    domain='POINT',
)
```

Calculate the standard deviation and variance of a given field

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.FieldVariance.i_group_id) | Input socket: Group ID |
| [i_value](#nodebpy.nodes.converter.FieldVariance.i_value) | Input socket: Value |
| [o_standard_deviation](#nodebpy.nodes.converter.FieldVariance.o_standard_deviation) | Output socket: Standard Deviation |
| [o_variance](#nodebpy.nodes.converter.FieldVariance.o_variance) | Output socket: Variance |

### FindInString { #nodebpy.nodes.converter.FindInString }

```python
nodes.converter.FindInString(string='', search='')
```

Find the number of times a given string occurs in another string and the position of the first match

#### Attributes

| Name | Description |
| --- | --- |
| [i_search](#nodebpy.nodes.converter.FindInString.i_search) | Input socket: Search |
| [i_string](#nodebpy.nodes.converter.FindInString.i_string) | Input socket: String |
| [o_count](#nodebpy.nodes.converter.FindInString.o_count) | Output socket: Count |
| [o_first_found](#nodebpy.nodes.converter.FindInString.o_first_found) | Output socket: First Found |

### FloatCurve { #nodebpy.nodes.converter.FloatCurve }

```python
nodes.converter.FloatCurve(factor=1.0, value=1.0)
```

Map an input float to a curve and outputs a float value

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.converter.FloatCurve.i_factor) | Input socket: Factor |
| [i_value](#nodebpy.nodes.converter.FloatCurve.i_value) | Input socket: Value |
| [o_value](#nodebpy.nodes.converter.FloatCurve.o_value) | Output socket: Value |

### FloatToInteger { #nodebpy.nodes.converter.FloatToInteger }

```python
nodes.converter.FloatToInteger(float=0.0, rounding_mode='ROUND')
```

Convert the given floating-point number to an integer, with a choice of methods

#### Attributes

| Name | Description |
| --- | --- |
| [i_float](#nodebpy.nodes.converter.FloatToInteger.i_float) | Input socket: Float |
| [o_integer](#nodebpy.nodes.converter.FloatToInteger.o_integer) | Output socket: Integer |

### FormatString { #nodebpy.nodes.converter.FormatString }

```python
nodes.converter.FormatString(*args, format='', **kwargs)
```

Insert values into a string using a Python and path template compatible formatting syntax

#### Attributes

| Name | Description |
| --- | --- |
| [i_format](#nodebpy.nodes.converter.FormatString.i_format) | Input socket: Format |
| [i_input_socket](#nodebpy.nodes.converter.FormatString.i_input_socket) | Input socket: |
| [items](#nodebpy.nodes.converter.FormatString.items) | Input sockets: |
| [o_string](#nodebpy.nodes.converter.FormatString.o_string) | Output socket: String |

### HashValue { #nodebpy.nodes.converter.HashValue }

```python
nodes.converter.HashValue(value=None, seed=0, *, data_type='INT')
```

Generate a randomized integer using the given input value as a seed

#### Attributes

| Name | Description |
| --- | --- |
| [i_seed](#nodebpy.nodes.converter.HashValue.i_seed) | Input socket: Seed |
| [i_value](#nodebpy.nodes.converter.HashValue.i_value) | Input socket: Value |
| [o_hash](#nodebpy.nodes.converter.HashValue.o_hash) | Output socket: Hash |

### IndexOfNearest { #nodebpy.nodes.converter.IndexOfNearest }

```python
nodes.converter.IndexOfNearest(position=None, group_id=None)
```

Find the nearest element in a group. Similar to the "Sample Nearest" node

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.IndexOfNearest.i_group_id) | Input socket: Group ID |
| [i_position](#nodebpy.nodes.converter.IndexOfNearest.i_position) | Input socket: Position |
| [o_has_neighbor](#nodebpy.nodes.converter.IndexOfNearest.o_has_neighbor) | Output socket: Has Neighbor |
| [o_index](#nodebpy.nodes.converter.IndexOfNearest.o_index) | Output socket: Index |

### IndexSwitch { #nodebpy.nodes.converter.IndexSwitch }

```python
nodes.converter.IndexSwitch(*args, index=0, data_type='FLOAT')
```

Node builder for the Index Switch node

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.IndexSwitch.data_type) | Input socket: Data Type |
| [i_index](#nodebpy.nodes.converter.IndexSwitch.i_index) | Input socket: Index |
| [inputs](#nodebpy.nodes.converter.IndexSwitch.inputs) | Input sockets |
| [o_output](#nodebpy.nodes.converter.IndexSwitch.o_output) | Output socket: Output |

### IntegerMath { #nodebpy.nodes.converter.IntegerMath }

```python
nodes.converter.IntegerMath(operation='ADD', **kwargs)
```

Perform various math operations on the given integer inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.converter.IntegerMath.i_value) | Input socket: Value |
| [i_value_001](#nodebpy.nodes.converter.IntegerMath.i_value_001) | Input socket: Value |
| [i_value_002](#nodebpy.nodes.converter.IntegerMath.i_value_002) | Input socket: Value |
| [o_value](#nodebpy.nodes.converter.IntegerMath.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.converter.IntegerMath.absolute) | Create Integer Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.converter.IntegerMath.add) | Create Integer Math with operation 'Add'. |
| [divide](#nodebpy.nodes.converter.IntegerMath.divide) | Create Integer Math with operation 'Divide'. |
| [divide_ceil](#nodebpy.nodes.converter.IntegerMath.divide_ceil) | Create Integer Math with operation 'Divide Ceiling'. |
| [divide_floor](#nodebpy.nodes.converter.IntegerMath.divide_floor) | Create Integer Math with operation 'Divide Floor'. |
| [divide_round](#nodebpy.nodes.converter.IntegerMath.divide_round) | Create Integer Math with operation 'Divide Round'. |
| [floored_modulo](#nodebpy.nodes.converter.IntegerMath.floored_modulo) | Create Integer Math with operation 'Floored Modulo'. |
| [greatest_common_divisor](#nodebpy.nodes.converter.IntegerMath.greatest_common_divisor) | Create Integer Math with operation 'Greatest Common Divisor'. |
| [least_common_multiple](#nodebpy.nodes.converter.IntegerMath.least_common_multiple) | Create Integer Math with operation 'Least Common Multiple'. |
| [maximum](#nodebpy.nodes.converter.IntegerMath.maximum) | Create Integer Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.converter.IntegerMath.minimum) | Create Integer Math with operation 'Minimum'. |
| [modulo](#nodebpy.nodes.converter.IntegerMath.modulo) | Create Integer Math with operation 'Modulo'. |
| [multiply](#nodebpy.nodes.converter.IntegerMath.multiply) | Create Integer Math with operation 'Multiply'. |
| [multiplyadd](#nodebpy.nodes.converter.IntegerMath.multiplyadd) | Create Integer Math with operation 'Multiply Add'. |
| [negate](#nodebpy.nodes.converter.IntegerMath.negate) | Create Integer Math with operation 'Negate'. |
| [power](#nodebpy.nodes.converter.IntegerMath.power) | Create Integer Math with operation 'Power'. |
| [sign](#nodebpy.nodes.converter.IntegerMath.sign) | Create Integer Math with operation 'Sign'. |
| [subtract](#nodebpy.nodes.converter.IntegerMath.subtract) | Create Integer Math with operation 'Subtract'. |

##### absolute { #nodebpy.nodes.converter.IntegerMath.absolute }

```python
nodes.converter.IntegerMath.absolute(value=0)
```

Create Integer Math with operation 'Absolute'.

##### add { #nodebpy.nodes.converter.IntegerMath.add }

```python
nodes.converter.IntegerMath.add(a=0, b=0)
```

Create Integer Math with operation 'Add'.

##### divide { #nodebpy.nodes.converter.IntegerMath.divide }

```python
nodes.converter.IntegerMath.divide(a=0, value_001=0)
```

Create Integer Math with operation 'Divide'.

##### divide_ceil { #nodebpy.nodes.converter.IntegerMath.divide_ceil }

```python
nodes.converter.IntegerMath.divide_ceil(a=0, b=0)
```

Create Integer Math with operation 'Divide Ceiling'.

##### divide_floor { #nodebpy.nodes.converter.IntegerMath.divide_floor }

```python
nodes.converter.IntegerMath.divide_floor(a=0, b=0)
```

Create Integer Math with operation 'Divide Floor'.

##### divide_round { #nodebpy.nodes.converter.IntegerMath.divide_round }

```python
nodes.converter.IntegerMath.divide_round(a=0, b=0)
```

Create Integer Math with operation 'Divide Round'.

##### floored_modulo { #nodebpy.nodes.converter.IntegerMath.floored_modulo }

```python
nodes.converter.IntegerMath.floored_modulo(a=0, b=0)
```

Create Integer Math with operation 'Floored Modulo'.

##### greatest_common_divisor { #nodebpy.nodes.converter.IntegerMath.greatest_common_divisor }

```python
nodes.converter.IntegerMath.greatest_common_divisor(a=0, b=0)
```

Create Integer Math with operation 'Greatest Common Divisor'.

##### least_common_multiple { #nodebpy.nodes.converter.IntegerMath.least_common_multiple }

```python
nodes.converter.IntegerMath.least_common_multiple(a=0, b=0)
```

Create Integer Math with operation 'Least Common Multiple'.

##### maximum { #nodebpy.nodes.converter.IntegerMath.maximum }

```python
nodes.converter.IntegerMath.maximum(a=0, b=0)
```

Create Integer Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.converter.IntegerMath.minimum }

```python
nodes.converter.IntegerMath.minimum(a=0, b=0)
```

Create Integer Math with operation 'Minimum'.

##### modulo { #nodebpy.nodes.converter.IntegerMath.modulo }

```python
nodes.converter.IntegerMath.modulo(a=0, b=0)
```

Create Integer Math with operation 'Modulo'.

##### multiply { #nodebpy.nodes.converter.IntegerMath.multiply }

```python
nodes.converter.IntegerMath.multiply(a=0, value_001=0)
```

Create Integer Math with operation 'Multiply'.

##### multiplyadd { #nodebpy.nodes.converter.IntegerMath.multiplyadd }

```python
nodes.converter.IntegerMath.multiplyadd(value=0, multiplier=0, addend=0)
```

Create Integer Math with operation 'Multiply Add'.

##### negate { #nodebpy.nodes.converter.IntegerMath.negate }

```python
nodes.converter.IntegerMath.negate(value=0)
```

Create Integer Math with operation 'Negate'.

##### power { #nodebpy.nodes.converter.IntegerMath.power }

```python
nodes.converter.IntegerMath.power(base=0, exponent=0)
```

Create Integer Math with operation 'Power'.

##### sign { #nodebpy.nodes.converter.IntegerMath.sign }

```python
nodes.converter.IntegerMath.sign(value=0)
```

Create Integer Math with operation 'Sign'.

##### subtract { #nodebpy.nodes.converter.IntegerMath.subtract }

```python
nodes.converter.IntegerMath.subtract(a=0, b=0)
```

Create Integer Math with operation 'Subtract'.

### InvertMatrix { #nodebpy.nodes.converter.InvertMatrix }

```python
nodes.converter.InvertMatrix(matrix=None)
```

Compute the inverse of the given matrix, if one exists

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.InvertMatrix.i_matrix) | Input socket: Matrix |
| [o_invertible](#nodebpy.nodes.converter.InvertMatrix.o_invertible) | Output socket: Invertible |
| [o_matrix](#nodebpy.nodes.converter.InvertMatrix.o_matrix) | Output socket: Matrix |

### InvertRotation { #nodebpy.nodes.converter.InvertRotation }

```python
nodes.converter.InvertRotation(rotation=(0.0, 0.0, 0.0))
```

Compute the inverse of the given rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.InvertRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.converter.InvertRotation.o_rotation) | Output socket: Rotation |

### JoinStrings { #nodebpy.nodes.converter.JoinStrings }

```python
nodes.converter.JoinStrings(*args, delimiter='')
```

Combine any number of input strings

#### Attributes

| Name | Description |
| --- | --- |
| [i_delimiter](#nodebpy.nodes.converter.JoinStrings.i_delimiter) | Input socket: Delimiter |
| [i_strings](#nodebpy.nodes.converter.JoinStrings.i_strings) | Input socket: Strings |
| [o_string](#nodebpy.nodes.converter.JoinStrings.o_string) | Output socket: String |

### MapRange { #nodebpy.nodes.converter.MapRange }

```python
nodes.converter.MapRange(
    interpolation_type='LINEAR',
    data_type='FLOAT',
    clamp=False,
    **kwargs,
)
```

Remap a value from a range to a target range

#### Attributes

| Name | Description |
| --- | --- |
| [i_from_max](#nodebpy.nodes.converter.MapRange.i_from_max) | Input socket: From Max |
| [i_from_min](#nodebpy.nodes.converter.MapRange.i_from_min) | Input socket: From Min |
| [i_steps](#nodebpy.nodes.converter.MapRange.i_steps) | Input socket: Steps |
| [i_to_max](#nodebpy.nodes.converter.MapRange.i_to_max) | Input socket: To Max |
| [i_to_min](#nodebpy.nodes.converter.MapRange.i_to_min) | Input socket: To Min |
| [i_value](#nodebpy.nodes.converter.MapRange.i_value) | Input socket: Value |
| [o_result](#nodebpy.nodes.converter.MapRange.o_result) | Output socket: Result |

### MatchString { #nodebpy.nodes.converter.MatchString }

```python
nodes.converter.MatchString(string='', operation='Starts With', key='')
```

Check if a given string exists within another string

#### Attributes

| Name | Description |
| --- | --- |
| [i_key](#nodebpy.nodes.converter.MatchString.i_key) | Input socket: Key |
| [i_operation](#nodebpy.nodes.converter.MatchString.i_operation) | Input socket: Operation |
| [i_string](#nodebpy.nodes.converter.MatchString.i_string) | Input socket: String |
| [o_result](#nodebpy.nodes.converter.MatchString.o_result) | Output socket: Result |

### Math { #nodebpy.nodes.converter.Math }

```python
nodes.converter.Math(operation='ADD', use_clamp=False, **kwargs)
```

Perform math operations

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.converter.Math.absolute) | Create Math with operation `abs(value)`. |
| [add](#nodebpy.nodes.converter.Math.add) | Create Math with operation of `a + b`. |
| [arccosine](#nodebpy.nodes.converter.Math.arccosine) | Create Math with operation 'arccos(value)'. |
| [arcsine](#nodebpy.nodes.converter.Math.arcsine) | Create Math with operation `arcsin(value)`. |
| [arctan2](#nodebpy.nodes.converter.Math.arctan2) | Create Math with operation 'arctan(a / b)'. |
| [arctangent](#nodebpy.nodes.converter.Math.arctangent) | Create Math with operation 'arctan(value)'. |
| [ceil](#nodebpy.nodes.converter.Math.ceil) | The smallest integer greater than or equal to `value` |
| [compare](#nodebpy.nodes.converter.Math.compare) | Create Math with operation `compare(a, b, epsilon)` returning -1, 0, or 1. |
| [cosh](#nodebpy.nodes.converter.Math.cosh) | Create Math with operation `cosh(value)`. |
| [cosine](#nodebpy.nodes.converter.Math.cosine) | Create Math with operation 'cos(value)'. |
| [degrees](#nodebpy.nodes.converter.Math.degrees) | Create Math with operation 'To Degrees'. |
| [divide](#nodebpy.nodes.converter.Math.divide) | Create Math with operation of `a / b`. |
| [exponent](#nodebpy.nodes.converter.Math.exponent) | Create Math with operation `exp(value)`. |
| [floor](#nodebpy.nodes.converter.Math.floor) | The largest integer smaller than or equal to `value` |
| [floored_modulo](#nodebpy.nodes.converter.Math.floored_modulo) | The remained of floored division |
| [fraction](#nodebpy.nodes.converter.Math.fraction) | The fractional part of `value` |
| [greater_than](#nodebpy.nodes.converter.Math.greater_than) | Create Math with operation `value > threshold` returning 1 or 0. |
| [inverse_sqrt](#nodebpy.nodes.converter.Math.inverse_sqrt) | Create Math with operation `inverse_sqrt(value)`. |
| [less_than](#nodebpy.nodes.converter.Math.less_than) | Create Math with operation `value < threshold` returning 1 or 0. |
| [logarithm](#nodebpy.nodes.converter.Math.logarithm) | Create Math with operation `log(value, base)`. |
| [maximum](#nodebpy.nodes.converter.Math.maximum) | Create Math with operation `max(a, b)`. |
| [minimum](#nodebpy.nodes.converter.Math.minimum) | Create Math with operation `min(a, b)`. |
| [multiply](#nodebpy.nodes.converter.Math.multiply) | Create Math with operation of `a * b`. |
| [multiply_add](#nodebpy.nodes.converter.Math.multiply_add) | Create Math with operation `a * b + c`. |
| [ping_pong](#nodebpy.nodes.converter.Math.ping_pong) | Wraps a value and reverses every other cycle |
| [power](#nodebpy.nodes.converter.Math.power) | Create Math with operation `base ** exponent`. |
| [radians](#nodebpy.nodes.converter.Math.radians) | Create Math with operation `radians(degrees)`. |
| [round](#nodebpy.nodes.converter.Math.round) | Round A to the nearest integer. Round up if 0.5 or greater. |
| [sign](#nodebpy.nodes.converter.Math.sign) | Create Math with operation `sign(value)` returning -1, 0, or 1. |
| [sine](#nodebpy.nodes.converter.Math.sine) | Create Math with operation 'sin(value)'. |
| [sinh](#nodebpy.nodes.converter.Math.sinh) | Create Math with operation `sinh(value)`. |
| [smooth_max_](#nodebpy.nodes.converter.Math.smooth_max_) | Create Math with operation `smooth_max(a, b, distance)`. |
| [smooth_min](#nodebpy.nodes.converter.Math.smooth_min) | Create Math with operation `smooth_min(a, b, distance)`. |
| [snap](#nodebpy.nodes.converter.Math.snap) | Snap to increment of `snap(value, increment)` |
| [sqrt](#nodebpy.nodes.converter.Math.sqrt) | Create Math with operation `sqrt(value)`. |
| [subtract](#nodebpy.nodes.converter.Math.subtract) | Create Math with operation of `a - b`. |
| [tangent](#nodebpy.nodes.converter.Math.tangent) | Create Math with operation 'tan(value)'. |
| [tanh](#nodebpy.nodes.converter.Math.tanh) | Create Math with operation `tanh(value)`. |
| [truncate](#nodebpy.nodes.converter.Math.truncate) | The integer part of `value` removing the fractional part |
| [truncated_modulo](#nodebpy.nodes.converter.Math.truncated_modulo) | The remained of truncated division using fmod(a, b) |
| [wrap](#nodebpy.nodes.converter.Math.wrap) | Wrap value to range, wrap(value, max, min) |

##### absolute { #nodebpy.nodes.converter.Math.absolute }

```python
nodes.converter.Math.absolute(value=0.5)
```

Create Math with operation `abs(value)`.

##### add { #nodebpy.nodes.converter.Math.add }

```python
nodes.converter.Math.add(a=0.5, b=0.5)
```

Create Math with operation of `a + b`.

##### arccosine { #nodebpy.nodes.converter.Math.arccosine }

```python
nodes.converter.Math.arccosine(value=0.5)
```

Create Math with operation 'arccos(value)'.

##### arcsine { #nodebpy.nodes.converter.Math.arcsine }

```python
nodes.converter.Math.arcsine(value=0.5)
```

Create Math with operation `arcsin(value)`.

##### arctan2 { #nodebpy.nodes.converter.Math.arctan2 }

```python
nodes.converter.Math.arctan2(a=0.5, b=0.5)
```

Create Math with operation 'arctan(a / b)'.

##### arctangent { #nodebpy.nodes.converter.Math.arctangent }

```python
nodes.converter.Math.arctangent(value=0.5)
```

Create Math with operation 'arctan(value)'.

##### ceil { #nodebpy.nodes.converter.Math.ceil }

```python
nodes.converter.Math.ceil(value=0.5)
```

The smallest integer greater than or equal to `value`

##### compare { #nodebpy.nodes.converter.Math.compare }

```python
nodes.converter.Math.compare(a=0.5, b=0.5, epsilon=0.5)
```

Create Math with operation `compare(a, b, epsilon)` returning -1, 0, or 1.

##### cosh { #nodebpy.nodes.converter.Math.cosh }

```python
nodes.converter.Math.cosh(value=0.5)
```

Create Math with operation `cosh(value)`.

##### cosine { #nodebpy.nodes.converter.Math.cosine }

```python
nodes.converter.Math.cosine(value=0.5)
```

Create Math with operation 'cos(value)'.

##### degrees { #nodebpy.nodes.converter.Math.degrees }

```python
nodes.converter.Math.degrees(radians=0.5)
```

Create Math with operation 'To Degrees'.

##### divide { #nodebpy.nodes.converter.Math.divide }

```python
nodes.converter.Math.divide(a=0.5, b=0.5)
```

Create Math with operation of `a / b`.

##### exponent { #nodebpy.nodes.converter.Math.exponent }

```python
nodes.converter.Math.exponent(value=0.5)
```

Create Math with operation `exp(value)`.

##### floor { #nodebpy.nodes.converter.Math.floor }

```python
nodes.converter.Math.floor(value=0.5)
```

The largest integer smaller than or equal to `value`

##### floored_modulo { #nodebpy.nodes.converter.Math.floored_modulo }

```python
nodes.converter.Math.floored_modulo(a=0.5, b=0.5)
```

The remained of floored division

##### fraction { #nodebpy.nodes.converter.Math.fraction }

```python
nodes.converter.Math.fraction(value=0.5)
```

The fractional part of `value`

##### greater_than { #nodebpy.nodes.converter.Math.greater_than }

```python
nodes.converter.Math.greater_than(value=0.5, threshold=0.5)
```

Create Math with operation `value > threshold` returning 1 or 0.

##### inverse_sqrt { #nodebpy.nodes.converter.Math.inverse_sqrt }

```python
nodes.converter.Math.inverse_sqrt(value=0.5)
```

Create Math with operation `inverse_sqrt(value)`.

##### less_than { #nodebpy.nodes.converter.Math.less_than }

```python
nodes.converter.Math.less_than(value=0.5, threshold=0.5)
```

Create Math with operation `value < threshold` returning 1 or 0.

##### logarithm { #nodebpy.nodes.converter.Math.logarithm }

```python
nodes.converter.Math.logarithm(value=0.5, base=0.5)
```

Create Math with operation `log(value, base)`.

##### maximum { #nodebpy.nodes.converter.Math.maximum }

```python
nodes.converter.Math.maximum(a=0.5, b=0.5)
```

Create Math with operation `max(a, b)`.

##### minimum { #nodebpy.nodes.converter.Math.minimum }

```python
nodes.converter.Math.minimum(a=0.5, b=0.5)
```

Create Math with operation `min(a, b)`.

##### multiply { #nodebpy.nodes.converter.Math.multiply }

```python
nodes.converter.Math.multiply(a=0.5, b=0.5)
```

Create Math with operation of `a * b`.

##### multiply_add { #nodebpy.nodes.converter.Math.multiply_add }

```python
nodes.converter.Math.multiply_add(a=0.5, b=0.5, c=0.5)
```

Create Math with operation `a * b + c`.

##### ping_pong { #nodebpy.nodes.converter.Math.ping_pong }

```python
nodes.converter.Math.ping_pong(value=0.5, scale=0.5)
```

Wraps a value and reverses every other cycle

##### power { #nodebpy.nodes.converter.Math.power }

```python
nodes.converter.Math.power(base=0.5, exponent=0.5)
```

Create Math with operation `base ** exponent`.

##### radians { #nodebpy.nodes.converter.Math.radians }

```python
nodes.converter.Math.radians(degrees=0.5)
```

Create Math with operation `radians(degrees)`.

##### round { #nodebpy.nodes.converter.Math.round }

```python
nodes.converter.Math.round(value=0.5)
```

Round A to the nearest integer. Round up if 0.5 or greater.

##### sign { #nodebpy.nodes.converter.Math.sign }

```python
nodes.converter.Math.sign(value=0.5)
```

Create Math with operation `sign(value)` returning -1, 0, or 1.

##### sine { #nodebpy.nodes.converter.Math.sine }

```python
nodes.converter.Math.sine(value=0.5)
```

Create Math with operation 'sin(value)'.

##### sinh { #nodebpy.nodes.converter.Math.sinh }

```python
nodes.converter.Math.sinh(value=0.5)
```

Create Math with operation `sinh(value)`.

##### smooth_max_ { #nodebpy.nodes.converter.Math.smooth_max_ }

```python
nodes.converter.Math.smooth_max_(a=0.5, b=0.5, distance=0.5)
```

Create Math with operation `smooth_max(a, b, distance)`.

##### smooth_min { #nodebpy.nodes.converter.Math.smooth_min }

```python
nodes.converter.Math.smooth_min(a=0.5, b=0.5, distance=0.5)
```

Create Math with operation `smooth_min(a, b, distance)`.

##### snap { #nodebpy.nodes.converter.Math.snap }

```python
nodes.converter.Math.snap(value=0.5, increment=0.5)
```

Snap to increment of `snap(value, increment)`

##### sqrt { #nodebpy.nodes.converter.Math.sqrt }

```python
nodes.converter.Math.sqrt(value=0.5)
```

Create Math with operation `sqrt(value)`.

##### subtract { #nodebpy.nodes.converter.Math.subtract }

```python
nodes.converter.Math.subtract(a=0.5, b=0.5)
```

Create Math with operation of `a - b`.

##### tangent { #nodebpy.nodes.converter.Math.tangent }

```python
nodes.converter.Math.tangent(value=0.5)
```

Create Math with operation 'tan(value)'.

##### tanh { #nodebpy.nodes.converter.Math.tanh }

```python
nodes.converter.Math.tanh(value=0.5)
```

Create Math with operation `tanh(value)`.

##### truncate { #nodebpy.nodes.converter.Math.truncate }

```python
nodes.converter.Math.truncate(value=0.5)
```

The integer part of `value` removing the fractional part

##### truncated_modulo { #nodebpy.nodes.converter.Math.truncated_modulo }

```python
nodes.converter.Math.truncated_modulo(a=0.5, b=0.5)
```

The remained of truncated division using fmod(a, b)

##### wrap { #nodebpy.nodes.converter.Math.wrap }

```python
nodes.converter.Math.wrap(value=0.5, max=0.5, min=0.5)
```

Wrap value to range, wrap(value, max, min)

### MatrixDeterminant { #nodebpy.nodes.converter.MatrixDeterminant }

```python
nodes.converter.MatrixDeterminant(matrix=None)
```

Compute the determinant of the given matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.MatrixDeterminant.i_matrix) | Input socket: Matrix |
| [o_determinant](#nodebpy.nodes.converter.MatrixDeterminant.o_determinant) | Output socket: Determinant |

### MenuSwitch { #nodebpy.nodes.converter.MenuSwitch }

```python
nodes.converter.MenuSwitch(*args, menu=None, data_type='FLOAT', **kwargs)
```

Node builder for the Index Switch node

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.MenuSwitch.data_type) | Input socket: Data Type |
| [i_menu](#nodebpy.nodes.converter.MenuSwitch.i_menu) | Input socket: Menu |
| [inputs](#nodebpy.nodes.converter.MenuSwitch.inputs) | Input sockets |
| [o_output](#nodebpy.nodes.converter.MenuSwitch.o_output) | Output socket: Output |
| [outputs](#nodebpy.nodes.converter.MenuSwitch.outputs) | Input sockets |

### Mix { #nodebpy.nodes.converter.Mix }

```python
nodes.converter.Mix(data_type='FLOAT', **kwargs)
```

Mix values by a factor

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.converter.Mix.i_factor) | Input socket: Factor |
| [i_value_a](#nodebpy.nodes.converter.Mix.i_value_a) | Input socket: Value A |
| [i_value_b](#nodebpy.nodes.converter.Mix.i_value_b) | Input socket: Value B |
| [o_result](#nodebpy.nodes.converter.Mix.o_result) | Output socket: Result |

### MultiplyMatrices { #nodebpy.nodes.converter.MultiplyMatrices }

```python
nodes.converter.MultiplyMatrices(matrix=None, matrix_001=None)
```

Perform a matrix multiplication on two input matrices

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.MultiplyMatrices.i_matrix) | Input socket: Matrix |
| [i_matrix_001](#nodebpy.nodes.converter.MultiplyMatrices.i_matrix_001) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.converter.MultiplyMatrices.o_matrix) | Output socket: Matrix |

### PackUVIslands { #nodebpy.nodes.converter.PackUVIslands }

```python
nodes.converter.PackUVIslands(
    uv=(0.0, 0.0, 0.0),
    selection=True,
    margin=0.001,
    rotate=True,
    method='Bounding Box',
)
```

Scale islands of a UV map and move them so they fill the UV space as much as possible

#### Attributes

| Name | Description |
| --- | --- |
| [i_margin](#nodebpy.nodes.converter.PackUVIslands.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.converter.PackUVIslands.i_method) | Input socket: Method |
| [i_rotate](#nodebpy.nodes.converter.PackUVIslands.i_rotate) | Input socket: Rotate |
| [i_selection](#nodebpy.nodes.converter.PackUVIslands.i_selection) | Input socket: Selection |
| [i_uv](#nodebpy.nodes.converter.PackUVIslands.i_uv) | Input socket: UV |
| [o_uv](#nodebpy.nodes.converter.PackUVIslands.o_uv) | Output socket: UV |

### ProjectPoint { #nodebpy.nodes.converter.ProjectPoint }

```python
nodes.converter.ProjectPoint(vector=(0.0, 0.0, 0.0), transform=None)
```

Project a point using a matrix, using location, rotation, scale, and perspective divide

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.ProjectPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.converter.ProjectPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.converter.ProjectPoint.o_vector) | Output socket: Vector |

### QuaternionToRotation { #nodebpy.nodes.converter.QuaternionToRotation }

```python
nodes.converter.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0)
```

Build a rotation from quaternion components

#### Attributes

| Name | Description |
| --- | --- |
| [i_w](#nodebpy.nodes.converter.QuaternionToRotation.i_w) | Input socket: W |
| [i_x](#nodebpy.nodes.converter.QuaternionToRotation.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.converter.QuaternionToRotation.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.converter.QuaternionToRotation.i_z) | Input socket: Z |
| [o_rotation](#nodebpy.nodes.converter.QuaternionToRotation.o_rotation) | Output socket: Rotation |

### RandomValue { #nodebpy.nodes.converter.RandomValue }

```python
nodes.converter.RandomValue(data_type, id=None, seed=0, **kwargs)
```

Random Value node

#### Attributes

| Name | Description |
| --- | --- |
| [o_value](#nodebpy.nodes.converter.RandomValue.o_value) | Output socket: Value |

#### Methods

| Name | Description |
| --- | --- |
| [i_max](#nodebpy.nodes.converter.RandomValue.i_max) | Input socket: Maximum |
| [i_min](#nodebpy.nodes.converter.RandomValue.i_min) | Input socket: Minimum |
| [i_probability](#nodebpy.nodes.converter.RandomValue.i_probability) | Input socket: Probability |

##### i_max { #nodebpy.nodes.converter.RandomValue.i_max }

```python
nodes.converter.RandomValue.i_max()
```

Input socket: Maximum

##### i_min { #nodebpy.nodes.converter.RandomValue.i_min }

```python
nodes.converter.RandomValue.i_min()
```

Input socket: Minimum

##### i_probability { #nodebpy.nodes.converter.RandomValue.i_probability }

```python
nodes.converter.RandomValue.i_probability()
```

Input socket: Probability

### ReplaceString { #nodebpy.nodes.converter.ReplaceString }

```python
nodes.converter.ReplaceString(string='', find='', replace='')
```

Replace a given string segment with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_find](#nodebpy.nodes.converter.ReplaceString.i_find) | Input socket: Find |
| [i_replace](#nodebpy.nodes.converter.ReplaceString.i_replace) | Input socket: Replace |
| [i_string](#nodebpy.nodes.converter.ReplaceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.converter.ReplaceString.o_string) | Output socket: String |

### RotateEuler { #nodebpy.nodes.converter.RotateEuler }

```python
nodes.converter.RotateEuler(
    rotation=(0.0, 0.0, 0.0),
    rotate_by=(0.0, 0.0, 0.0),
    *,
    rotation_type='EULER',
    space='OBJECT',
)
```

Apply a secondary Euler rotation to a given Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.converter.RotateEuler.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.converter.RotateEuler.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.converter.RotateEuler.o_rotation) | Output socket: Rotation |

### RotateRotation { #nodebpy.nodes.converter.RotateRotation }

```python
nodes.converter.RotateRotation(
    rotation=(0.0, 0.0, 0.0),
    rotate_by=(0.0, 0.0, 0.0),
    *,
    rotation_space='GLOBAL',
)
```

Apply a secondary rotation to a given rotation value

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.converter.RotateRotation.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.converter.RotateRotation.i_rotation) | Input socket: Rotation |
| [o_rotation](#nodebpy.nodes.converter.RotateRotation.o_rotation) | Output socket: Rotation |

### RotateVector { #nodebpy.nodes.converter.RotateVector }

```python
nodes.converter.RotateVector(vector=(0.0, 0.0, 0.0), rotation=(0.0, 0.0, 0.0))
```

Apply a rotation to a given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotateVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.converter.RotateVector.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.converter.RotateVector.o_vector) | Output socket: Vector |

### RotationToAxisAngle { #nodebpy.nodes.converter.RotationToAxisAngle }

```python
nodes.converter.RotationToAxisAngle(rotation=(0.0, 0.0, 0.0))
```

Convert a rotation to axis angle components

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToAxisAngle.i_rotation) | Input socket: Rotation |
| [o_angle](#nodebpy.nodes.converter.RotationToAxisAngle.o_angle) | Output socket: Angle |
| [o_axis](#nodebpy.nodes.converter.RotationToAxisAngle.o_axis) | Output socket: Axis |

### RotationToEuler { #nodebpy.nodes.converter.RotationToEuler }

```python
nodes.converter.RotationToEuler(rotation=(0.0, 0.0, 0.0))
```

Convert a standard rotation value to an Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToEuler.i_rotation) | Input socket: Rotation |
| [o_euler](#nodebpy.nodes.converter.RotationToEuler.o_euler) | Output socket: Euler |

### RotationToQuaternion { #nodebpy.nodes.converter.RotationToQuaternion }

```python
nodes.converter.RotationToQuaternion(rotation=(0.0, 0.0, 0.0))
```

Retrieve the quaternion components representing a rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToQuaternion.i_rotation) | Input socket: Rotation |
| [o_w](#nodebpy.nodes.converter.RotationToQuaternion.o_w) | Output socket: W |
| [o_x](#nodebpy.nodes.converter.RotationToQuaternion.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.converter.RotationToQuaternion.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.converter.RotationToQuaternion.o_z) | Output socket: Z |

### SeparateColor { #nodebpy.nodes.converter.SeparateColor }

```python
nodes.converter.SeparateColor(color=(1.0, 1.0, 1.0, 1.0), *, mode='RGB')
```

Split a color into separate channels, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.converter.SeparateColor.i_color) | Input socket: Color |
| [o_alpha](#nodebpy.nodes.converter.SeparateColor.o_alpha) | Output socket: Alpha |
| [o_blue](#nodebpy.nodes.converter.SeparateColor.o_blue) | Output socket: Blue |
| [o_green](#nodebpy.nodes.converter.SeparateColor.o_green) | Output socket: Green |
| [o_red](#nodebpy.nodes.converter.SeparateColor.o_red) | Output socket: Red |

### SeparateMatrix { #nodebpy.nodes.converter.SeparateMatrix }

```python
nodes.converter.SeparateMatrix(matrix=None)
```

Split a 4x4 matrix into its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.SeparateMatrix.i_matrix) | Input socket: Matrix |
| [o_column_1_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_1) | Output socket: Column 1 Row 1 |
| [o_column_1_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_2) | Output socket: Column 1 Row 2 |
| [o_column_1_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_3) | Output socket: Column 1 Row 3 |
| [o_column_1_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_4) | Output socket: Column 1 Row 4 |
| [o_column_2_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_1) | Output socket: Column 2 Row 1 |
| [o_column_2_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_2) | Output socket: Column 2 Row 2 |
| [o_column_2_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_3) | Output socket: Column 2 Row 3 |
| [o_column_2_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_4) | Output socket: Column 2 Row 4 |
| [o_column_3_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_1) | Output socket: Column 3 Row 1 |
| [o_column_3_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_2) | Output socket: Column 3 Row 2 |
| [o_column_3_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_3) | Output socket: Column 3 Row 3 |
| [o_column_3_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_4) | Output socket: Column 3 Row 4 |
| [o_column_4_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_1) | Output socket: Column 4 Row 1 |
| [o_column_4_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_2) | Output socket: Column 4 Row 2 |
| [o_column_4_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_3) | Output socket: Column 4 Row 3 |
| [o_column_4_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_4) | Output socket: Column 4 Row 4 |

### SeparateTransform { #nodebpy.nodes.converter.SeparateTransform }

```python
nodes.converter.SeparateTransform(transform)
```

Split a transformation matrix into a translation vector, a rotation, and a scale vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.SeparateTransform.i_transform) | Input socket: Transform |
| [o_rotation](#nodebpy.nodes.converter.SeparateTransform.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.converter.SeparateTransform.o_scale) | Output socket: Scale |
| [o_translation](#nodebpy.nodes.converter.SeparateTransform.o_translation) | Output socket: Translation |

### SeparateXYZ { #nodebpy.nodes.converter.SeparateXYZ }

```python
nodes.converter.SeparateXYZ(vector=(0.0, 0.0, 0.0))
```

Split a vector into its X, Y, and Z components

#### Attributes

| Name | Description |
| --- | --- |
| [i_vector](#nodebpy.nodes.converter.SeparateXYZ.i_vector) | Input socket: Vector |
| [o_x](#nodebpy.nodes.converter.SeparateXYZ.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.converter.SeparateXYZ.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.converter.SeparateXYZ.o_z) | Output socket: Z |

### SliceString { #nodebpy.nodes.converter.SliceString }

```python
nodes.converter.SliceString(string='', position=0, length=10)
```

Extract a string segment from a larger string

#### Attributes

| Name | Description |
| --- | --- |
| [i_length](#nodebpy.nodes.converter.SliceString.i_length) | Input socket: Length |
| [i_position](#nodebpy.nodes.converter.SliceString.i_position) | Input socket: Position |
| [i_string](#nodebpy.nodes.converter.SliceString.i_string) | Input socket: String |
| [o_string](#nodebpy.nodes.converter.SliceString.o_string) | Output socket: String |

### StringLength { #nodebpy.nodes.converter.StringLength }

```python
nodes.converter.StringLength(string='')
```

Output the number of characters in the given string

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.converter.StringLength.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.converter.StringLength.o_length) | Output socket: Length |

### StringToValue { #nodebpy.nodes.converter.StringToValue }

```python
nodes.converter.StringToValue(string='', *, data_type='FLOAT')
```

Derive a numeric value from a given string representation

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.converter.StringToValue.i_string) | Input socket: String |
| [o_length](#nodebpy.nodes.converter.StringToValue.o_length) | Output socket: Length |
| [o_value](#nodebpy.nodes.converter.StringToValue.o_value) | Output socket: Value |

### Switch { #nodebpy.nodes.converter.Switch }

```python
nodes.converter.Switch(
    switch=False,
    false=None,
    true=None,
    *,
    input_type='GEOMETRY',
    **kwargs,
)
```

Switch between two inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_false](#nodebpy.nodes.converter.Switch.i_false) | Input socket: False |
| [i_switch](#nodebpy.nodes.converter.Switch.i_switch) | Input socket: Switch |
| [i_true](#nodebpy.nodes.converter.Switch.i_true) | Input socket: True |
| [o_output](#nodebpy.nodes.converter.Switch.o_output) | Output socket: Output |

### TransformDirection { #nodebpy.nodes.converter.TransformDirection }

```python
nodes.converter.TransformDirection(direction=(0.0, 0.0, 0.0), transform=None)
```

Apply a transformation matrix (excluding translation) to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.converter.TransformDirection.i_direction) | Input socket: Direction |
| [i_transform](#nodebpy.nodes.converter.TransformDirection.i_transform) | Input socket: Transform |
| [o_direction](#nodebpy.nodes.converter.TransformDirection.o_direction) | Output socket: Direction |

### TransformPoint { #nodebpy.nodes.converter.TransformPoint }

```python
nodes.converter.TransformPoint(vector=(0.0, 0.0, 0.0), transform=None)
```

Apply a transformation matrix to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.TransformPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.converter.TransformPoint.i_vector) | Input socket: Vector |
| [o_vector](#nodebpy.nodes.converter.TransformPoint.o_vector) | Output socket: Vector |

### TransposeMatrix { #nodebpy.nodes.converter.TransposeMatrix }

```python
nodes.converter.TransposeMatrix(matrix=None)
```

Flip a matrix over its diagonal, turning columns into rows and vice-versa

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.TransposeMatrix.i_matrix) | Input socket: Matrix |
| [o_matrix](#nodebpy.nodes.converter.TransposeMatrix.o_matrix) | Output socket: Matrix |

### UVUnwrap { #nodebpy.nodes.converter.UVUnwrap }

```python
nodes.converter.UVUnwrap(
    selection=True,
    seam=False,
    margin=0.001,
    fill_holes=True,
    method='Angle Based',
)
```

Generate a UV map based on seam edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_fill_holes](#nodebpy.nodes.converter.UVUnwrap.i_fill_holes) | Input socket: Fill Holes |
| [i_margin](#nodebpy.nodes.converter.UVUnwrap.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.converter.UVUnwrap.i_method) | Input socket: Method |
| [i_seam](#nodebpy.nodes.converter.UVUnwrap.i_seam) | Input socket: Seam |
| [i_selection](#nodebpy.nodes.converter.UVUnwrap.i_selection) | Input socket: Selection |
| [o_uv](#nodebpy.nodes.converter.UVUnwrap.o_uv) | Output socket: UV |

### ValueToString { #nodebpy.nodes.converter.ValueToString }

```python
nodes.converter.ValueToString(value=0.0, decimals=0, *, data_type='FLOAT')
```

Generate a string representation of the given input value

#### Attributes

| Name | Description |
| --- | --- |
| [i_decimals](#nodebpy.nodes.converter.ValueToString.i_decimals) | Input socket: Decimals |
| [i_value](#nodebpy.nodes.converter.ValueToString.i_value) | Input socket: Value |
| [o_string](#nodebpy.nodes.converter.ValueToString.o_string) | Output socket: String |

### VectorMath { #nodebpy.nodes.converter.VectorMath }

```python
nodes.converter.VectorMath(operation='ADD', **kwargs)
```

Perform vector math operation

#### Attributes

| Name | Description |
| --- | --- |
| [i_vector](#nodebpy.nodes.converter.VectorMath.i_vector) | Input socket: Vector |
| [i_vector_001](#nodebpy.nodes.converter.VectorMath.i_vector_001) | Input socket: Vector |
| [o_value](#nodebpy.nodes.converter.VectorMath.o_value) | Output socket: Value |
| [o_vector](#nodebpy.nodes.converter.VectorMath.o_vector) | Output socket: Vector |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.converter.VectorMath.absolute) | Create Vector Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.converter.VectorMath.add) | Create Vector Math with operation `a + b`. |
| [ceil](#nodebpy.nodes.converter.VectorMath.ceil) | Create Vector Math with operation 'Ceil'. |
| [cosine](#nodebpy.nodes.converter.VectorMath.cosine) | Create Vector Math with operation 'Cosine'. |
| [cross_product](#nodebpy.nodes.converter.VectorMath.cross_product) | Create Vector Math with operation 'Cross Product'. |
| [distance](#nodebpy.nodes.converter.VectorMath.distance) | Create Vector Math with operation 'Distance'. |
| [divide](#nodebpy.nodes.converter.VectorMath.divide) | Create Vector Math with operation 'Divide'. |
| [dot_product](#nodebpy.nodes.converter.VectorMath.dot_product) | Create Vector Math with operation 'Dot Product'. |
| [face_forward](#nodebpy.nodes.converter.VectorMath.face_forward) | Orients a vector to face away from a surface (incidence) defined by it's normal (reference) |
| [floor](#nodebpy.nodes.converter.VectorMath.floor) | Create Vector Math with operation 'Floor'. |
| [fraction](#nodebpy.nodes.converter.VectorMath.fraction) | Create Vector Math with operation 'Fraction'. |
| [length](#nodebpy.nodes.converter.VectorMath.length) | Create Vector Math with operation 'Length'. |
| [maximum](#nodebpy.nodes.converter.VectorMath.maximum) | Create Vector Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.converter.VectorMath.minimum) | Create Vector Math with operation 'Minimum'. |
| [modulo](#nodebpy.nodes.converter.VectorMath.modulo) | Create Vector Math with operation 'Modulo'. |
| [multiply](#nodebpy.nodes.converter.VectorMath.multiply) | Create Vector Math with operation `a * b` element-wise. |
| [multiply_add](#nodebpy.nodes.converter.VectorMath.multiply_add) | Create Vector Math with operation 'Multiply Add'. |
| [normalize](#nodebpy.nodes.converter.VectorMath.normalize) | Create Vector Math with operation 'Normalize'. |
| [power](#nodebpy.nodes.converter.VectorMath.power) | Create Vector Math with operation 'Power'. |
| [project](#nodebpy.nodes.converter.VectorMath.project) | Project A onto B. |
| [reflect](#nodebpy.nodes.converter.VectorMath.reflect) | Reflect A around the normal B. B does not need to be normalized. |
| [refract](#nodebpy.nodes.converter.VectorMath.refract) | For a given incident vector and surface normal (b) with an index of refraction (ior), return the refraction vector |
| [scale](#nodebpy.nodes.converter.VectorMath.scale) | Create Vector Math with operation 'Scale'. |
| [sign](#nodebpy.nodes.converter.VectorMath.sign) | Create Vector Math with operation 'Sign'. |
| [sine](#nodebpy.nodes.converter.VectorMath.sine) | Create Vector Math with operation 'Sine'. |
| [snap](#nodebpy.nodes.converter.VectorMath.snap) | Create Vector Math with operation 'Snap'. |
| [subtract](#nodebpy.nodes.converter.VectorMath.subtract) | Create Vector Math with operation `a - b`. |
| [tangent](#nodebpy.nodes.converter.VectorMath.tangent) | Create Vector Math with operation 'Tangent'. |
| [wrap](#nodebpy.nodes.converter.VectorMath.wrap) | Create Vector Math with operation 'Wrap'. |

##### absolute { #nodebpy.nodes.converter.VectorMath.absolute }

```python
nodes.converter.VectorMath.absolute(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Absolute'.

##### add { #nodebpy.nodes.converter.VectorMath.add }

```python
nodes.converter.VectorMath.add(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation `a + b`.

##### ceil { #nodebpy.nodes.converter.VectorMath.ceil }

```python
nodes.converter.VectorMath.ceil(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Ceil'.

##### cosine { #nodebpy.nodes.converter.VectorMath.cosine }

```python
nodes.converter.VectorMath.cosine(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Cosine'.

##### cross_product { #nodebpy.nodes.converter.VectorMath.cross_product }

```python
nodes.converter.VectorMath.cross_product(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Cross Product'.

##### distance { #nodebpy.nodes.converter.VectorMath.distance }

```python
nodes.converter.VectorMath.distance(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Distance'.

##### divide { #nodebpy.nodes.converter.VectorMath.divide }

```python
nodes.converter.VectorMath.divide(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Divide'.

##### dot_product { #nodebpy.nodes.converter.VectorMath.dot_product }

```python
nodes.converter.VectorMath.dot_product(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Dot Product'.

##### face_forward { #nodebpy.nodes.converter.VectorMath.face_forward }

```python
nodes.converter.VectorMath.face_forward(
    vector=(0.0, 0.0, 0.0),
    incidence=(0.0, 0.0, 0.0),
    reference=(0.0, 0.0, 0.0),
)
```

Orients a vector to face away from a surface (incidence) defined by it's normal (reference)

##### floor { #nodebpy.nodes.converter.VectorMath.floor }

```python
nodes.converter.VectorMath.floor(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Floor'.

##### fraction { #nodebpy.nodes.converter.VectorMath.fraction }

```python
nodes.converter.VectorMath.fraction(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Fraction'.

##### length { #nodebpy.nodes.converter.VectorMath.length }

```python
nodes.converter.VectorMath.length(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Length'.

##### maximum { #nodebpy.nodes.converter.VectorMath.maximum }

```python
nodes.converter.VectorMath.maximum(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.converter.VectorMath.minimum }

```python
nodes.converter.VectorMath.minimum(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Minimum'.

##### modulo { #nodebpy.nodes.converter.VectorMath.modulo }

```python
nodes.converter.VectorMath.modulo(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Modulo'.

##### multiply { #nodebpy.nodes.converter.VectorMath.multiply }

```python
nodes.converter.VectorMath.multiply(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation `a * b` element-wise.

##### multiply_add { #nodebpy.nodes.converter.VectorMath.multiply_add }

```python
nodes.converter.VectorMath.multiply_add(
    vector=(0.0, 0.0, 0.0),
    multiplier=(0.0, 0.0, 0.0),
    addend=(0.0, 0.0, 0.0),
)
```

Create Vector Math with operation 'Multiply Add'.

##### normalize { #nodebpy.nodes.converter.VectorMath.normalize }

```python
nodes.converter.VectorMath.normalize(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Normalize'.

##### power { #nodebpy.nodes.converter.VectorMath.power }

```python
nodes.converter.VectorMath.power(base=(0.0, 0.0, 0.0), exponent=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Power'.

##### project { #nodebpy.nodes.converter.VectorMath.project }

```python
nodes.converter.VectorMath.project(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Project A onto B.

##### reflect { #nodebpy.nodes.converter.VectorMath.reflect }

```python
nodes.converter.VectorMath.reflect(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Reflect A around the normal B. B does not need to be normalized.

##### refract { #nodebpy.nodes.converter.VectorMath.refract }

```python
nodes.converter.VectorMath.refract(
    a=(0.0, 0.0, 0.0),
    b=(0.0, 0.0, 0.0),
    ior=1.0,
)
```

For a given incident vector and surface normal (b) with an index of refraction (ior), return the refraction vector

##### scale { #nodebpy.nodes.converter.VectorMath.scale }

```python
nodes.converter.VectorMath.scale(vector=(0.0, 0.0, 0.0), scale=1.0)
```

Create Vector Math with operation 'Scale'.

##### sign { #nodebpy.nodes.converter.VectorMath.sign }

```python
nodes.converter.VectorMath.sign(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Sign'.

##### sine { #nodebpy.nodes.converter.VectorMath.sine }

```python
nodes.converter.VectorMath.sine(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Sine'.

##### snap { #nodebpy.nodes.converter.VectorMath.snap }

```python
nodes.converter.VectorMath.snap(
    vector=(0.0, 0.0, 0.0),
    increment=(0.0, 0.0, 0.0),
)
```

Create Vector Math with operation 'Snap'.

##### subtract { #nodebpy.nodes.converter.VectorMath.subtract }

```python
nodes.converter.VectorMath.subtract(a=(0.0, 0.0, 0.0), b=(0.0, 0.0, 0.0))
```

Create Vector Math with operation `a - b`.

##### tangent { #nodebpy.nodes.converter.VectorMath.tangent }

```python
nodes.converter.VectorMath.tangent(vector=(0.0, 0.0, 0.0))
```

Create Vector Math with operation 'Tangent'.

##### wrap { #nodebpy.nodes.converter.VectorMath.wrap }

```python
nodes.converter.VectorMath.wrap(
    vector=(0.0, 0.0, 0.0),
    min=(0.0, 0.0, 0.0),
    max=(0.0, 0.0, 0.0),
)
```

Create Vector Math with operation 'Wrap'.