# nodes.converter { #nodebpy.nodes.converter }

`nodes.converter`



## Classes

| Name | Description |
| --- | --- |
| [AlignRotationToVector](#nodebpy.nodes.converter.AlignRotationToVector) | Orient a rotation along the given direction |
| [AxesToRotation](#nodebpy.nodes.converter.AxesToRotation) | Create a rotation from a primary and (ideally orthogonal) secondary axis |
| [AxisAngleToRotation](#nodebpy.nodes.converter.AxisAngleToRotation) | Build a rotation from an axis and a rotation around that axis |
| [BitMath](#nodebpy.nodes.converter.BitMath) | Perform bitwise operations on 32-bit integers |
| [Blackbody](#nodebpy.nodes.converter.Blackbody) | Convert a blackbody temperature to an RGB value |
| [BooleanMath](#nodebpy.nodes.converter.BooleanMath) | Perform a logical operation on the given boolean inputs |
| [Clamp](#nodebpy.nodes.converter.Clamp) | Clamp a value between a minimum and a maximum |
| [ColorRamp](#nodebpy.nodes.converter.ColorRamp) | Map values to colors with the use of a gradient |
| [CombineBundle](#nodebpy.nodes.converter.CombineBundle) | Combine multiple socket values into one. |
| [CombineColor](#nodebpy.nodes.converter.CombineColor) | Combine four channels into a single color, based on a particular color model |
| [CombineMatrix](#nodebpy.nodes.converter.CombineMatrix) | Construct a 4x4 matrix from its individual values |
| [CombineTransform](#nodebpy.nodes.converter.CombineTransform) | Combine a translation vector, a rotation, and a scale vector into a transformation matrix |
| [CombineXYZ](#nodebpy.nodes.converter.CombineXYZ) | Create a vector from X, Y, and Z components |
| [EulerToRotation](#nodebpy.nodes.converter.EulerToRotation) | Build a rotation from separate angles around each axis |
| [FindInString](#nodebpy.nodes.converter.FindInString) | Find the number of times a given string occurs in another string and the position of the first match |
| [FloatCurve](#nodebpy.nodes.converter.FloatCurve) | Map an input float to a curve and outputs a float value |
| [FloatToInteger](#nodebpy.nodes.converter.FloatToInteger) | Convert the given floating-point number to an integer, with a choice of methods |
| [HashValue](#nodebpy.nodes.converter.HashValue) | Generate a randomized integer using the given input value as a seed |
| [IndexOfNearest](#nodebpy.nodes.converter.IndexOfNearest) | Find the nearest element in a group. Similar to the "Sample Nearest" node |
| [IntegerMath](#nodebpy.nodes.converter.IntegerMath) | Perform various math operations on the given integer inputs |
| [InvertMatrix](#nodebpy.nodes.converter.InvertMatrix) | Compute the inverse of the given matrix, if one exists |
| [InvertRotation](#nodebpy.nodes.converter.InvertRotation) | Compute the inverse of the given rotation |
| [JoinBundle](#nodebpy.nodes.converter.JoinBundle) | Join multiple bundles together |
| [MapRange](#nodebpy.nodes.converter.MapRange) | Remap a value from a range to a target range |
| [MatchString](#nodebpy.nodes.converter.MatchString) | Check if a given string exists within another string |
| [Math](#nodebpy.nodes.converter.Math) | Perform math operations |
| [MatrixDeterminant](#nodebpy.nodes.converter.MatrixDeterminant) | Compute the determinant of the given matrix |
| [Mix](#nodebpy.nodes.converter.Mix) | Mix values by a factor |
| [MultiplyMatrices](#nodebpy.nodes.converter.MultiplyMatrices) | Perform a matrix multiplication on two input matrices |
| [PackUVIslands](#nodebpy.nodes.converter.PackUVIslands) | Scale islands of a UV map and move them so they fill the UV space as much as possible |
| [ProjectPoint](#nodebpy.nodes.converter.ProjectPoint) | Project a point using a matrix, using location, rotation, scale, and perspective divide |
| [QuaternionToRotation](#nodebpy.nodes.converter.QuaternionToRotation) | Build a rotation from quaternion components |
| [RandomValue](#nodebpy.nodes.converter.RandomValue) | Output a randomized value |
| [ReplaceString](#nodebpy.nodes.converter.ReplaceString) | Replace a given string segment with another |
| [RotateEuler](#nodebpy.nodes.converter.RotateEuler) | Apply a secondary Euler rotation to a given Euler rotation |
| [RotateRotation](#nodebpy.nodes.converter.RotateRotation) | Apply a secondary rotation to a given rotation value |
| [RotateVector](#nodebpy.nodes.converter.RotateVector) | Apply a rotation to a given vector |
| [RotationToAxisAngle](#nodebpy.nodes.converter.RotationToAxisAngle) | Convert a rotation to axis angle components |
| [RotationToEuler](#nodebpy.nodes.converter.RotationToEuler) | Convert a standard rotation value to an Euler rotation |
| [RotationToQuaternion](#nodebpy.nodes.converter.RotationToQuaternion) | Retrieve the quaternion components representing a rotation |
| [SeparateBundle](#nodebpy.nodes.converter.SeparateBundle) | Split a bundle into multiple sockets. |
| [SeparateColor](#nodebpy.nodes.converter.SeparateColor) | Split a color into separate channels, based on a particular color model |
| [SeparateMatrix](#nodebpy.nodes.converter.SeparateMatrix) | Split a 4x4 matrix into its individual values |
| [SeparateTransform](#nodebpy.nodes.converter.SeparateTransform) | Split a transformation matrix into a translation vector, a rotation, and a scale vector |
| [SeparateXYZ](#nodebpy.nodes.converter.SeparateXYZ) | Split a vector into its X, Y, and Z components |
| [SliceString](#nodebpy.nodes.converter.SliceString) | Extract a string segment from a larger string |
| [StringLength](#nodebpy.nodes.converter.StringLength) | Output the number of characters in the given string |
| [StringToValue](#nodebpy.nodes.converter.StringToValue) | Derive a numeric value from a given string representation |
| [Switch](#nodebpy.nodes.converter.Switch) | Switch between two inputs |
| [TransformDirection](#nodebpy.nodes.converter.TransformDirection) | Apply a transformation matrix (excluding translation) to the given vector |
| [TransformPoint](#nodebpy.nodes.converter.TransformPoint) | Apply a transformation matrix to the given vector |
| [TransposeMatrix](#nodebpy.nodes.converter.TransposeMatrix) | Flip a matrix over its diagonal, turning columns into rows and vice-versa |
| [UVUnwrap](#nodebpy.nodes.converter.UVUnwrap) | Generate a UV map based on seam edges |
| [ValueToString](#nodebpy.nodes.converter.ValueToString) | Generate a string representation of the given input value |

### AlignRotationToVector { #nodebpy.nodes.converter.AlignRotationToVector }

```python
nodes.converter.AlignRotationToVector(
    rotation=None,
    factor=1.0,
    vector=None,
    *,
    axis='Z',
    pivot_axis='AUTO',
)
```

Orient a rotation along the given direction

#### Attributes

| Name | Description |
| --- | --- |
| [axis](#nodebpy.nodes.converter.AlignRotationToVector.axis) |  |
| [i_factor](#nodebpy.nodes.converter.AlignRotationToVector.i_factor) | Input socket: Factor |
| [i_rotation](#nodebpy.nodes.converter.AlignRotationToVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.converter.AlignRotationToVector.i_vector) | Input socket: Vector |
| [name](#nodebpy.nodes.converter.AlignRotationToVector.name) |  |
| [node](#nodebpy.nodes.converter.AlignRotationToVector.node) |  |
| [o_rotation](#nodebpy.nodes.converter.AlignRotationToVector.o_rotation) | Output socket: Rotation |
| [pivot_axis](#nodebpy.nodes.converter.AlignRotationToVector.pivot_axis) |  |
| [tree](#nodebpy.nodes.converter.AlignRotationToVector.tree) |  |
| [type](#nodebpy.nodes.converter.AlignRotationToVector.type) |  |

### AxesToRotation { #nodebpy.nodes.converter.AxesToRotation }

```python
nodes.converter.AxesToRotation(
    primary_axis=None,
    secondary_axis=None,
    *,
    primary='Z',
    secondary='X',
)
```

Create a rotation from a primary and (ideally orthogonal) secondary axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_primary_axis](#nodebpy.nodes.converter.AxesToRotation.i_primary_axis) | Input socket: Primary Axis |
| [i_secondary_axis](#nodebpy.nodes.converter.AxesToRotation.i_secondary_axis) | Input socket: Secondary Axis |
| [name](#nodebpy.nodes.converter.AxesToRotation.name) |  |
| [node](#nodebpy.nodes.converter.AxesToRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.AxesToRotation.o_rotation) | Output socket: Rotation |
| [primary](#nodebpy.nodes.converter.AxesToRotation.primary) |  |
| [primary_axis](#nodebpy.nodes.converter.AxesToRotation.primary_axis) |  |
| [secondary](#nodebpy.nodes.converter.AxesToRotation.secondary) |  |
| [secondary_axis](#nodebpy.nodes.converter.AxesToRotation.secondary_axis) |  |
| [tree](#nodebpy.nodes.converter.AxesToRotation.tree) |  |
| [type](#nodebpy.nodes.converter.AxesToRotation.type) |  |

### AxisAngleToRotation { #nodebpy.nodes.converter.AxisAngleToRotation }

```python
nodes.converter.AxisAngleToRotation(axis=None, angle=0.0)
```

Build a rotation from an axis and a rotation around that axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_angle](#nodebpy.nodes.converter.AxisAngleToRotation.i_angle) | Input socket: Angle |
| [i_axis](#nodebpy.nodes.converter.AxisAngleToRotation.i_axis) | Input socket: Axis |
| [name](#nodebpy.nodes.converter.AxisAngleToRotation.name) |  |
| [node](#nodebpy.nodes.converter.AxisAngleToRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.AxisAngleToRotation.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.converter.AxisAngleToRotation.tree) |  |
| [type](#nodebpy.nodes.converter.AxisAngleToRotation.type) |  |

### BitMath { #nodebpy.nodes.converter.BitMath }

```python
nodes.converter.BitMath(a=0, b=0, shift=0, *, operation='AND')
```

Perform bitwise operations on 32-bit integers

#### Attributes

| Name | Description |
| --- | --- |
| [i_a](#nodebpy.nodes.converter.BitMath.i_a) | Input socket: A |
| [i_b](#nodebpy.nodes.converter.BitMath.i_b) | Input socket: B |
| [i_shift](#nodebpy.nodes.converter.BitMath.i_shift) | Input socket: Shift |
| [name](#nodebpy.nodes.converter.BitMath.name) |  |
| [node](#nodebpy.nodes.converter.BitMath.node) |  |
| [o_value](#nodebpy.nodes.converter.BitMath.o_value) | Output socket: Value |
| [operation](#nodebpy.nodes.converter.BitMath.operation) |  |
| [tree](#nodebpy.nodes.converter.BitMath.tree) |  |
| [type](#nodebpy.nodes.converter.BitMath.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [l_and](#nodebpy.nodes.converter.BitMath.l_and) | Create Bit Math with operation 'And'. |
| [l_not](#nodebpy.nodes.converter.BitMath.l_not) | Create Bit Math with operation 'Not'. |
| [l_or](#nodebpy.nodes.converter.BitMath.l_or) | Create Bit Math with operation 'Or'. |
| [rotate](#nodebpy.nodes.converter.BitMath.rotate) | Create Bit Math with operation 'Rotate'. |
| [shift](#nodebpy.nodes.converter.BitMath.shift) | Create Bit Math with operation 'Shift'. |

##### l_and { #nodebpy.nodes.converter.BitMath.l_and }

```python
nodes.converter.BitMath.l_and(a=0, b=0)
```

Create Bit Math with operation 'And'.

##### l_not { #nodebpy.nodes.converter.BitMath.l_not }

```python
nodes.converter.BitMath.l_not(a=0)
```

Create Bit Math with operation 'Not'.

##### l_or { #nodebpy.nodes.converter.BitMath.l_or }

```python
nodes.converter.BitMath.l_or(a=0, b=0)
```

Create Bit Math with operation 'Or'.

##### rotate { #nodebpy.nodes.converter.BitMath.rotate }

```python
nodes.converter.BitMath.rotate(a=0, shift=0)
```

Create Bit Math with operation 'Rotate'.

##### shift { #nodebpy.nodes.converter.BitMath.shift }

```python
nodes.converter.BitMath.shift(a=0, shift=0)
```

Create Bit Math with operation 'Shift'.

### Blackbody { #nodebpy.nodes.converter.Blackbody }

```python
nodes.converter.Blackbody(temperature=6500.0)
```

Convert a blackbody temperature to an RGB value

#### Attributes

| Name | Description |
| --- | --- |
| [i_temperature](#nodebpy.nodes.converter.Blackbody.i_temperature) | Input socket: Temperature |
| [name](#nodebpy.nodes.converter.Blackbody.name) |  |
| [node](#nodebpy.nodes.converter.Blackbody.node) |  |
| [o_color](#nodebpy.nodes.converter.Blackbody.o_color) | Output socket: Color |
| [tree](#nodebpy.nodes.converter.Blackbody.tree) |  |
| [type](#nodebpy.nodes.converter.Blackbody.type) |  |

### BooleanMath { #nodebpy.nodes.converter.BooleanMath }

```python
nodes.converter.BooleanMath(
    boolean=False,
    boolean_001=False,
    *,
    operation='AND',
)
```

Perform a logical operation on the given boolean inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_boolean](#nodebpy.nodes.converter.BooleanMath.i_boolean) | Input socket: Boolean |
| [i_boolean_001](#nodebpy.nodes.converter.BooleanMath.i_boolean_001) | Input socket: Boolean |
| [name](#nodebpy.nodes.converter.BooleanMath.name) |  |
| [node](#nodebpy.nodes.converter.BooleanMath.node) |  |
| [o_boolean](#nodebpy.nodes.converter.BooleanMath.o_boolean) | Output socket: Boolean |
| [operation](#nodebpy.nodes.converter.BooleanMath.operation) |  |
| [tree](#nodebpy.nodes.converter.BooleanMath.tree) |  |
| [type](#nodebpy.nodes.converter.BooleanMath.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [equal](#nodebpy.nodes.converter.BooleanMath.equal) | Create Boolean Math with operation 'Equal'. |
| [imply](#nodebpy.nodes.converter.BooleanMath.imply) | Create Boolean Math with operation 'Imply'. |
| [l_and](#nodebpy.nodes.converter.BooleanMath.l_and) | Create Boolean Math with operation 'And'. |
| [l_not](#nodebpy.nodes.converter.BooleanMath.l_not) | Create Boolean Math with operation 'Not'. |
| [l_or](#nodebpy.nodes.converter.BooleanMath.l_or) | Create Boolean Math with operation 'Or'. |
| [nor](#nodebpy.nodes.converter.BooleanMath.nor) | Create Boolean Math with operation 'Nor'. |
| [subtract](#nodebpy.nodes.converter.BooleanMath.subtract) | Create Boolean Math with operation 'Subtract'. |

##### equal { #nodebpy.nodes.converter.BooleanMath.equal }

```python
nodes.converter.BooleanMath.equal(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'Equal'.

##### imply { #nodebpy.nodes.converter.BooleanMath.imply }

```python
nodes.converter.BooleanMath.imply(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'Imply'.

##### l_and { #nodebpy.nodes.converter.BooleanMath.l_and }

```python
nodes.converter.BooleanMath.l_and(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'And'.

##### l_not { #nodebpy.nodes.converter.BooleanMath.l_not }

```python
nodes.converter.BooleanMath.l_not(boolean=False)
```

Create Boolean Math with operation 'Not'.

##### l_or { #nodebpy.nodes.converter.BooleanMath.l_or }

```python
nodes.converter.BooleanMath.l_or(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'Or'.

##### nor { #nodebpy.nodes.converter.BooleanMath.nor }

```python
nodes.converter.BooleanMath.nor(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'Nor'.

##### subtract { #nodebpy.nodes.converter.BooleanMath.subtract }

```python
nodes.converter.BooleanMath.subtract(boolean=False, boolean_001=False)
```

Create Boolean Math with operation 'Subtract'.

### Clamp { #nodebpy.nodes.converter.Clamp }

```python
nodes.converter.Clamp(value=1.0, min=0.0, max=1.0, *, clamp_type='MINMAX')
```

Clamp a value between a minimum and a maximum

#### Attributes

| Name | Description |
| --- | --- |
| [clamp_type](#nodebpy.nodes.converter.Clamp.clamp_type) |  |
| [i_max](#nodebpy.nodes.converter.Clamp.i_max) | Input socket: Max |
| [i_min](#nodebpy.nodes.converter.Clamp.i_min) | Input socket: Min |
| [i_value](#nodebpy.nodes.converter.Clamp.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.converter.Clamp.name) |  |
| [node](#nodebpy.nodes.converter.Clamp.node) |  |
| [o_result](#nodebpy.nodes.converter.Clamp.o_result) | Output socket: Result |
| [tree](#nodebpy.nodes.converter.Clamp.tree) |  |
| [type](#nodebpy.nodes.converter.Clamp.type) |  |

### ColorRamp { #nodebpy.nodes.converter.ColorRamp }

```python
nodes.converter.ColorRamp(fac=0.5)
```

Map values to colors with the use of a gradient

#### Attributes

| Name | Description |
| --- | --- |
| [i_fac](#nodebpy.nodes.converter.ColorRamp.i_fac) | Input socket: Factor |
| [name](#nodebpy.nodes.converter.ColorRamp.name) |  |
| [node](#nodebpy.nodes.converter.ColorRamp.node) |  |
| [o_alpha](#nodebpy.nodes.converter.ColorRamp.o_alpha) | Output socket: Alpha |
| [o_color](#nodebpy.nodes.converter.ColorRamp.o_color) | Output socket: Color |
| [tree](#nodebpy.nodes.converter.ColorRamp.tree) |  |
| [type](#nodebpy.nodes.converter.ColorRamp.type) |  |

### CombineBundle { #nodebpy.nodes.converter.CombineBundle }

```python
nodes.converter.CombineBundle(define_signature=False)
```

Combine multiple socket values into one.

#### Attributes

| Name | Description |
| --- | --- |
| [define_signature](#nodebpy.nodes.converter.CombineBundle.define_signature) |  |
| [name](#nodebpy.nodes.converter.CombineBundle.name) |  |
| [node](#nodebpy.nodes.converter.CombineBundle.node) |  |
| [o_bundle](#nodebpy.nodes.converter.CombineBundle.o_bundle) | Output socket: Bundle |
| [tree](#nodebpy.nodes.converter.CombineBundle.tree) |  |
| [type](#nodebpy.nodes.converter.CombineBundle.type) |  |

### CombineColor { #nodebpy.nodes.converter.CombineColor }

```python
nodes.converter.CombineColor(
    red=0.0,
    green=0.0,
    blue=0.0,
    alpha=1.0,
    *,
    mode='RGB',
)
```

Combine four channels into a single color, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_alpha](#nodebpy.nodes.converter.CombineColor.i_alpha) | Input socket: Alpha |
| [i_blue](#nodebpy.nodes.converter.CombineColor.i_blue) | Input socket: Blue |
| [i_green](#nodebpy.nodes.converter.CombineColor.i_green) | Input socket: Green |
| [i_red](#nodebpy.nodes.converter.CombineColor.i_red) | Input socket: Red |
| [mode](#nodebpy.nodes.converter.CombineColor.mode) |  |
| [name](#nodebpy.nodes.converter.CombineColor.name) |  |
| [node](#nodebpy.nodes.converter.CombineColor.node) |  |
| [o_color](#nodebpy.nodes.converter.CombineColor.o_color) | Output socket: Color |
| [tree](#nodebpy.nodes.converter.CombineColor.tree) |  |
| [type](#nodebpy.nodes.converter.CombineColor.type) |  |

### CombineMatrix { #nodebpy.nodes.converter.CombineMatrix }

```python
nodes.converter.CombineMatrix(
    column_1_row_1=1.0,
    column_1_row_2=0.0,
    column_1_row_3=0.0,
    column_1_row_4=0.0,
    column_2_row_1=0.0,
    column_2_row_2=1.0,
    column_2_row_3=0.0,
    column_2_row_4=0.0,
    column_3_row_1=0.0,
    column_3_row_2=0.0,
    column_3_row_3=1.0,
    column_3_row_4=0.0,
    column_4_row_1=0.0,
    column_4_row_2=0.0,
    column_4_row_3=0.0,
    column_4_row_4=1.0,
)
```

Construct a 4x4 matrix from its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_column_1_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_1) | Input socket: Column 1 Row 1 |
| [i_column_1_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_2) | Input socket: Column 1 Row 2 |
| [i_column_1_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_3) | Input socket: Column 1 Row 3 |
| [i_column_1_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_1_row_4) | Input socket: Column 1 Row 4 |
| [i_column_2_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_1) | Input socket: Column 2 Row 1 |
| [i_column_2_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_2) | Input socket: Column 2 Row 2 |
| [i_column_2_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_3) | Input socket: Column 2 Row 3 |
| [i_column_2_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_2_row_4) | Input socket: Column 2 Row 4 |
| [i_column_3_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_1) | Input socket: Column 3 Row 1 |
| [i_column_3_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_2) | Input socket: Column 3 Row 2 |
| [i_column_3_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_3) | Input socket: Column 3 Row 3 |
| [i_column_3_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_3_row_4) | Input socket: Column 3 Row 4 |
| [i_column_4_row_1](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_1) | Input socket: Column 4 Row 1 |
| [i_column_4_row_2](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_2) | Input socket: Column 4 Row 2 |
| [i_column_4_row_3](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_3) | Input socket: Column 4 Row 3 |
| [i_column_4_row_4](#nodebpy.nodes.converter.CombineMatrix.i_column_4_row_4) | Input socket: Column 4 Row 4 |
| [name](#nodebpy.nodes.converter.CombineMatrix.name) |  |
| [node](#nodebpy.nodes.converter.CombineMatrix.node) |  |
| [o_matrix](#nodebpy.nodes.converter.CombineMatrix.o_matrix) | Output socket: Matrix |
| [tree](#nodebpy.nodes.converter.CombineMatrix.tree) |  |
| [type](#nodebpy.nodes.converter.CombineMatrix.type) |  |

### CombineTransform { #nodebpy.nodes.converter.CombineTransform }

```python
nodes.converter.CombineTransform(translation=None, rotation=None, scale=None)
```

Combine a translation vector, a rotation, and a scale vector into a transformation matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.CombineTransform.i_rotation) | Input socket: Rotation |
| [i_scale](#nodebpy.nodes.converter.CombineTransform.i_scale) | Input socket: Scale |
| [i_translation](#nodebpy.nodes.converter.CombineTransform.i_translation) | Input socket: Translation |
| [name](#nodebpy.nodes.converter.CombineTransform.name) |  |
| [node](#nodebpy.nodes.converter.CombineTransform.node) |  |
| [o_transform](#nodebpy.nodes.converter.CombineTransform.o_transform) | Output socket: Transform |
| [tree](#nodebpy.nodes.converter.CombineTransform.tree) |  |
| [type](#nodebpy.nodes.converter.CombineTransform.type) |  |

### CombineXYZ { #nodebpy.nodes.converter.CombineXYZ }

```python
nodes.converter.CombineXYZ(x=0.0, y=0.0, z=0.0)
```

Create a vector from X, Y, and Z components

#### Attributes

| Name | Description |
| --- | --- |
| [i_x](#nodebpy.nodes.converter.CombineXYZ.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.converter.CombineXYZ.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.converter.CombineXYZ.i_z) | Input socket: Z |
| [name](#nodebpy.nodes.converter.CombineXYZ.name) |  |
| [node](#nodebpy.nodes.converter.CombineXYZ.node) |  |
| [o_vector](#nodebpy.nodes.converter.CombineXYZ.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.converter.CombineXYZ.tree) |  |
| [type](#nodebpy.nodes.converter.CombineXYZ.type) |  |

### EulerToRotation { #nodebpy.nodes.converter.EulerToRotation }

```python
nodes.converter.EulerToRotation(euler=None)
```

Build a rotation from separate angles around each axis

#### Attributes

| Name | Description |
| --- | --- |
| [i_euler](#nodebpy.nodes.converter.EulerToRotation.i_euler) | Input socket: Euler |
| [name](#nodebpy.nodes.converter.EulerToRotation.name) |  |
| [node](#nodebpy.nodes.converter.EulerToRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.EulerToRotation.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.converter.EulerToRotation.tree) |  |
| [type](#nodebpy.nodes.converter.EulerToRotation.type) |  |

### FindInString { #nodebpy.nodes.converter.FindInString }

```python
nodes.converter.FindInString(string='', search='')
```

Find the number of times a given string occurs in another string and the position of the first match

#### Attributes

| Name | Description |
| --- | --- |
| [i_search](#nodebpy.nodes.converter.FindInString.i_search) | Input socket: Search |
| [i_string](#nodebpy.nodes.converter.FindInString.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.FindInString.name) |  |
| [node](#nodebpy.nodes.converter.FindInString.node) |  |
| [o_count](#nodebpy.nodes.converter.FindInString.o_count) | Output socket: Count |
| [o_first_found](#nodebpy.nodes.converter.FindInString.o_first_found) | Output socket: First Found |
| [tree](#nodebpy.nodes.converter.FindInString.tree) |  |
| [type](#nodebpy.nodes.converter.FindInString.type) |  |

### FloatCurve { #nodebpy.nodes.converter.FloatCurve }

```python
nodes.converter.FloatCurve(factor=1.0, value=1.0)
```

Map an input float to a curve and outputs a float value

#### Attributes

| Name | Description |
| --- | --- |
| [i_factor](#nodebpy.nodes.converter.FloatCurve.i_factor) | Input socket: Factor |
| [i_value](#nodebpy.nodes.converter.FloatCurve.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.converter.FloatCurve.name) |  |
| [node](#nodebpy.nodes.converter.FloatCurve.node) |  |
| [o_value](#nodebpy.nodes.converter.FloatCurve.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.converter.FloatCurve.tree) |  |
| [type](#nodebpy.nodes.converter.FloatCurve.type) |  |

### FloatToInteger { #nodebpy.nodes.converter.FloatToInteger }

```python
nodes.converter.FloatToInteger(float=0.0, *, rounding_mode='ROUND')
```

Convert the given floating-point number to an integer, with a choice of methods

#### Attributes

| Name | Description |
| --- | --- |
| [i_float](#nodebpy.nodes.converter.FloatToInteger.i_float) | Input socket: Float |
| [name](#nodebpy.nodes.converter.FloatToInteger.name) |  |
| [node](#nodebpy.nodes.converter.FloatToInteger.node) |  |
| [o_integer](#nodebpy.nodes.converter.FloatToInteger.o_integer) | Output socket: Integer |
| [rounding_mode](#nodebpy.nodes.converter.FloatToInteger.rounding_mode) |  |
| [tree](#nodebpy.nodes.converter.FloatToInteger.tree) |  |
| [type](#nodebpy.nodes.converter.FloatToInteger.type) |  |

### HashValue { #nodebpy.nodes.converter.HashValue }

```python
nodes.converter.HashValue(value=0, seed=0, *, data_type='INT')
```

Generate a randomized integer using the given input value as a seed

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.HashValue.data_type) |  |
| [i_seed](#nodebpy.nodes.converter.HashValue.i_seed) | Input socket: Seed |
| [i_value](#nodebpy.nodes.converter.HashValue.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.converter.HashValue.name) |  |
| [node](#nodebpy.nodes.converter.HashValue.node) |  |
| [o_hash](#nodebpy.nodes.converter.HashValue.o_hash) | Output socket: Hash |
| [tree](#nodebpy.nodes.converter.HashValue.tree) |  |
| [type](#nodebpy.nodes.converter.HashValue.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [color](#nodebpy.nodes.converter.HashValue.color) | Create Hash Value with operation 'Color'. |
| [float](#nodebpy.nodes.converter.HashValue.float) | Create Hash Value with operation 'Float'. |
| [integer](#nodebpy.nodes.converter.HashValue.integer) | Create Hash Value with operation 'Integer'. |
| [matrix](#nodebpy.nodes.converter.HashValue.matrix) | Create Hash Value with operation 'Matrix'. |
| [rotation](#nodebpy.nodes.converter.HashValue.rotation) | Create Hash Value with operation 'Rotation'. |
| [string](#nodebpy.nodes.converter.HashValue.string) | Create Hash Value with operation 'String'. |
| [vector](#nodebpy.nodes.converter.HashValue.vector) | Create Hash Value with operation 'Vector'. |

##### color { #nodebpy.nodes.converter.HashValue.color }

```python
nodes.converter.HashValue.color(value=None, seed=0)
```

Create Hash Value with operation 'Color'.

##### float { #nodebpy.nodes.converter.HashValue.float }

```python
nodes.converter.HashValue.float(value=0.0, seed=0)
```

Create Hash Value with operation 'Float'.

##### integer { #nodebpy.nodes.converter.HashValue.integer }

```python
nodes.converter.HashValue.integer(value=0, seed=0)
```

Create Hash Value with operation 'Integer'.

##### matrix { #nodebpy.nodes.converter.HashValue.matrix }

```python
nodes.converter.HashValue.matrix(value=None, seed=0)
```

Create Hash Value with operation 'Matrix'.

##### rotation { #nodebpy.nodes.converter.HashValue.rotation }

```python
nodes.converter.HashValue.rotation(value=None, seed=0)
```

Create Hash Value with operation 'Rotation'.

##### string { #nodebpy.nodes.converter.HashValue.string }

```python
nodes.converter.HashValue.string(value='', seed=0)
```

Create Hash Value with operation 'String'.

##### vector { #nodebpy.nodes.converter.HashValue.vector }

```python
nodes.converter.HashValue.vector(value=None, seed=0)
```

Create Hash Value with operation 'Vector'.

### IndexOfNearest { #nodebpy.nodes.converter.IndexOfNearest }

```python
nodes.converter.IndexOfNearest(position=None, group_id=0)
```

Find the nearest element in a group. Similar to the "Sample Nearest" node

#### Attributes

| Name | Description |
| --- | --- |
| [i_group_id](#nodebpy.nodes.converter.IndexOfNearest.i_group_id) | Input socket: Group ID |
| [i_position](#nodebpy.nodes.converter.IndexOfNearest.i_position) | Input socket: Position |
| [name](#nodebpy.nodes.converter.IndexOfNearest.name) |  |
| [node](#nodebpy.nodes.converter.IndexOfNearest.node) |  |
| [o_has_neighbor](#nodebpy.nodes.converter.IndexOfNearest.o_has_neighbor) | Output socket: Has Neighbor |
| [o_index](#nodebpy.nodes.converter.IndexOfNearest.o_index) | Output socket: Index |
| [tree](#nodebpy.nodes.converter.IndexOfNearest.tree) |  |
| [type](#nodebpy.nodes.converter.IndexOfNearest.type) |  |

### IntegerMath { #nodebpy.nodes.converter.IntegerMath }

```python
nodes.converter.IntegerMath(
    value=0,
    value_001=0,
    value_002=0,
    *,
    operation='ADD',
)
```

Perform various math operations on the given integer inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.converter.IntegerMath.i_value) | Input socket: Value |
| [i_value_001](#nodebpy.nodes.converter.IntegerMath.i_value_001) | Input socket: Value |
| [i_value_002](#nodebpy.nodes.converter.IntegerMath.i_value_002) | Input socket: Value |
| [name](#nodebpy.nodes.converter.IntegerMath.name) |  |
| [node](#nodebpy.nodes.converter.IntegerMath.node) |  |
| [o_value](#nodebpy.nodes.converter.IntegerMath.o_value) | Output socket: Value |
| [operation](#nodebpy.nodes.converter.IntegerMath.operation) |  |
| [tree](#nodebpy.nodes.converter.IntegerMath.tree) |  |
| [type](#nodebpy.nodes.converter.IntegerMath.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.converter.IntegerMath.absolute) | Create Integer Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.converter.IntegerMath.add) | Create Integer Math with operation 'Add'. |
| [divide](#nodebpy.nodes.converter.IntegerMath.divide) | Create Integer Math with operation 'Divide'. |
| [maximum](#nodebpy.nodes.converter.IntegerMath.maximum) | Create Integer Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.converter.IntegerMath.minimum) | Create Integer Math with operation 'Minimum'. |
| [modulo](#nodebpy.nodes.converter.IntegerMath.modulo) | Create Integer Math with operation 'Modulo'. |
| [multiply](#nodebpy.nodes.converter.IntegerMath.multiply) | Create Integer Math with operation 'Multiply'. |
| [negate](#nodebpy.nodes.converter.IntegerMath.negate) | Create Integer Math with operation 'Negate'. |
| [power](#nodebpy.nodes.converter.IntegerMath.power) | Create Integer Math with operation 'Power'. |
| [sign](#nodebpy.nodes.converter.IntegerMath.sign) | Create Integer Math with operation 'Sign'. |
| [subtract](#nodebpy.nodes.converter.IntegerMath.subtract) | Create Integer Math with operation 'Subtract'. |

##### absolute { #nodebpy.nodes.converter.IntegerMath.absolute }

```python
nodes.converter.IntegerMath.absolute(value=0)
```

Create Integer Math with operation 'Absolute'.

##### add { #nodebpy.nodes.converter.IntegerMath.add }

```python
nodes.converter.IntegerMath.add(value=0, value_001=0)
```

Create Integer Math with operation 'Add'.

##### divide { #nodebpy.nodes.converter.IntegerMath.divide }

```python
nodes.converter.IntegerMath.divide(value=0, value_001=0)
```

Create Integer Math with operation 'Divide'.

##### maximum { #nodebpy.nodes.converter.IntegerMath.maximum }

```python
nodes.converter.IntegerMath.maximum(value=0, value_001=0)
```

Create Integer Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.converter.IntegerMath.minimum }

```python
nodes.converter.IntegerMath.minimum(value=0, value_001=0)
```

Create Integer Math with operation 'Minimum'.

##### modulo { #nodebpy.nodes.converter.IntegerMath.modulo }

```python
nodes.converter.IntegerMath.modulo(value=0, value_001=0)
```

Create Integer Math with operation 'Modulo'.

##### multiply { #nodebpy.nodes.converter.IntegerMath.multiply }

```python
nodes.converter.IntegerMath.multiply(value=0, value_001=0)
```

Create Integer Math with operation 'Multiply'.

##### negate { #nodebpy.nodes.converter.IntegerMath.negate }

```python
nodes.converter.IntegerMath.negate(value=0)
```

Create Integer Math with operation 'Negate'.

##### power { #nodebpy.nodes.converter.IntegerMath.power }

```python
nodes.converter.IntegerMath.power(value=0, value_001=0)
```

Create Integer Math with operation 'Power'.

##### sign { #nodebpy.nodes.converter.IntegerMath.sign }

```python
nodes.converter.IntegerMath.sign(value=0)
```

Create Integer Math with operation 'Sign'.

##### subtract { #nodebpy.nodes.converter.IntegerMath.subtract }

```python
nodes.converter.IntegerMath.subtract(value=0, value_001=0)
```

Create Integer Math with operation 'Subtract'.

### InvertMatrix { #nodebpy.nodes.converter.InvertMatrix }

```python
nodes.converter.InvertMatrix(matrix=None)
```

Compute the inverse of the given matrix, if one exists

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.InvertMatrix.i_matrix) | Input socket: Matrix |
| [name](#nodebpy.nodes.converter.InvertMatrix.name) |  |
| [node](#nodebpy.nodes.converter.InvertMatrix.node) |  |
| [o_invertible](#nodebpy.nodes.converter.InvertMatrix.o_invertible) | Output socket: Invertible |
| [o_matrix](#nodebpy.nodes.converter.InvertMatrix.o_matrix) | Output socket: Matrix |
| [tree](#nodebpy.nodes.converter.InvertMatrix.tree) |  |
| [type](#nodebpy.nodes.converter.InvertMatrix.type) |  |

### InvertRotation { #nodebpy.nodes.converter.InvertRotation }

```python
nodes.converter.InvertRotation(rotation=None)
```

Compute the inverse of the given rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.InvertRotation.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.InvertRotation.name) |  |
| [node](#nodebpy.nodes.converter.InvertRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.InvertRotation.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.converter.InvertRotation.tree) |  |
| [type](#nodebpy.nodes.converter.InvertRotation.type) |  |

### JoinBundle { #nodebpy.nodes.converter.JoinBundle }

```python
nodes.converter.JoinBundle(bundle=None)
```

Join multiple bundles together

#### Attributes

| Name | Description |
| --- | --- |
| [i_bundle](#nodebpy.nodes.converter.JoinBundle.i_bundle) | Input socket: Bundle |
| [name](#nodebpy.nodes.converter.JoinBundle.name) |  |
| [node](#nodebpy.nodes.converter.JoinBundle.node) |  |
| [o_bundle](#nodebpy.nodes.converter.JoinBundle.o_bundle) | Output socket: Bundle |
| [tree](#nodebpy.nodes.converter.JoinBundle.tree) |  |
| [type](#nodebpy.nodes.converter.JoinBundle.type) |  |

### MapRange { #nodebpy.nodes.converter.MapRange }

```python
nodes.converter.MapRange(
    value=1.0,
    from_min=0.0,
    from_max=1.0,
    to_min=0.0,
    to_max=1.0,
    steps=4.0,
    vector=None,
    from_min_float3=None,
    from_max_float3=None,
    to_min_float3=None,
    to_max_float3=None,
    steps_float3=None,
    *,
    clamp=False,
    interpolation_type='LINEAR',
    data_type='FLOAT',
)
```

Remap a value from a range to a target range

#### Attributes

| Name | Description |
| --- | --- |
| [clamp](#nodebpy.nodes.converter.MapRange.clamp) |  |
| [data_type](#nodebpy.nodes.converter.MapRange.data_type) |  |
| [i_from_max](#nodebpy.nodes.converter.MapRange.i_from_max) | Input socket: From Max |
| [i_from_max_float3](#nodebpy.nodes.converter.MapRange.i_from_max_float3) | Input socket: From Max |
| [i_from_min](#nodebpy.nodes.converter.MapRange.i_from_min) | Input socket: From Min |
| [i_from_min_float3](#nodebpy.nodes.converter.MapRange.i_from_min_float3) | Input socket: From Min |
| [i_steps](#nodebpy.nodes.converter.MapRange.i_steps) | Input socket: Steps |
| [i_steps_float3](#nodebpy.nodes.converter.MapRange.i_steps_float3) | Input socket: Steps |
| [i_to_max](#nodebpy.nodes.converter.MapRange.i_to_max) | Input socket: To Max |
| [i_to_max_float3](#nodebpy.nodes.converter.MapRange.i_to_max_float3) | Input socket: To Max |
| [i_to_min](#nodebpy.nodes.converter.MapRange.i_to_min) | Input socket: To Min |
| [i_to_min_float3](#nodebpy.nodes.converter.MapRange.i_to_min_float3) | Input socket: To Min |
| [i_value](#nodebpy.nodes.converter.MapRange.i_value) | Input socket: Value |
| [i_vector](#nodebpy.nodes.converter.MapRange.i_vector) | Input socket: Vector |
| [interpolation_type](#nodebpy.nodes.converter.MapRange.interpolation_type) |  |
| [name](#nodebpy.nodes.converter.MapRange.name) |  |
| [node](#nodebpy.nodes.converter.MapRange.node) |  |
| [o_result](#nodebpy.nodes.converter.MapRange.o_result) | Output socket: Result |
| [o_vector](#nodebpy.nodes.converter.MapRange.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.converter.MapRange.tree) |  |
| [type](#nodebpy.nodes.converter.MapRange.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [float](#nodebpy.nodes.converter.MapRange.float) | Create Map Range with operation 'Float'. |
| [vector](#nodebpy.nodes.converter.MapRange.vector) | Create Map Range with operation 'Vector'. |

##### float { #nodebpy.nodes.converter.MapRange.float }

```python
nodes.converter.MapRange.float(
    value=1.0,
    from_min=0.0,
    from_max=1.0,
    to_min=0.0,
    to_max=1.0,
)
```

Create Map Range with operation 'Float'.

##### vector { #nodebpy.nodes.converter.MapRange.vector }

```python
nodes.converter.MapRange.vector(
    vector=None,
    from_min3=None,
    from_max3=None,
    to_min3=None,
    to_max3=None,
)
```

Create Map Range with operation 'Vector'.

### MatchString { #nodebpy.nodes.converter.MatchString }

```python
nodes.converter.MatchString(string='', operation='Starts With', key='')
```

Check if a given string exists within another string

#### Attributes

| Name | Description |
| --- | --- |
| [i_key](#nodebpy.nodes.converter.MatchString.i_key) | Input socket: Key |
| [i_operation](#nodebpy.nodes.converter.MatchString.i_operation) | Input socket: Operation |
| [i_string](#nodebpy.nodes.converter.MatchString.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.MatchString.name) |  |
| [node](#nodebpy.nodes.converter.MatchString.node) |  |
| [o_result](#nodebpy.nodes.converter.MatchString.o_result) | Output socket: Result |
| [tree](#nodebpy.nodes.converter.MatchString.tree) |  |
| [type](#nodebpy.nodes.converter.MatchString.type) |  |

### Math { #nodebpy.nodes.converter.Math }

```python
nodes.converter.Math(
    value=0.5,
    value_001=0.5,
    value_002=0.5,
    *,
    operation='ADD',
    use_clamp=False,
)
```

Perform math operations

#### Attributes

| Name | Description |
| --- | --- |
| [i_value](#nodebpy.nodes.converter.Math.i_value) | Input socket: Value |
| [i_value_001](#nodebpy.nodes.converter.Math.i_value_001) | Input socket: Value |
| [i_value_002](#nodebpy.nodes.converter.Math.i_value_002) | Input socket: Value |
| [name](#nodebpy.nodes.converter.Math.name) |  |
| [node](#nodebpy.nodes.converter.Math.node) |  |
| [o_value](#nodebpy.nodes.converter.Math.o_value) | Output socket: Value |
| [operation](#nodebpy.nodes.converter.Math.operation) |  |
| [tree](#nodebpy.nodes.converter.Math.tree) |  |
| [type](#nodebpy.nodes.converter.Math.type) |  |
| [use_clamp](#nodebpy.nodes.converter.Math.use_clamp) |  |

#### Methods

| Name | Description |
| --- | --- |
| [absolute](#nodebpy.nodes.converter.Math.absolute) | Create Math with operation 'Absolute'. |
| [add](#nodebpy.nodes.converter.Math.add) | Create Math with operation 'Add'. |
| [arccosine](#nodebpy.nodes.converter.Math.arccosine) | Create Math with operation 'Arccosine'. |
| [arcsine](#nodebpy.nodes.converter.Math.arcsine) | Create Math with operation 'Arcsine'. |
| [arctan2](#nodebpy.nodes.converter.Math.arctan2) | Create Math with operation 'Arctan2'. |
| [arctangent](#nodebpy.nodes.converter.Math.arctangent) | Create Math with operation 'Arctangent'. |
| [ceil](#nodebpy.nodes.converter.Math.ceil) | Create Math with operation 'Ceil'. |
| [compare](#nodebpy.nodes.converter.Math.compare) | Create Math with operation 'Compare'. |
| [cosine](#nodebpy.nodes.converter.Math.cosine) | Create Math with operation 'Cosine'. |
| [divide](#nodebpy.nodes.converter.Math.divide) | Create Math with operation 'Divide'. |
| [exponent](#nodebpy.nodes.converter.Math.exponent) | Create Math with operation 'Exponent'. |
| [floor](#nodebpy.nodes.converter.Math.floor) | Create Math with operation 'Floor'. |
| [fraction](#nodebpy.nodes.converter.Math.fraction) | Create Math with operation 'Fraction'. |
| [logarithm](#nodebpy.nodes.converter.Math.logarithm) | Create Math with operation 'Logarithm'. |
| [maximum](#nodebpy.nodes.converter.Math.maximum) | Create Math with operation 'Maximum'. |
| [minimum](#nodebpy.nodes.converter.Math.minimum) | Create Math with operation 'Minimum'. |
| [multiply](#nodebpy.nodes.converter.Math.multiply) | Create Math with operation 'Multiply'. |
| [power](#nodebpy.nodes.converter.Math.power) | Create Math with operation 'Power'. |
| [round](#nodebpy.nodes.converter.Math.round) | Create Math with operation 'Round'. |
| [sign](#nodebpy.nodes.converter.Math.sign) | Create Math with operation 'Sign'. |
| [sine](#nodebpy.nodes.converter.Math.sine) | Create Math with operation 'Sine'. |
| [snap](#nodebpy.nodes.converter.Math.snap) | Create Math with operation 'Snap'. |
| [subtract](#nodebpy.nodes.converter.Math.subtract) | Create Math with operation 'Subtract'. |
| [tangent](#nodebpy.nodes.converter.Math.tangent) | Create Math with operation 'Tangent'. |
| [truncate](#nodebpy.nodes.converter.Math.truncate) | Create Math with operation 'Truncate'. |
| [wrap](#nodebpy.nodes.converter.Math.wrap) | Create Math with operation 'Wrap'. |

##### absolute { #nodebpy.nodes.converter.Math.absolute }

```python
nodes.converter.Math.absolute(value=0.5)
```

Create Math with operation 'Absolute'.

##### add { #nodebpy.nodes.converter.Math.add }

```python
nodes.converter.Math.add(value=0.5, value_001=0.5)
```

Create Math with operation 'Add'.

##### arccosine { #nodebpy.nodes.converter.Math.arccosine }

```python
nodes.converter.Math.arccosine(value=0.5)
```

Create Math with operation 'Arccosine'.

##### arcsine { #nodebpy.nodes.converter.Math.arcsine }

```python
nodes.converter.Math.arcsine(value=0.5)
```

Create Math with operation 'Arcsine'.

##### arctan2 { #nodebpy.nodes.converter.Math.arctan2 }

```python
nodes.converter.Math.arctan2(value=0.5, value_001=0.5)
```

Create Math with operation 'Arctan2'.

##### arctangent { #nodebpy.nodes.converter.Math.arctangent }

```python
nodes.converter.Math.arctangent(value=0.5)
```

Create Math with operation 'Arctangent'.

##### ceil { #nodebpy.nodes.converter.Math.ceil }

```python
nodes.converter.Math.ceil(value=0.5)
```

Create Math with operation 'Ceil'.

##### compare { #nodebpy.nodes.converter.Math.compare }

```python
nodes.converter.Math.compare(value=0.5, value_001=0.5, value_002=0.5)
```

Create Math with operation 'Compare'.

##### cosine { #nodebpy.nodes.converter.Math.cosine }

```python
nodes.converter.Math.cosine(value=0.5)
```

Create Math with operation 'Cosine'.

##### divide { #nodebpy.nodes.converter.Math.divide }

```python
nodes.converter.Math.divide(value=0.5, value_001=0.5)
```

Create Math with operation 'Divide'.

##### exponent { #nodebpy.nodes.converter.Math.exponent }

```python
nodes.converter.Math.exponent(value=0.5)
```

Create Math with operation 'Exponent'.

##### floor { #nodebpy.nodes.converter.Math.floor }

```python
nodes.converter.Math.floor(value=0.5)
```

Create Math with operation 'Floor'.

##### fraction { #nodebpy.nodes.converter.Math.fraction }

```python
nodes.converter.Math.fraction(value=0.5)
```

Create Math with operation 'Fraction'.

##### logarithm { #nodebpy.nodes.converter.Math.logarithm }

```python
nodes.converter.Math.logarithm(value=0.5, value_001=0.5)
```

Create Math with operation 'Logarithm'.

##### maximum { #nodebpy.nodes.converter.Math.maximum }

```python
nodes.converter.Math.maximum(value=0.5, value_001=0.5)
```

Create Math with operation 'Maximum'.

##### minimum { #nodebpy.nodes.converter.Math.minimum }

```python
nodes.converter.Math.minimum(value=0.5, value_001=0.5)
```

Create Math with operation 'Minimum'.

##### multiply { #nodebpy.nodes.converter.Math.multiply }

```python
nodes.converter.Math.multiply(value=0.5, value_001=0.5)
```

Create Math with operation 'Multiply'.

##### power { #nodebpy.nodes.converter.Math.power }

```python
nodes.converter.Math.power(value=0.5, value_001=0.5)
```

Create Math with operation 'Power'.

##### round { #nodebpy.nodes.converter.Math.round }

```python
nodes.converter.Math.round(value=0.5)
```

Create Math with operation 'Round'.

##### sign { #nodebpy.nodes.converter.Math.sign }

```python
nodes.converter.Math.sign(value=0.5)
```

Create Math with operation 'Sign'.

##### sine { #nodebpy.nodes.converter.Math.sine }

```python
nodes.converter.Math.sine(value=0.5)
```

Create Math with operation 'Sine'.

##### snap { #nodebpy.nodes.converter.Math.snap }

```python
nodes.converter.Math.snap(value=0.5, value_001=0.5)
```

Create Math with operation 'Snap'.

##### subtract { #nodebpy.nodes.converter.Math.subtract }

```python
nodes.converter.Math.subtract(value=0.5, value_001=0.5)
```

Create Math with operation 'Subtract'.

##### tangent { #nodebpy.nodes.converter.Math.tangent }

```python
nodes.converter.Math.tangent(value=0.5)
```

Create Math with operation 'Tangent'.

##### truncate { #nodebpy.nodes.converter.Math.truncate }

```python
nodes.converter.Math.truncate(value=0.5)
```

Create Math with operation 'Truncate'.

##### wrap { #nodebpy.nodes.converter.Math.wrap }

```python
nodes.converter.Math.wrap(value=0.5, value_001=0.5, value_002=0.5)
```

Create Math with operation 'Wrap'.

### MatrixDeterminant { #nodebpy.nodes.converter.MatrixDeterminant }

```python
nodes.converter.MatrixDeterminant(matrix=None)
```

Compute the determinant of the given matrix

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.MatrixDeterminant.i_matrix) | Input socket: Matrix |
| [name](#nodebpy.nodes.converter.MatrixDeterminant.name) |  |
| [node](#nodebpy.nodes.converter.MatrixDeterminant.node) |  |
| [o_determinant](#nodebpy.nodes.converter.MatrixDeterminant.o_determinant) | Output socket: Determinant |
| [tree](#nodebpy.nodes.converter.MatrixDeterminant.tree) |  |
| [type](#nodebpy.nodes.converter.MatrixDeterminant.type) |  |

### Mix { #nodebpy.nodes.converter.Mix }

```python
nodes.converter.Mix(
    factor_float=0.5,
    factor_vector=None,
    a_float=0.0,
    b_float=0.0,
    a_vector=None,
    b_vector=None,
    a_color=None,
    b_color=None,
    a_rotation=None,
    b_rotation=None,
    *,
    data_type='FLOAT',
    factor_mode='UNIFORM',
    blend_type='MIX',
    clamp_factor=False,
    clamp_result=False,
)
```

Mix values by a factor

#### Attributes

| Name | Description |
| --- | --- |
| [blend_type](#nodebpy.nodes.converter.Mix.blend_type) |  |
| [clamp_factor](#nodebpy.nodes.converter.Mix.clamp_factor) |  |
| [clamp_result](#nodebpy.nodes.converter.Mix.clamp_result) |  |
| [data_type](#nodebpy.nodes.converter.Mix.data_type) |  |
| [factor_mode](#nodebpy.nodes.converter.Mix.factor_mode) |  |
| [i_a_color](#nodebpy.nodes.converter.Mix.i_a_color) | Input socket: A |
| [i_a_float](#nodebpy.nodes.converter.Mix.i_a_float) | Input socket: A |
| [i_a_rotation](#nodebpy.nodes.converter.Mix.i_a_rotation) | Input socket: A |
| [i_a_vector](#nodebpy.nodes.converter.Mix.i_a_vector) | Input socket: A |
| [i_b_color](#nodebpy.nodes.converter.Mix.i_b_color) | Input socket: B |
| [i_b_float](#nodebpy.nodes.converter.Mix.i_b_float) | Input socket: B |
| [i_b_rotation](#nodebpy.nodes.converter.Mix.i_b_rotation) | Input socket: B |
| [i_b_vector](#nodebpy.nodes.converter.Mix.i_b_vector) | Input socket: B |
| [i_factor_float](#nodebpy.nodes.converter.Mix.i_factor_float) | Input socket: Factor |
| [i_factor_vector](#nodebpy.nodes.converter.Mix.i_factor_vector) | Input socket: Factor |
| [name](#nodebpy.nodes.converter.Mix.name) |  |
| [node](#nodebpy.nodes.converter.Mix.node) |  |
| [o_result_color](#nodebpy.nodes.converter.Mix.o_result_color) | Output socket: Result |
| [o_result_float](#nodebpy.nodes.converter.Mix.o_result_float) | Output socket: Result |
| [o_result_rotation](#nodebpy.nodes.converter.Mix.o_result_rotation) | Output socket: Result |
| [o_result_vector](#nodebpy.nodes.converter.Mix.o_result_vector) | Output socket: Result |
| [tree](#nodebpy.nodes.converter.Mix.tree) |  |
| [type](#nodebpy.nodes.converter.Mix.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [color](#nodebpy.nodes.converter.Mix.color) | Create Mix with operation 'Color'. |
| [float](#nodebpy.nodes.converter.Mix.float) | Create Mix with operation 'Float'. |
| [rotation](#nodebpy.nodes.converter.Mix.rotation) | Create Mix with operation 'Rotation'. |
| [vector](#nodebpy.nodes.converter.Mix.vector) | Create Mix with operation 'Vector'. |

##### color { #nodebpy.nodes.converter.Mix.color }

```python
nodes.converter.Mix.color(factor=0.5, a_color=None, b_color=None)
```

Create Mix with operation 'Color'.

##### float { #nodebpy.nodes.converter.Mix.float }

```python
nodes.converter.Mix.float(factor=0.5, a=0.0, b=0.0)
```

Create Mix with operation 'Float'.

##### rotation { #nodebpy.nodes.converter.Mix.rotation }

```python
nodes.converter.Mix.rotation(factor=0.5, a_rotation=None, b_rotation=None)
```

Create Mix with operation 'Rotation'.

##### vector { #nodebpy.nodes.converter.Mix.vector }

```python
nodes.converter.Mix.vector(factor=0.5, a=None, b=None)
```

Create Mix with operation 'Vector'.

### MultiplyMatrices { #nodebpy.nodes.converter.MultiplyMatrices }

```python
nodes.converter.MultiplyMatrices(matrix=None, matrix_001=None)
```

Perform a matrix multiplication on two input matrices

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.MultiplyMatrices.i_matrix) | Input socket: Matrix |
| [i_matrix_001](#nodebpy.nodes.converter.MultiplyMatrices.i_matrix_001) | Input socket: Matrix |
| [name](#nodebpy.nodes.converter.MultiplyMatrices.name) |  |
| [node](#nodebpy.nodes.converter.MultiplyMatrices.node) |  |
| [o_matrix](#nodebpy.nodes.converter.MultiplyMatrices.o_matrix) | Output socket: Matrix |
| [tree](#nodebpy.nodes.converter.MultiplyMatrices.tree) |  |
| [type](#nodebpy.nodes.converter.MultiplyMatrices.type) |  |

### PackUVIslands { #nodebpy.nodes.converter.PackUVIslands }

```python
nodes.converter.PackUVIslands(
    uv=None,
    selection=True,
    margin=0.001,
    rotate=True,
    method='Bounding Box',
)
```

Scale islands of a UV map and move them so they fill the UV space as much as possible

#### Attributes

| Name | Description |
| --- | --- |
| [i_margin](#nodebpy.nodes.converter.PackUVIslands.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.converter.PackUVIslands.i_method) | Input socket: Method |
| [i_rotate](#nodebpy.nodes.converter.PackUVIslands.i_rotate) | Input socket: Rotate |
| [i_selection](#nodebpy.nodes.converter.PackUVIslands.i_selection) | Input socket: Selection |
| [i_uv](#nodebpy.nodes.converter.PackUVIslands.i_uv) | Input socket: UV |
| [name](#nodebpy.nodes.converter.PackUVIslands.name) |  |
| [node](#nodebpy.nodes.converter.PackUVIslands.node) |  |
| [o_uv](#nodebpy.nodes.converter.PackUVIslands.o_uv) | Output socket: UV |
| [tree](#nodebpy.nodes.converter.PackUVIslands.tree) |  |
| [type](#nodebpy.nodes.converter.PackUVIslands.type) |  |

### ProjectPoint { #nodebpy.nodes.converter.ProjectPoint }

```python
nodes.converter.ProjectPoint(vector=None, transform=None)
```

Project a point using a matrix, using location, rotation, scale, and perspective divide

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.ProjectPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.converter.ProjectPoint.i_vector) | Input socket: Vector |
| [name](#nodebpy.nodes.converter.ProjectPoint.name) |  |
| [node](#nodebpy.nodes.converter.ProjectPoint.node) |  |
| [o_vector](#nodebpy.nodes.converter.ProjectPoint.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.converter.ProjectPoint.tree) |  |
| [type](#nodebpy.nodes.converter.ProjectPoint.type) |  |

### QuaternionToRotation { #nodebpy.nodes.converter.QuaternionToRotation }

```python
nodes.converter.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0)
```

Build a rotation from quaternion components

#### Attributes

| Name | Description |
| --- | --- |
| [i_w](#nodebpy.nodes.converter.QuaternionToRotation.i_w) | Input socket: W |
| [i_x](#nodebpy.nodes.converter.QuaternionToRotation.i_x) | Input socket: X |
| [i_y](#nodebpy.nodes.converter.QuaternionToRotation.i_y) | Input socket: Y |
| [i_z](#nodebpy.nodes.converter.QuaternionToRotation.i_z) | Input socket: Z |
| [name](#nodebpy.nodes.converter.QuaternionToRotation.name) |  |
| [node](#nodebpy.nodes.converter.QuaternionToRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.QuaternionToRotation.o_rotation) | Output socket: Rotation |
| [tree](#nodebpy.nodes.converter.QuaternionToRotation.tree) |  |
| [type](#nodebpy.nodes.converter.QuaternionToRotation.type) |  |

### RandomValue { #nodebpy.nodes.converter.RandomValue }

```python
nodes.converter.RandomValue(
    min=None,
    max=None,
    min_001=0.0,
    max_001=1.0,
    min_002=0,
    max_002=100,
    probability=0.5,
    id=0,
    seed=0,
    *,
    data_type='FLOAT',
)
```

Output a randomized value

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.RandomValue.data_type) |  |
| [i_id](#nodebpy.nodes.converter.RandomValue.i_id) | Input socket: ID |
| [i_max](#nodebpy.nodes.converter.RandomValue.i_max) | Input socket: Max |
| [i_max_001](#nodebpy.nodes.converter.RandomValue.i_max_001) | Input socket: Max |
| [i_max_002](#nodebpy.nodes.converter.RandomValue.i_max_002) | Input socket: Max |
| [i_min](#nodebpy.nodes.converter.RandomValue.i_min) | Input socket: Min |
| [i_min_001](#nodebpy.nodes.converter.RandomValue.i_min_001) | Input socket: Min |
| [i_min_002](#nodebpy.nodes.converter.RandomValue.i_min_002) | Input socket: Min |
| [i_probability](#nodebpy.nodes.converter.RandomValue.i_probability) | Input socket: Probability |
| [i_seed](#nodebpy.nodes.converter.RandomValue.i_seed) | Input socket: Seed |
| [name](#nodebpy.nodes.converter.RandomValue.name) |  |
| [node](#nodebpy.nodes.converter.RandomValue.node) |  |
| [o_value](#nodebpy.nodes.converter.RandomValue.o_value) | Output socket: Value |
| [o_value_001](#nodebpy.nodes.converter.RandomValue.o_value_001) | Output socket: Value |
| [o_value_002](#nodebpy.nodes.converter.RandomValue.o_value_002) | Output socket: Value |
| [o_value_003](#nodebpy.nodes.converter.RandomValue.o_value_003) | Output socket: Value |
| [tree](#nodebpy.nodes.converter.RandomValue.tree) |  |
| [type](#nodebpy.nodes.converter.RandomValue.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.converter.RandomValue.boolean) | Create Random Value with operation 'Boolean'. |
| [float](#nodebpy.nodes.converter.RandomValue.float) | Create Random Value with operation 'Float'. |
| [integer](#nodebpy.nodes.converter.RandomValue.integer) | Create Random Value with operation 'Integer'. |
| [vector](#nodebpy.nodes.converter.RandomValue.vector) | Create Random Value with operation 'Vector'. |

##### boolean { #nodebpy.nodes.converter.RandomValue.boolean }

```python
nodes.converter.RandomValue.boolean(probability=0.5, id=0, seed=0)
```

Create Random Value with operation 'Boolean'.

##### float { #nodebpy.nodes.converter.RandomValue.float }

```python
nodes.converter.RandomValue.float(min=0.0, max=1.0, id=0, seed=0)
```

Create Random Value with operation 'Float'.

##### integer { #nodebpy.nodes.converter.RandomValue.integer }

```python
nodes.converter.RandomValue.integer(min=0, max=100, id=0, seed=0)
```

Create Random Value with operation 'Integer'.

##### vector { #nodebpy.nodes.converter.RandomValue.vector }

```python
nodes.converter.RandomValue.vector(min=None, max=None, id=0, seed=0)
```

Create Random Value with operation 'Vector'.

### ReplaceString { #nodebpy.nodes.converter.ReplaceString }

```python
nodes.converter.ReplaceString(string='', find='', replace='')
```

Replace a given string segment with another

#### Attributes

| Name | Description |
| --- | --- |
| [i_find](#nodebpy.nodes.converter.ReplaceString.i_find) | Input socket: Find |
| [i_replace](#nodebpy.nodes.converter.ReplaceString.i_replace) | Input socket: Replace |
| [i_string](#nodebpy.nodes.converter.ReplaceString.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.ReplaceString.name) |  |
| [node](#nodebpy.nodes.converter.ReplaceString.node) |  |
| [o_string](#nodebpy.nodes.converter.ReplaceString.o_string) | Output socket: String |
| [tree](#nodebpy.nodes.converter.ReplaceString.tree) |  |
| [type](#nodebpy.nodes.converter.ReplaceString.type) |  |

### RotateEuler { #nodebpy.nodes.converter.RotateEuler }

```python
nodes.converter.RotateEuler(
    rotation=None,
    rotate_by=None,
    axis=None,
    angle=0.0,
    *,
    rotation_type='EULER',
    space='OBJECT',
)
```

Apply a secondary Euler rotation to a given Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_angle](#nodebpy.nodes.converter.RotateEuler.i_angle) | Input socket: Angle |
| [i_axis](#nodebpy.nodes.converter.RotateEuler.i_axis) | Input socket: Axis |
| [i_rotate_by](#nodebpy.nodes.converter.RotateEuler.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.converter.RotateEuler.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.RotateEuler.name) |  |
| [node](#nodebpy.nodes.converter.RotateEuler.node) |  |
| [o_rotation](#nodebpy.nodes.converter.RotateEuler.o_rotation) | Output socket: Rotation |
| [rotation_type](#nodebpy.nodes.converter.RotateEuler.rotation_type) |  |
| [space](#nodebpy.nodes.converter.RotateEuler.space) |  |
| [tree](#nodebpy.nodes.converter.RotateEuler.tree) |  |
| [type](#nodebpy.nodes.converter.RotateEuler.type) |  |

### RotateRotation { #nodebpy.nodes.converter.RotateRotation }

```python
nodes.converter.RotateRotation(
    rotation=None,
    rotate_by=None,
    *,
    rotation_space='GLOBAL',
)
```

Apply a secondary rotation to a given rotation value

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotate_by](#nodebpy.nodes.converter.RotateRotation.i_rotate_by) | Input socket: Rotate By |
| [i_rotation](#nodebpy.nodes.converter.RotateRotation.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.RotateRotation.name) |  |
| [node](#nodebpy.nodes.converter.RotateRotation.node) |  |
| [o_rotation](#nodebpy.nodes.converter.RotateRotation.o_rotation) | Output socket: Rotation |
| [rotation_space](#nodebpy.nodes.converter.RotateRotation.rotation_space) |  |
| [tree](#nodebpy.nodes.converter.RotateRotation.tree) |  |
| [type](#nodebpy.nodes.converter.RotateRotation.type) |  |

### RotateVector { #nodebpy.nodes.converter.RotateVector }

```python
nodes.converter.RotateVector(vector=None, rotation=None)
```

Apply a rotation to a given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotateVector.i_rotation) | Input socket: Rotation |
| [i_vector](#nodebpy.nodes.converter.RotateVector.i_vector) | Input socket: Vector |
| [name](#nodebpy.nodes.converter.RotateVector.name) |  |
| [node](#nodebpy.nodes.converter.RotateVector.node) |  |
| [o_vector](#nodebpy.nodes.converter.RotateVector.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.converter.RotateVector.tree) |  |
| [type](#nodebpy.nodes.converter.RotateVector.type) |  |

### RotationToAxisAngle { #nodebpy.nodes.converter.RotationToAxisAngle }

```python
nodes.converter.RotationToAxisAngle(rotation=None)
```

Convert a rotation to axis angle components

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToAxisAngle.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.RotationToAxisAngle.name) |  |
| [node](#nodebpy.nodes.converter.RotationToAxisAngle.node) |  |
| [o_angle](#nodebpy.nodes.converter.RotationToAxisAngle.o_angle) | Output socket: Angle |
| [o_axis](#nodebpy.nodes.converter.RotationToAxisAngle.o_axis) | Output socket: Axis |
| [tree](#nodebpy.nodes.converter.RotationToAxisAngle.tree) |  |
| [type](#nodebpy.nodes.converter.RotationToAxisAngle.type) |  |

### RotationToEuler { #nodebpy.nodes.converter.RotationToEuler }

```python
nodes.converter.RotationToEuler(rotation=None)
```

Convert a standard rotation value to an Euler rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToEuler.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.RotationToEuler.name) |  |
| [node](#nodebpy.nodes.converter.RotationToEuler.node) |  |
| [o_euler](#nodebpy.nodes.converter.RotationToEuler.o_euler) | Output socket: Euler |
| [tree](#nodebpy.nodes.converter.RotationToEuler.tree) |  |
| [type](#nodebpy.nodes.converter.RotationToEuler.type) |  |

### RotationToQuaternion { #nodebpy.nodes.converter.RotationToQuaternion }

```python
nodes.converter.RotationToQuaternion(rotation=None)
```

Retrieve the quaternion components representing a rotation

#### Attributes

| Name | Description |
| --- | --- |
| [i_rotation](#nodebpy.nodes.converter.RotationToQuaternion.i_rotation) | Input socket: Rotation |
| [name](#nodebpy.nodes.converter.RotationToQuaternion.name) |  |
| [node](#nodebpy.nodes.converter.RotationToQuaternion.node) |  |
| [o_w](#nodebpy.nodes.converter.RotationToQuaternion.o_w) | Output socket: W |
| [o_x](#nodebpy.nodes.converter.RotationToQuaternion.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.converter.RotationToQuaternion.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.converter.RotationToQuaternion.o_z) | Output socket: Z |
| [tree](#nodebpy.nodes.converter.RotationToQuaternion.tree) |  |
| [type](#nodebpy.nodes.converter.RotationToQuaternion.type) |  |

### SeparateBundle { #nodebpy.nodes.converter.SeparateBundle }

```python
nodes.converter.SeparateBundle(bundle=None, *, define_signature=False)
```

Split a bundle into multiple sockets.

#### Attributes

| Name | Description |
| --- | --- |
| [define_signature](#nodebpy.nodes.converter.SeparateBundle.define_signature) |  |
| [i_bundle](#nodebpy.nodes.converter.SeparateBundle.i_bundle) | Input socket: Bundle |
| [name](#nodebpy.nodes.converter.SeparateBundle.name) |  |
| [node](#nodebpy.nodes.converter.SeparateBundle.node) |  |
| [tree](#nodebpy.nodes.converter.SeparateBundle.tree) |  |
| [type](#nodebpy.nodes.converter.SeparateBundle.type) |  |

### SeparateColor { #nodebpy.nodes.converter.SeparateColor }

```python
nodes.converter.SeparateColor(color=None, *, mode='RGB')
```

Split a color into separate channels, based on a particular color model

#### Attributes

| Name | Description |
| --- | --- |
| [i_color](#nodebpy.nodes.converter.SeparateColor.i_color) | Input socket: Color |
| [mode](#nodebpy.nodes.converter.SeparateColor.mode) |  |
| [name](#nodebpy.nodes.converter.SeparateColor.name) |  |
| [node](#nodebpy.nodes.converter.SeparateColor.node) |  |
| [o_alpha](#nodebpy.nodes.converter.SeparateColor.o_alpha) | Output socket: Alpha |
| [o_blue](#nodebpy.nodes.converter.SeparateColor.o_blue) | Output socket: Blue |
| [o_green](#nodebpy.nodes.converter.SeparateColor.o_green) | Output socket: Green |
| [o_red](#nodebpy.nodes.converter.SeparateColor.o_red) | Output socket: Red |
| [tree](#nodebpy.nodes.converter.SeparateColor.tree) |  |
| [type](#nodebpy.nodes.converter.SeparateColor.type) |  |

### SeparateMatrix { #nodebpy.nodes.converter.SeparateMatrix }

```python
nodes.converter.SeparateMatrix(matrix=None)
```

Split a 4x4 matrix into its individual values

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.SeparateMatrix.i_matrix) | Input socket: Matrix |
| [name](#nodebpy.nodes.converter.SeparateMatrix.name) |  |
| [node](#nodebpy.nodes.converter.SeparateMatrix.node) |  |
| [o_column_1_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_1) | Output socket: Column 1 Row 1 |
| [o_column_1_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_2) | Output socket: Column 1 Row 2 |
| [o_column_1_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_3) | Output socket: Column 1 Row 3 |
| [o_column_1_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_1_row_4) | Output socket: Column 1 Row 4 |
| [o_column_2_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_1) | Output socket: Column 2 Row 1 |
| [o_column_2_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_2) | Output socket: Column 2 Row 2 |
| [o_column_2_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_3) | Output socket: Column 2 Row 3 |
| [o_column_2_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_2_row_4) | Output socket: Column 2 Row 4 |
| [o_column_3_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_1) | Output socket: Column 3 Row 1 |
| [o_column_3_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_2) | Output socket: Column 3 Row 2 |
| [o_column_3_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_3) | Output socket: Column 3 Row 3 |
| [o_column_3_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_3_row_4) | Output socket: Column 3 Row 4 |
| [o_column_4_row_1](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_1) | Output socket: Column 4 Row 1 |
| [o_column_4_row_2](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_2) | Output socket: Column 4 Row 2 |
| [o_column_4_row_3](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_3) | Output socket: Column 4 Row 3 |
| [o_column_4_row_4](#nodebpy.nodes.converter.SeparateMatrix.o_column_4_row_4) | Output socket: Column 4 Row 4 |
| [tree](#nodebpy.nodes.converter.SeparateMatrix.tree) |  |
| [type](#nodebpy.nodes.converter.SeparateMatrix.type) |  |

### SeparateTransform { #nodebpy.nodes.converter.SeparateTransform }

```python
nodes.converter.SeparateTransform(transform=None)
```

Split a transformation matrix into a translation vector, a rotation, and a scale vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.SeparateTransform.i_transform) | Input socket: Transform |
| [name](#nodebpy.nodes.converter.SeparateTransform.name) |  |
| [node](#nodebpy.nodes.converter.SeparateTransform.node) |  |
| [o_rotation](#nodebpy.nodes.converter.SeparateTransform.o_rotation) | Output socket: Rotation |
| [o_scale](#nodebpy.nodes.converter.SeparateTransform.o_scale) | Output socket: Scale |
| [o_translation](#nodebpy.nodes.converter.SeparateTransform.o_translation) | Output socket: Translation |
| [tree](#nodebpy.nodes.converter.SeparateTransform.tree) |  |
| [type](#nodebpy.nodes.converter.SeparateTransform.type) |  |

### SeparateXYZ { #nodebpy.nodes.converter.SeparateXYZ }

```python
nodes.converter.SeparateXYZ(vector=None)
```

Split a vector into its X, Y, and Z components

#### Attributes

| Name | Description |
| --- | --- |
| [i_vector](#nodebpy.nodes.converter.SeparateXYZ.i_vector) | Input socket: Vector |
| [name](#nodebpy.nodes.converter.SeparateXYZ.name) |  |
| [node](#nodebpy.nodes.converter.SeparateXYZ.node) |  |
| [o_x](#nodebpy.nodes.converter.SeparateXYZ.o_x) | Output socket: X |
| [o_y](#nodebpy.nodes.converter.SeparateXYZ.o_y) | Output socket: Y |
| [o_z](#nodebpy.nodes.converter.SeparateXYZ.o_z) | Output socket: Z |
| [tree](#nodebpy.nodes.converter.SeparateXYZ.tree) |  |
| [type](#nodebpy.nodes.converter.SeparateXYZ.type) |  |

### SliceString { #nodebpy.nodes.converter.SliceString }

```python
nodes.converter.SliceString(string='', position=0, length=10)
```

Extract a string segment from a larger string

#### Attributes

| Name | Description |
| --- | --- |
| [i_length](#nodebpy.nodes.converter.SliceString.i_length) | Input socket: Length |
| [i_position](#nodebpy.nodes.converter.SliceString.i_position) | Input socket: Position |
| [i_string](#nodebpy.nodes.converter.SliceString.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.SliceString.name) |  |
| [node](#nodebpy.nodes.converter.SliceString.node) |  |
| [o_string](#nodebpy.nodes.converter.SliceString.o_string) | Output socket: String |
| [tree](#nodebpy.nodes.converter.SliceString.tree) |  |
| [type](#nodebpy.nodes.converter.SliceString.type) |  |

### StringLength { #nodebpy.nodes.converter.StringLength }

```python
nodes.converter.StringLength(string='')
```

Output the number of characters in the given string

#### Attributes

| Name | Description |
| --- | --- |
| [i_string](#nodebpy.nodes.converter.StringLength.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.StringLength.name) |  |
| [node](#nodebpy.nodes.converter.StringLength.node) |  |
| [o_length](#nodebpy.nodes.converter.StringLength.o_length) | Output socket: Length |
| [tree](#nodebpy.nodes.converter.StringLength.tree) |  |
| [type](#nodebpy.nodes.converter.StringLength.type) |  |

### StringToValue { #nodebpy.nodes.converter.StringToValue }

```python
nodes.converter.StringToValue(string='', *, data_type='FLOAT')
```

Derive a numeric value from a given string representation

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.StringToValue.data_type) |  |
| [i_string](#nodebpy.nodes.converter.StringToValue.i_string) | Input socket: String |
| [name](#nodebpy.nodes.converter.StringToValue.name) |  |
| [node](#nodebpy.nodes.converter.StringToValue.node) |  |
| [o_length](#nodebpy.nodes.converter.StringToValue.o_length) | Output socket: Length |
| [o_value](#nodebpy.nodes.converter.StringToValue.o_value) | Output socket: Value |
| [tree](#nodebpy.nodes.converter.StringToValue.tree) |  |
| [type](#nodebpy.nodes.converter.StringToValue.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [float](#nodebpy.nodes.converter.StringToValue.float) | Create String to Value with operation 'Float'. |
| [integer](#nodebpy.nodes.converter.StringToValue.integer) | Create String to Value with operation 'Integer'. |

##### float { #nodebpy.nodes.converter.StringToValue.float }

```python
nodes.converter.StringToValue.float(string='')
```

Create String to Value with operation 'Float'.

##### integer { #nodebpy.nodes.converter.StringToValue.integer }

```python
nodes.converter.StringToValue.integer(string='')
```

Create String to Value with operation 'Integer'.

### Switch { #nodebpy.nodes.converter.Switch }

```python
nodes.converter.Switch(
    switch=False,
    false=None,
    true=None,
    *,
    input_type='GEOMETRY',
)
```

Switch between two inputs

#### Attributes

| Name | Description |
| --- | --- |
| [i_false](#nodebpy.nodes.converter.Switch.i_false) | Input socket: False |
| [i_switch](#nodebpy.nodes.converter.Switch.i_switch) | Input socket: Switch |
| [i_true](#nodebpy.nodes.converter.Switch.i_true) | Input socket: True |
| [input_type](#nodebpy.nodes.converter.Switch.input_type) |  |
| [name](#nodebpy.nodes.converter.Switch.name) |  |
| [node](#nodebpy.nodes.converter.Switch.node) |  |
| [o_output](#nodebpy.nodes.converter.Switch.o_output) | Output socket: Output |
| [tree](#nodebpy.nodes.converter.Switch.tree) |  |
| [type](#nodebpy.nodes.converter.Switch.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [boolean](#nodebpy.nodes.converter.Switch.boolean) | Create Switch with operation 'Boolean'. |
| [bundle](#nodebpy.nodes.converter.Switch.bundle) | Create Switch with operation 'Bundle'. |
| [closure](#nodebpy.nodes.converter.Switch.closure) | Create Switch with operation 'Closure'. |
| [collection](#nodebpy.nodes.converter.Switch.collection) | Create Switch with operation 'Collection'. |
| [color](#nodebpy.nodes.converter.Switch.color) | Create Switch with operation 'Color'. |
| [float](#nodebpy.nodes.converter.Switch.float) | Create Switch with operation 'Float'. |
| [geometry](#nodebpy.nodes.converter.Switch.geometry) | Create Switch with operation 'Geometry'. |
| [image](#nodebpy.nodes.converter.Switch.image) | Create Switch with operation 'Image'. |
| [integer](#nodebpy.nodes.converter.Switch.integer) | Create Switch with operation 'Integer'. |
| [material](#nodebpy.nodes.converter.Switch.material) | Create Switch with operation 'Material'. |
| [matrix](#nodebpy.nodes.converter.Switch.matrix) | Create Switch with operation 'Matrix'. |
| [menu](#nodebpy.nodes.converter.Switch.menu) | Create Switch with operation 'Menu'. |
| [object](#nodebpy.nodes.converter.Switch.object) | Create Switch with operation 'Object'. |
| [rotation](#nodebpy.nodes.converter.Switch.rotation) | Create Switch with operation 'Rotation'. |
| [string](#nodebpy.nodes.converter.Switch.string) | Create Switch with operation 'String'. |
| [vector](#nodebpy.nodes.converter.Switch.vector) | Create Switch with operation 'Vector'. |

##### boolean { #nodebpy.nodes.converter.Switch.boolean }

```python
nodes.converter.Switch.boolean(switch=False, false=False, true=False)
```

Create Switch with operation 'Boolean'.

##### bundle { #nodebpy.nodes.converter.Switch.bundle }

```python
nodes.converter.Switch.bundle(switch=False, false=None, true=None)
```

Create Switch with operation 'Bundle'.

##### closure { #nodebpy.nodes.converter.Switch.closure }

```python
nodes.converter.Switch.closure(switch=False, false=None, true=None)
```

Create Switch with operation 'Closure'.

##### collection { #nodebpy.nodes.converter.Switch.collection }

```python
nodes.converter.Switch.collection(switch=False, false=None, true=None)
```

Create Switch with operation 'Collection'.

##### color { #nodebpy.nodes.converter.Switch.color }

```python
nodes.converter.Switch.color(switch=False, false=None, true=None)
```

Create Switch with operation 'Color'.

##### float { #nodebpy.nodes.converter.Switch.float }

```python
nodes.converter.Switch.float(switch=False, false=0.0, true=0.0)
```

Create Switch with operation 'Float'.

##### geometry { #nodebpy.nodes.converter.Switch.geometry }

```python
nodes.converter.Switch.geometry(switch=False, false=None, true=None)
```

Create Switch with operation 'Geometry'.

##### image { #nodebpy.nodes.converter.Switch.image }

```python
nodes.converter.Switch.image(switch=False, false=None, true=None)
```

Create Switch with operation 'Image'.

##### integer { #nodebpy.nodes.converter.Switch.integer }

```python
nodes.converter.Switch.integer(switch=False, false=0, true=0)
```

Create Switch with operation 'Integer'.

##### material { #nodebpy.nodes.converter.Switch.material }

```python
nodes.converter.Switch.material(switch=False, false=None, true=None)
```

Create Switch with operation 'Material'.

##### matrix { #nodebpy.nodes.converter.Switch.matrix }

```python
nodes.converter.Switch.matrix(switch=False, false=None, true=None)
```

Create Switch with operation 'Matrix'.

##### menu { #nodebpy.nodes.converter.Switch.menu }

```python
nodes.converter.Switch.menu(switch=False, false='', true='')
```

Create Switch with operation 'Menu'.

##### object { #nodebpy.nodes.converter.Switch.object }

```python
nodes.converter.Switch.object(switch=False, false=None, true=None)
```

Create Switch with operation 'Object'.

##### rotation { #nodebpy.nodes.converter.Switch.rotation }

```python
nodes.converter.Switch.rotation(switch=False, false=None, true=None)
```

Create Switch with operation 'Rotation'.

##### string { #nodebpy.nodes.converter.Switch.string }

```python
nodes.converter.Switch.string(switch=False, false='', true='')
```

Create Switch with operation 'String'.

##### vector { #nodebpy.nodes.converter.Switch.vector }

```python
nodes.converter.Switch.vector(switch=False, false=None, true=None)
```

Create Switch with operation 'Vector'.

### TransformDirection { #nodebpy.nodes.converter.TransformDirection }

```python
nodes.converter.TransformDirection(direction=None, transform=None)
```

Apply a transformation matrix (excluding translation) to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_direction](#nodebpy.nodes.converter.TransformDirection.i_direction) | Input socket: Direction |
| [i_transform](#nodebpy.nodes.converter.TransformDirection.i_transform) | Input socket: Transform |
| [name](#nodebpy.nodes.converter.TransformDirection.name) |  |
| [node](#nodebpy.nodes.converter.TransformDirection.node) |  |
| [o_direction](#nodebpy.nodes.converter.TransformDirection.o_direction) | Output socket: Direction |
| [tree](#nodebpy.nodes.converter.TransformDirection.tree) |  |
| [type](#nodebpy.nodes.converter.TransformDirection.type) |  |

### TransformPoint { #nodebpy.nodes.converter.TransformPoint }

```python
nodes.converter.TransformPoint(vector=None, transform=None)
```

Apply a transformation matrix to the given vector

#### Attributes

| Name | Description |
| --- | --- |
| [i_transform](#nodebpy.nodes.converter.TransformPoint.i_transform) | Input socket: Transform |
| [i_vector](#nodebpy.nodes.converter.TransformPoint.i_vector) | Input socket: Vector |
| [name](#nodebpy.nodes.converter.TransformPoint.name) |  |
| [node](#nodebpy.nodes.converter.TransformPoint.node) |  |
| [o_vector](#nodebpy.nodes.converter.TransformPoint.o_vector) | Output socket: Vector |
| [tree](#nodebpy.nodes.converter.TransformPoint.tree) |  |
| [type](#nodebpy.nodes.converter.TransformPoint.type) |  |

### TransposeMatrix { #nodebpy.nodes.converter.TransposeMatrix }

```python
nodes.converter.TransposeMatrix(matrix=None)
```

Flip a matrix over its diagonal, turning columns into rows and vice-versa

#### Attributes

| Name | Description |
| --- | --- |
| [i_matrix](#nodebpy.nodes.converter.TransposeMatrix.i_matrix) | Input socket: Matrix |
| [name](#nodebpy.nodes.converter.TransposeMatrix.name) |  |
| [node](#nodebpy.nodes.converter.TransposeMatrix.node) |  |
| [o_matrix](#nodebpy.nodes.converter.TransposeMatrix.o_matrix) | Output socket: Matrix |
| [tree](#nodebpy.nodes.converter.TransposeMatrix.tree) |  |
| [type](#nodebpy.nodes.converter.TransposeMatrix.type) |  |

### UVUnwrap { #nodebpy.nodes.converter.UVUnwrap }

```python
nodes.converter.UVUnwrap(
    selection=True,
    seam=False,
    margin=0.001,
    fill_holes=True,
    method='Angle Based',
)
```

Generate a UV map based on seam edges

#### Attributes

| Name | Description |
| --- | --- |
| [i_fill_holes](#nodebpy.nodes.converter.UVUnwrap.i_fill_holes) | Input socket: Fill Holes |
| [i_margin](#nodebpy.nodes.converter.UVUnwrap.i_margin) | Input socket: Margin |
| [i_method](#nodebpy.nodes.converter.UVUnwrap.i_method) | Input socket: Method |
| [i_seam](#nodebpy.nodes.converter.UVUnwrap.i_seam) | Input socket: Seam |
| [i_selection](#nodebpy.nodes.converter.UVUnwrap.i_selection) | Input socket: Selection |
| [name](#nodebpy.nodes.converter.UVUnwrap.name) |  |
| [node](#nodebpy.nodes.converter.UVUnwrap.node) |  |
| [o_uv](#nodebpy.nodes.converter.UVUnwrap.o_uv) | Output socket: UV |
| [tree](#nodebpy.nodes.converter.UVUnwrap.tree) |  |
| [type](#nodebpy.nodes.converter.UVUnwrap.type) |  |

### ValueToString { #nodebpy.nodes.converter.ValueToString }

```python
nodes.converter.ValueToString(value=0.0, decimals=0, *, data_type='FLOAT')
```

Generate a string representation of the given input value

#### Attributes

| Name | Description |
| --- | --- |
| [data_type](#nodebpy.nodes.converter.ValueToString.data_type) |  |
| [i_decimals](#nodebpy.nodes.converter.ValueToString.i_decimals) | Input socket: Decimals |
| [i_value](#nodebpy.nodes.converter.ValueToString.i_value) | Input socket: Value |
| [name](#nodebpy.nodes.converter.ValueToString.name) |  |
| [node](#nodebpy.nodes.converter.ValueToString.node) |  |
| [o_string](#nodebpy.nodes.converter.ValueToString.o_string) | Output socket: String |
| [tree](#nodebpy.nodes.converter.ValueToString.tree) |  |
| [type](#nodebpy.nodes.converter.ValueToString.type) |  |

#### Methods

| Name | Description |
| --- | --- |
| [float](#nodebpy.nodes.converter.ValueToString.float) | Create Value to String with operation 'Float'. |
| [integer](#nodebpy.nodes.converter.ValueToString.integer) | Create Value to String with operation 'Integer'. |

##### float { #nodebpy.nodes.converter.ValueToString.float }

```python
nodes.converter.ValueToString.float(value=0.0, decimals=0)
```

Create Value to String with operation 'Float'.

##### integer { #nodebpy.nodes.converter.ValueToString.integer }

```python
nodes.converter.ValueToString.integer(value=0)
```

Create Value to String with operation 'Integer'.