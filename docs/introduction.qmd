---
title: What happens when we add nodes?
---

```{python}
from nodebpy import TreeBuilder, nodes as n, sockets as s
```

## Adding Nodes

Adding nodes must be done inside of a context. We enter a context using the `with` keyword.
While inside of this context, whenever you call a node class (`n.SetPosition()`) a node of that type will be added to the current tree.

This first example creates a new tree and adds two new nodes, linking the `Set Position` node into the `Transform Geometry` node. The output and input sockets for each are inferred based on simple heuristics around socket type and order.

```{python}
with TreeBuilder("NewTree") as tree:
    n.SetPosition() >> n.TransformGeometry()

tree
```

These nodes can be saved as variables for re-use later in the node tree as well. After instantiating a class you can specify the input and output sockets using the `i_*` and `o_*` properties on the class.

These two approaches are equivalent:

::: {.panel-tabset}

## Individual Socket Access

```{python}
with TreeBuilder("AnotherTree") as tree:
    pos = n.SetPosition()

    n.Position() * 0.5 >> pos.i_position
    n.Vector() >> pos.i_offset
```

## Using Arguments to Class

```{python}
with TreeBuilder("AnotherAnotherTree") as tree:
    n.SetPosition(
        offset = n.Vector(),
        position = n.Position() * 0.5
    )
```

:::

```{python}
#| echo: false
tree
```

## Node Input Sockets

The socket interface nodes define what values / sockets are available as inputs for the node tree.

We define them in a similar way to the socekts themselves, using context with the `tree.inputs` and `tree.outputs` and adding sockets with the `s.SocketGeometry()`.

```{python}
with TreeBuilder("NewTree") as tree:
    with tree.inputs:
        geom_inputs = [s.SocketGeometry(f"Geometry_{i}") for i in range(5)]

    with tree.outputs:
        n.JoinGeometry(*geom_inputs) >> s.SocketGeometry("The Output Socket")

tree

```


```{python}
with TreeBuilder() as tree:
    with tree.inputs:
        count = s.SocketInt("Count", 10)

    with tree.outputs:
        output = s.SocketGeometry()

    (
        count
        >> n.Points(position=n.RandomValue.vector(min=(-0.1,-0.1,-0.2)))
        >> output
    )

tree
```

```{python}
with TreeBuilder() as tree:
    with tree.inputs:
        count = s.SocketInt("Count", 10)

    with tree.outputs:
        output = s.SocketGeometry()

    (
        count
        >> n.Points(position=n.RandomValue.vector() * 0.5 * n.Position())
        >> output
    )

tree
```

## Zones

Zones like the repeat and simulation zone are initialized with their `SimulationZone()` and `RepeatZone()` constructors. You can add individvual `RepeatInput()` node and output, but they require additional setup to be actually linked. The repeat zone can be initialized with a repeat count, which can also be linked to from elsewhere.

We can access the input and output nodes with `zone.input` and `zone.output`. The repeat zone as the `zone.i` which is the iteration number of the current zone. Simulation zone has the `zone.output.o_delta_time` which is the time between previous and current simulation loop.

Both input and output nodes can automatically detect and capture links when you attempt to link into them with `>>`. The `zone.input.capture()` method also allows you to explicitly capture a link or a value, returning the output socket for further linking.


```{python}
with TreeBuilder(arrange=False) as tree:
    zone = n.RepeatZone(10)

    join = zone.input >> n.JoinGeometry()
    (
        zone.i
        >> n.Points(position=n.RandomValue.vector(seed=zone.i))
        >> join
        >> zone.output
        >> n.SetPosition()
    )

tree
```