[
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "What happens when we add nodes?",
    "section": "",
    "text": "from nodebpy import TreeBuilder, nodes as n, sockets as s"
  },
  {
    "objectID": "introduction.html#adding-nodes",
    "href": "introduction.html#adding-nodes",
    "title": "What happens when we add nodes?",
    "section": "Adding Nodes",
    "text": "Adding Nodes\nAdding nodes must be done inside of a context. We enter a context using the with keyword. While inside of this context, whenever you call a node class (n.SetPosition()) a node of that type will be added to the current tree.\nThis first example creates a new tree and adds two new nodes, linking the Set Position node into the Transform Geometry node. The output and input sockets for each are inferred based on simple heuristics around socket type and order.\n\nwith TreeBuilder(\"NewTree\") as tree:\n    n.SetPosition() &gt;&gt; n.TransformGeometry()\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"SetPosition\"):::geometry-node\n    N1(\"Transform\"):::geometry-node\n    N0 --&gt;|\"Geometry&gt;&gt;Geometry\"| N1\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\nThese nodes can be saved as variables for re-use later in the node tree as well. After instantiating a class you can specify the input and output sockets using the i_* and o_* properties on the class.\nThese two approaches are equivalent:\n\nIndividual Socket AccessUsing Arguments to Class\n\n\n\nwith TreeBuilder(\"AnotherTree\") as tree:\n    pos = n.SetPosition()\n\n    n.Position() * 0.5 &gt;&gt; pos.i_position\n    n.Vector() &gt;&gt; pos.i_offset\n\n\n\n\nwith TreeBuilder(\"AnotherAnotherTree\") as tree:\n    n.SetPosition(\n        offset = n.Vector(),\n        position = n.Position() * 0.5\n    )\n\n\n\n\n\n\n\n\n\n\n\ngraph LR\n    N0(\"InputPosition\"):::input-node\n    N1(\"VectorMath&lt;br/&gt;&lt;small&gt;×0.5&lt;/small&gt;\"):::vector-node\n    N2(\"InputVector\"):::input-node\n    N3(\"SetPosition\"):::geometry-node\n    N0 --&gt;|\"Position&gt;&gt;Vector\"| N1\n    N1 --&gt;|\"Vector&gt;&gt;Position\"| N3\n    N2 --&gt;|\"Vector&gt;&gt;Offset\"| N3\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px"
  },
  {
    "objectID": "introduction.html#node-input-sockets",
    "href": "introduction.html#node-input-sockets",
    "title": "What happens when we add nodes?",
    "section": "Node Input Sockets",
    "text": "Node Input Sockets\nThe socket interface nodes define what values / sockets are available as inputs for the node tree.\nWe define them in a similar way to the socekts themselves, using context with the tree.inputs and tree.outputs and adding sockets with the s.SocketGeometry().\n\nwith TreeBuilder(\"NewTree\") as tree:\n    with tree.inputs:\n        geom_inputs = [s.SocketGeometry(f\"Geometry_{i}\") for i in range(5)]\n\n    with tree.outputs:\n        n.JoinGeometry(*geom_inputs) &gt;&gt; s.SocketGeometry(\"The Output Socket\")\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"JoinGeometry\"):::geometry-node\n    N2(\"NodeGroupOutput\"):::default-node\n    N0 --&gt;|\"Geometry_4&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_3&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_2&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_1&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_0&gt;&gt;Geometry\"| N1\n    N1 --&gt;|\"Geometry&gt;&gt;The Output Socket\"| N2\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\n\nwith TreeBuilder() as tree:\n    with tree.inputs:\n        count = s.SocketInt(\"Count\", 10)\n\n    with tree.outputs:\n        output = s.SocketGeometry()\n\n    (\n        count\n        &gt;&gt; n.Points(position=n.RandomValue.vector(min=(-0.1,-0.1,-0.2)))\n        &gt;&gt; output\n    )\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"RandomValue&lt;br/&gt;&lt;small&gt;(-0.1,-0.1,-0.2)&lt;/small&gt;\"):::converter-node\n    N2(\"Points\"):::geometry-node\n    N3(\"NodeGroupOutput\"):::default-node\n    N1 --&gt;|\"Value&gt;&gt;Position\"| N2\n    N0 --&gt;|\"Count&gt;&gt;Count\"| N2\n    N2 --&gt;|\"Points&gt;&gt;Geometry\"| N3\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\n\nwith TreeBuilder() as tree:\n    with tree.inputs:\n        count = s.SocketInt(\"Count\", 10)\n\n    with tree.outputs:\n        output = s.SocketGeometry()\n\n    (\n        count\n        &gt;&gt; n.Points(position=n.RandomValue.vector() * 0.5 * n.Position())\n        &gt;&gt; output\n    )\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"RandomValue\"):::converter-node\n    N2(\"VectorMath&lt;br/&gt;&lt;small&gt;×0.5&lt;/small&gt;\"):::vector-node\n    N3(\"InputPosition\"):::input-node\n    N4(\"VectorMath\"):::vector-node\n    N5(\"Points\"):::geometry-node\n    N6(\"NodeGroupOutput\"):::default-node\n    N1 --&gt;|\"Value&gt;&gt;Vector\"| N2\n    N2 --&gt;|\"Vector&gt;&gt;Vector\"| N4\n    N3 --&gt;|\"Position&gt;&gt;Vector\"| N4\n    N4 --&gt;|\"Vector&gt;&gt;Position\"| N5\n    N0 --&gt;|\"Count&gt;&gt;Count\"| N5\n    N5 --&gt;|\"Points&gt;&gt;Geometry\"| N6\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px"
  },
  {
    "objectID": "introduction.html#zones",
    "href": "introduction.html#zones",
    "title": "What happens when we add nodes?",
    "section": "Zones",
    "text": "Zones\nZones like the repeat and simulation zone are initialized with their SimulationZone() and RepeatZone() constructors. You can add individvual RepeatInput() node and output, but they require additional setup to be actually linked. The repeat zone can be initialized with a repeat count, which can also be linked to from elsewhere.\nWe can access the input and output nodes with zone.input and zone.output. The repeat zone as the zone.i which is the iteration number of the current zone. Simulation zone has the zone.output.o_delta_time which is the time between previous and current simulation loop.\nBoth input and output nodes can automatically detect and capture links when you attempt to link into them with &gt;&gt;. The zone.input.capture() method also allows you to explicitly capture a link or a value, returning the output socket for further linking.\n\nwith TreeBuilder(arrange=False) as tree:\n    zone = n.RepeatZone(10)\n    join = n.JoinGeometry()\n    # a geometry socket is added to the zone when we try to connect from the Join Geometry\n    # to the zone output, which is then available for the zone.input &gt;&gt; join\n    join &gt;&gt; zone.output &gt;&gt; n.SetPosition()\n    zone.input &gt;&gt; join\n    n.Points(zone.i, position=n.RandomValue.vector(seed=zone.i)) &gt;&gt; join\n\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"RepeatInput\"):::default-node\n    N1(\"RepeatOutput\"):::default-node\n    N2(\"JoinGeometry\"):::geometry-node\n    N3(\"SetPosition\"):::geometry-node\n    N4(\"RandomValue\"):::converter-node\n    N5(\"Points\"):::geometry-node\n    N2 --&gt;|\"Geometry&gt;&gt;Geometry\"| N1\n    N1 --&gt;|\"Geometry&gt;&gt;Geometry\"| N3\n    N0 --&gt;|\"Geometry&gt;&gt;Geometry\"| N2\n    N0 --&gt;|\"Iteration&gt;&gt;Seed\"| N4\n    N0 --&gt;|\"Iteration&gt;&gt;Count\"| N5\n    N4 --&gt;|\"Value&gt;&gt;Position\"| N5\n    N5 --&gt;|\"Points&gt;&gt;Geometry\"| N2\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\n\nwith TreeBuilder(arrange=False) as tree:\n    # this initializes the zone with two socket inputs for each of the values\n    zone = n.SimulationZone(n.Value(), n.Vector())\n\n    # this explicitly grabs the \"Value\" socket (which got it's name from the n.Value() node)\n    # and adds 10 then attempts to plug it into the zone output (it will choose the float\n    # socket instead of the vector socket because that is the most compatible)\n    zone.input.outputs[\"Value\"] + 10 &gt;&gt; zone.output\n    # this should automatically pick the vector input socket because we are\n    # explicity about the VectorMath and it will be the most compatible\n    zone.input &gt;&gt; n.VectorMath.add((1.2, 1.2, 1.2)) &gt;&gt; zone.output\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"Value\"):::input-node\n    N1(\"InputVector\"):::input-node\n    N2(\"SimulationInput\"):::default-node\n    N3(\"SimulationOutput\"):::default-node\n    N4(\"Math\"):::converter-node\n    N5(\"VectorMath\"):::vector-node\n    N0 --&gt;|\"Value&gt;&gt;Value\"| N2\n    N1 --&gt;|\"Vector&gt;&gt;Vector\"| N2\n    N2 --&gt;|\"Value&gt;&gt;Value\"| N4\n    N4 --&gt;|\"Value&gt;&gt;Value\"| N3\n    N2 --&gt;|\"Vector&gt;&gt;Vector\"| N5\n    N5 --&gt;|\"Vector&gt;&gt;Vector\"| N3\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px"
  },
  {
    "objectID": "reference/nodes.converter.html",
    "href": "reference/nodes.converter.html",
    "title": "nodes.converter",
    "section": "",
    "text": "nodes.converter\n\n\n\n\n\nName\nDescription\n\n\n\n\nAlignRotationToVector\nOrient a rotation along the given direction\n\n\nAxesToRotation\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\nAxisAngleToRotation\nBuild a rotation from an axis and a rotation around that axis\n\n\nBitMath\nPerform bitwise operations on 32-bit integers\n\n\nBlackbody\nConvert a blackbody temperature to an RGB value\n\n\nBooleanMath\nPerform a logical operation on the given boolean inputs\n\n\nClamp\nClamp a value between a minimum and a maximum\n\n\nColorRamp\nMap values to colors with the use of a gradient\n\n\nCombineBundle\nCombine multiple socket values into one.\n\n\nCombineColor\nCombine four channels into a single color, based on a particular color model\n\n\nCombineMatrix\nConstruct a 4x4 matrix from its individual values\n\n\nCombineTransform\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\nCombineXYZ\nCreate a vector from X, Y, and Z components\n\n\nEulerToRotation\nBuild a rotation from separate angles around each axis\n\n\nFindInString\nFind the number of times a given string occurs in another string and the position of the first match\n\n\nFloatCurve\nMap an input float to a curve and outputs a float value\n\n\nFloatToInteger\nConvert the given floating-point number to an integer, with a choice of methods\n\n\nHashValue\nGenerate a randomized integer using the given input value as a seed\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nIntegerMath\nPerform various math operations on the given integer inputs\n\n\nInvertMatrix\nCompute the inverse of the given matrix, if one exists\n\n\nInvertRotation\nCompute the inverse of the given rotation\n\n\nJoinBundle\nJoin multiple bundles together\n\n\nMapRange\nRemap a value from a range to a target range\n\n\nMatchString\nCheck if a given string exists within another string\n\n\nMath\nPerform math operations\n\n\nMatrixDeterminant\nCompute the determinant of the given matrix\n\n\nMix\nMix values by a factor\n\n\nMultiplyMatrices\nPerform a matrix multiplication on two input matrices\n\n\nPackUVIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nProjectPoint\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\nQuaternionToRotation\nBuild a rotation from quaternion components\n\n\nRandomValue\nOutput a randomized value\n\n\nReplaceString\nReplace a given string segment with another\n\n\nRotateEuler\nApply a secondary Euler rotation to a given Euler rotation\n\n\nRotateRotation\nApply a secondary rotation to a given rotation value\n\n\nRotateVector\nApply a rotation to a given vector\n\n\nRotationToAxisAngle\nConvert a rotation to axis angle components\n\n\nRotationToEuler\nConvert a standard rotation value to an Euler rotation\n\n\nRotationToQuaternion\nRetrieve the quaternion components representing a rotation\n\n\nSeparateBundle\nSplit a bundle into multiple sockets.\n\n\nSeparateColor\nSplit a color into separate channels, based on a particular color model\n\n\nSeparateMatrix\nSplit a 4x4 matrix into its individual values\n\n\nSeparateTransform\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\nSeparateXYZ\nSplit a vector into its X, Y, and Z components\n\n\nSliceString\nExtract a string segment from a larger string\n\n\nStringLength\nOutput the number of characters in the given string\n\n\nStringToValue\nDerive a numeric value from a given string representation\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformDirection\nApply a transformation matrix (excluding translation) to the given vector\n\n\nTransformPoint\nApply a transformation matrix to the given vector\n\n\nTransposeMatrix\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\nUVUnwrap\nGenerate a UV map based on seam edges\n\n\nValueToString\nGenerate a string representation of the given input value\n\n\n\n\n\nnodes.converter.AlignRotationToVector(\n    rotation=None,\n    factor=1.0,\n    vector=None,\n    *,\n    axis='Z',\n    pivot_axis='AUTO',\n)\nOrient a rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\naxis\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\npivot_axis\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.AxesToRotation(\n    primary_axis=None,\n    secondary_axis=None,\n    *,\n    primary='Z',\n    secondary='X',\n)\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_primary_axis\nInput socket: Primary Axis\n\n\ni_secondary_axis\nInput socket: Secondary Axis\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nprimary\n\n\n\nprimary_axis\n\n\n\nsecondary\n\n\n\nsecondary_axis\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.AxisAngleToRotation(axis=None, angle=0.0)\nBuild a rotation from an axis and a rotation around that axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.BitMath(a=0, b=0, shift=0, *, operation='AND')\nPerform bitwise operations on 32-bit integers\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\ni_shift\nInput socket: Shift\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nexclusive_or\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\nl_and\nCreate Bit Math with operation ‘And’.\n\n\nl_not\nCreate Bit Math with operation ‘Not’.\n\n\nl_or\nCreate Bit Math with operation ‘Or’.\n\n\nrotate\nCreate Bit Math with operation ‘Rotate’.\n\n\nshift\nCreate Bit Math with operation ‘Shift’.\n\n\n\n\n\nnodes.converter.BitMath.exclusive_or(a=0, b=0)\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\nnodes.converter.BitMath.l_and(a=0, b=0)\nCreate Bit Math with operation ‘And’.\n\n\n\nnodes.converter.BitMath.l_not(a=0)\nCreate Bit Math with operation ‘Not’.\n\n\n\nnodes.converter.BitMath.l_or(a=0, b=0)\nCreate Bit Math with operation ‘Or’.\n\n\n\nnodes.converter.BitMath.rotate(a=0, shift=0)\nCreate Bit Math with operation ‘Rotate’.\n\n\n\nnodes.converter.BitMath.shift(a=0, shift=0)\nCreate Bit Math with operation ‘Shift’.\n\n\n\n\n\nnodes.converter.Blackbody(temperature=6500.0)\nConvert a blackbody temperature to an RGB value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_temperature\nInput socket: Temperature\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.BooleanMath(\n    boolean=False,\n    boolean_001=False,\n    *,\n    operation='AND',\n)\nPerform a logical operation on the given boolean inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boolean\nInput socket: Boolean\n\n\ni_boolean_001\nInput socket: Boolean\n\n\nname\n\n\n\nnode\n\n\n\no_boolean\nOutput socket: Boolean\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nequal\nCreate Boolean Math with operation ‘Equal’.\n\n\nimply\nCreate Boolean Math with operation ‘Imply’.\n\n\nl_and\nCreate Boolean Math with operation ‘And’.\n\n\nl_not\nCreate Boolean Math with operation ‘Not’.\n\n\nl_or\nCreate Boolean Math with operation ‘Or’.\n\n\nnor\nCreate Boolean Math with operation ‘Nor’.\n\n\nnot_and\nCreate Boolean Math with operation ‘Not And’.\n\n\nnot_equal\nCreate Boolean Math with operation ‘Not Equal’.\n\n\nsubtract\nCreate Boolean Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.BooleanMath.equal(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Equal’.\n\n\n\nnodes.converter.BooleanMath.imply(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Imply’.\n\n\n\nnodes.converter.BooleanMath.l_and(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘And’.\n\n\n\nnodes.converter.BooleanMath.l_not(boolean=False)\nCreate Boolean Math with operation ‘Not’.\n\n\n\nnodes.converter.BooleanMath.l_or(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Or’.\n\n\n\nnodes.converter.BooleanMath.nor(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Nor’.\n\n\n\nnodes.converter.BooleanMath.not_and(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Not And’.\n\n\n\nnodes.converter.BooleanMath.not_equal(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Not Equal’.\n\n\n\nnodes.converter.BooleanMath.subtract(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.Clamp(value=1.0, min=0.0, max=1.0, *, clamp_type='MINMAX')\nClamp a value between a minimum and a maximum\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp_type\n\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ColorRamp(fac=0.5)\nMap values to colors with the use of a gradient\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fac\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineBundle(define_signature=False)\nCombine multiple socket values into one.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_signature\n\n\n\nname\n\n\n\nnode\n\n\n\no_bundle\nOutput socket: Bundle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineColor(\n    red=0.0,\n    green=0.0,\n    blue=0.0,\n    alpha=1.0,\n    *,\n    mode='RGB',\n)\nCombine four channels into a single color, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_alpha\nInput socket: Alpha\n\n\ni_blue\nInput socket: Blue\n\n\ni_green\nInput socket: Green\n\n\ni_red\nInput socket: Red\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineMatrix(\n    column_1_row_1=1.0,\n    column_1_row_2=0.0,\n    column_1_row_3=0.0,\n    column_1_row_4=0.0,\n    column_2_row_1=0.0,\n    column_2_row_2=1.0,\n    column_2_row_3=0.0,\n    column_2_row_4=0.0,\n    column_3_row_1=0.0,\n    column_3_row_2=0.0,\n    column_3_row_3=1.0,\n    column_3_row_4=0.0,\n    column_4_row_1=0.0,\n    column_4_row_2=0.0,\n    column_4_row_3=0.0,\n    column_4_row_4=1.0,\n)\nConstruct a 4x4 matrix from its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_column_1_row_1\nInput socket: Column 1 Row 1\n\n\ni_column_1_row_2\nInput socket: Column 1 Row 2\n\n\ni_column_1_row_3\nInput socket: Column 1 Row 3\n\n\ni_column_1_row_4\nInput socket: Column 1 Row 4\n\n\ni_column_2_row_1\nInput socket: Column 2 Row 1\n\n\ni_column_2_row_2\nInput socket: Column 2 Row 2\n\n\ni_column_2_row_3\nInput socket: Column 2 Row 3\n\n\ni_column_2_row_4\nInput socket: Column 2 Row 4\n\n\ni_column_3_row_1\nInput socket: Column 3 Row 1\n\n\ni_column_3_row_2\nInput socket: Column 3 Row 2\n\n\ni_column_3_row_3\nInput socket: Column 3 Row 3\n\n\ni_column_3_row_4\nInput socket: Column 3 Row 4\n\n\ni_column_4_row_1\nInput socket: Column 4 Row 1\n\n\ni_column_4_row_2\nInput socket: Column 4 Row 2\n\n\ni_column_4_row_3\nInput socket: Column 4 Row 3\n\n\ni_column_4_row_4\nInput socket: Column 4 Row 4\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineTransform(translation=None, rotation=None, scale=None)\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineXYZ(x=0.0, y=0.0, z=0.0)\nCreate a vector from X, Y, and Z components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.EulerToRotation(euler=None)\nBuild a rotation from separate angles around each axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_euler\nInput socket: Euler\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FindInString(string='', search='')\nFind the number of times a given string occurs in another string and the position of the first match\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_search\nInput socket: Search\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_count\nOutput socket: Count\n\n\no_first_found\nOutput socket: First Found\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FloatCurve(factor=1.0, value=1.0)\nMap an input float to a curve and outputs a float value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FloatToInteger(float=0.0, *, rounding_mode='ROUND')\nConvert the given floating-point number to an integer, with a choice of methods\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_float\nInput socket: Float\n\n\nname\n\n\n\nnode\n\n\n\no_integer\nOutput socket: Integer\n\n\nrounding_mode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.HashValue(value=0, seed=0, *, data_type='INT')\nGenerate a randomized integer using the given input value as a seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_seed\nInput socket: Seed\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_hash\nOutput socket: Hash\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Hash Value with operation ‘Color’.\n\n\nfloat\nCreate Hash Value with operation ‘Float’.\n\n\ninteger\nCreate Hash Value with operation ‘Integer’.\n\n\nmatrix\nCreate Hash Value with operation ‘Matrix’.\n\n\nrotation\nCreate Hash Value with operation ‘Rotation’.\n\n\nstring\nCreate Hash Value with operation ‘String’.\n\n\nvector\nCreate Hash Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.HashValue.color(value=None, seed=0)\nCreate Hash Value with operation ‘Color’.\n\n\n\nnodes.converter.HashValue.float(value=0.0, seed=0)\nCreate Hash Value with operation ‘Float’.\n\n\n\nnodes.converter.HashValue.integer(value=0, seed=0)\nCreate Hash Value with operation ‘Integer’.\n\n\n\nnodes.converter.HashValue.matrix(value=None, seed=0)\nCreate Hash Value with operation ‘Matrix’.\n\n\n\nnodes.converter.HashValue.rotation(value=None, seed=0)\nCreate Hash Value with operation ‘Rotation’.\n\n\n\nnodes.converter.HashValue.string(value='', seed=0)\nCreate Hash Value with operation ‘String’.\n\n\n\nnodes.converter.HashValue.vector(value=None, seed=0)\nCreate Hash Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.IndexOfNearest(position=None, group_id=0)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\nname\n\n\n\nnode\n\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.IntegerMath(\n    value=0,\n    value_001=0,\n    value_002=0,\n    *,\n    operation='ADD',\n)\nPerform various math operations on the given integer inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\ni_value_002\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Integer Math with operation ‘Absolute’.\n\n\nadd\nCreate Integer Math with operation ‘Add’.\n\n\ndivide\nCreate Integer Math with operation ‘Divide’.\n\n\ndivide_ceiling\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\ndivide_floor\nCreate Integer Math with operation ‘Divide Floor’.\n\n\ndivide_round\nCreate Integer Math with operation ‘Divide Round’.\n\n\nfloored_modulo\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\ngreatest_common_divisor\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\nleast_common_multiple\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\nmaximum\nCreate Integer Math with operation ‘Maximum’.\n\n\nminimum\nCreate Integer Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Integer Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Integer Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Integer Math with operation ‘Multiply Add’.\n\n\nnegate\nCreate Integer Math with operation ‘Negate’.\n\n\npower\nCreate Integer Math with operation ‘Power’.\n\n\nsign\nCreate Integer Math with operation ‘Sign’.\n\n\nsubtract\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.IntegerMath.absolute(value=0)\nCreate Integer Math with operation ‘Absolute’.\n\n\n\nnodes.converter.IntegerMath.add(value=0, value_001=0)\nCreate Integer Math with operation ‘Add’.\n\n\n\nnodes.converter.IntegerMath.divide(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide’.\n\n\n\nnodes.converter.IntegerMath.divide_ceiling(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\n\nnodes.converter.IntegerMath.divide_floor(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Floor’.\n\n\n\nnodes.converter.IntegerMath.divide_round(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Round’.\n\n\n\nnodes.converter.IntegerMath.floored_modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\n\nnodes.converter.IntegerMath.greatest_common_divisor(value=0, value_001=0)\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\n\nnodes.converter.IntegerMath.least_common_multiple(value=0, value_001=0)\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\n\nnodes.converter.IntegerMath.maximum(value=0, value_001=0)\nCreate Integer Math with operation ‘Maximum’.\n\n\n\nnodes.converter.IntegerMath.minimum(value=0, value_001=0)\nCreate Integer Math with operation ‘Minimum’.\n\n\n\nnodes.converter.IntegerMath.modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Modulo’.\n\n\n\nnodes.converter.IntegerMath.multiply(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply’.\n\n\n\nnodes.converter.IntegerMath.multiply_add(value=0, value_001=0, value_002=0)\nCreate Integer Math with operation ‘Multiply Add’.\n\n\n\nnodes.converter.IntegerMath.negate(value=0)\nCreate Integer Math with operation ‘Negate’.\n\n\n\nnodes.converter.IntegerMath.power(value=0, value_001=0)\nCreate Integer Math with operation ‘Power’.\n\n\n\nnodes.converter.IntegerMath.sign(value=0)\nCreate Integer Math with operation ‘Sign’.\n\n\n\nnodes.converter.IntegerMath.subtract(value=0, value_001=0)\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.InvertMatrix(matrix=None)\nCompute the inverse of the given matrix, if one exists\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_invertible\nOutput socket: Invertible\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.InvertRotation(rotation=None)\nCompute the inverse of the given rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.JoinBundle(bundle=None)\nJoin multiple bundles together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bundle\nInput socket: Bundle\n\n\nname\n\n\n\nnode\n\n\n\no_bundle\nOutput socket: Bundle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.MapRange(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n    steps=4.0,\n    vector=None,\n    from_min_float3=None,\n    from_max_float3=None,\n    to_min_float3=None,\n    to_max_float3=None,\n    steps_float3=None,\n    *,\n    clamp=False,\n    interpolation_type='LINEAR',\n    data_type='FLOAT',\n)\nRemap a value from a range to a target range\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp\n\n\n\ndata_type\n\n\n\ni_from_max\nInput socket: From Max\n\n\ni_from_max_float3\nInput socket: From Max\n\n\ni_from_min\nInput socket: From Min\n\n\ni_from_min_float3\nInput socket: From Min\n\n\ni_steps\nInput socket: Steps\n\n\ni_steps_float3\nInput socket: Steps\n\n\ni_to_max\nInput socket: To Max\n\n\ni_to_max_float3\nInput socket: To Max\n\n\ni_to_min\nInput socket: To Min\n\n\ni_to_min_float3\nInput socket: To Min\n\n\ni_value\nInput socket: Value\n\n\ni_vector\nInput socket: Vector\n\n\ninterpolation_type\n\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Map Range with operation ‘Float’.\n\n\nvector\nCreate Map Range with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MapRange.float(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n)\nCreate Map Range with operation ‘Float’.\n\n\n\nnodes.converter.MapRange.vector(\n    vector=None,\n    from_min3=None,\n    from_max3=None,\n    to_min3=None,\n    to_max3=None,\n)\nCreate Map Range with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MatchString(string='', operation='Starts With', key='')\nCheck if a given string exists within another string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_key\nInput socket: Key\n\n\ni_operation\nInput socket: Operation\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.Math(\n    value=0.5,\n    value_001=0.5,\n    value_002=0.5,\n    *,\n    operation='ADD',\n    use_clamp=False,\n)\nPerform math operations\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\ni_value_002\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\nuse_clamp\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Math with operation ‘Absolute’.\n\n\nadd\nCreate Math with operation ‘Add’.\n\n\narccosine\nCreate Math with operation ‘Arccosine’.\n\n\narcsine\nCreate Math with operation ‘Arcsine’.\n\n\narctan2\nCreate Math with operation ‘Arctan2’.\n\n\narctangent\nCreate Math with operation ‘Arctangent’.\n\n\nceil\nCreate Math with operation ‘Ceil’.\n\n\ncompare\nCreate Math with operation ‘Compare’.\n\n\ncosine\nCreate Math with operation ‘Cosine’.\n\n\ndivide\nCreate Math with operation ‘Divide’.\n\n\nexponent\nCreate Math with operation ‘Exponent’.\n\n\nfloor\nCreate Math with operation ‘Floor’.\n\n\nfloored_modulo\nCreate Math with operation ‘Floored Modulo’.\n\n\nfraction\nCreate Math with operation ‘Fraction’.\n\n\ngreater_than\nCreate Math with operation ‘Greater Than’.\n\n\nhyperbolic_cosine\nCreate Math with operation ‘Hyperbolic Cosine’.\n\n\nhyperbolic_sine\nCreate Math with operation ‘Hyperbolic Sine’.\n\n\nhyperbolic_tangent\nCreate Math with operation ‘Hyperbolic Tangent’.\n\n\ninverse_square_root\nCreate Math with operation ‘Inverse Square Root’.\n\n\nless_than\nCreate Math with operation ‘Less Than’.\n\n\nlogarithm\nCreate Math with operation ‘Logarithm’.\n\n\nmaximum\nCreate Math with operation ‘Maximum’.\n\n\nminimum\nCreate Math with operation ‘Minimum’.\n\n\nmultiply\nCreate Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Math with operation ‘Multiply Add’.\n\n\nping_pong\nCreate Math with operation ‘Ping-Pong’.\n\n\npower\nCreate Math with operation ‘Power’.\n\n\nround\nCreate Math with operation ‘Round’.\n\n\nsign\nCreate Math with operation ‘Sign’.\n\n\nsine\nCreate Math with operation ‘Sine’.\n\n\nsmooth_maximum\nCreate Math with operation ‘Smooth Maximum’.\n\n\nsmooth_minimum\nCreate Math with operation ‘Smooth Minimum’.\n\n\nsnap\nCreate Math with operation ‘Snap’.\n\n\nsquare_root\nCreate Math with operation ‘Square Root’.\n\n\nsubtract\nCreate Math with operation ‘Subtract’.\n\n\ntangent\nCreate Math with operation ‘Tangent’.\n\n\nto_degrees\nCreate Math with operation ‘To Degrees’.\n\n\nto_radians\nCreate Math with operation ‘To Radians’.\n\n\ntruncate\nCreate Math with operation ‘Truncate’.\n\n\ntruncated_modulo\nCreate Math with operation ‘Truncated Modulo’.\n\n\nwrap\nCreate Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.converter.Math.absolute(value=0.5)\nCreate Math with operation ‘Absolute’.\n\n\n\nnodes.converter.Math.add(value=0.5, value_001=0.5)\nCreate Math with operation ‘Add’.\n\n\n\nnodes.converter.Math.arccosine(value=0.5)\nCreate Math with operation ‘Arccosine’.\n\n\n\nnodes.converter.Math.arcsine(value=0.5)\nCreate Math with operation ‘Arcsine’.\n\n\n\nnodes.converter.Math.arctan2(value=0.5, value_001=0.5)\nCreate Math with operation ‘Arctan2’.\n\n\n\nnodes.converter.Math.arctangent(value=0.5)\nCreate Math with operation ‘Arctangent’.\n\n\n\nnodes.converter.Math.ceil(value=0.5)\nCreate Math with operation ‘Ceil’.\n\n\n\nnodes.converter.Math.compare(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Compare’.\n\n\n\nnodes.converter.Math.cosine(value=0.5)\nCreate Math with operation ‘Cosine’.\n\n\n\nnodes.converter.Math.divide(value=0.5, value_001=0.5)\nCreate Math with operation ‘Divide’.\n\n\n\nnodes.converter.Math.exponent(value=0.5)\nCreate Math with operation ‘Exponent’.\n\n\n\nnodes.converter.Math.floor(value=0.5)\nCreate Math with operation ‘Floor’.\n\n\n\nnodes.converter.Math.floored_modulo(value=0.5, value_001=0.5)\nCreate Math with operation ‘Floored Modulo’.\n\n\n\nnodes.converter.Math.fraction(value=0.5)\nCreate Math with operation ‘Fraction’.\n\n\n\nnodes.converter.Math.greater_than(value=0.5, value_001=0.5)\nCreate Math with operation ‘Greater Than’.\n\n\n\nnodes.converter.Math.hyperbolic_cosine(value=0.5)\nCreate Math with operation ‘Hyperbolic Cosine’.\n\n\n\nnodes.converter.Math.hyperbolic_sine(value=0.5)\nCreate Math with operation ‘Hyperbolic Sine’.\n\n\n\nnodes.converter.Math.hyperbolic_tangent(value=0.5)\nCreate Math with operation ‘Hyperbolic Tangent’.\n\n\n\nnodes.converter.Math.inverse_square_root(value=0.5)\nCreate Math with operation ‘Inverse Square Root’.\n\n\n\nnodes.converter.Math.less_than(value=0.5, value_001=0.5)\nCreate Math with operation ‘Less Than’.\n\n\n\nnodes.converter.Math.logarithm(value=0.5, value_001=0.5)\nCreate Math with operation ‘Logarithm’.\n\n\n\nnodes.converter.Math.maximum(value=0.5, value_001=0.5)\nCreate Math with operation ‘Maximum’.\n\n\n\nnodes.converter.Math.minimum(value=0.5, value_001=0.5)\nCreate Math with operation ‘Minimum’.\n\n\n\nnodes.converter.Math.multiply(value=0.5, value_001=0.5)\nCreate Math with operation ‘Multiply’.\n\n\n\nnodes.converter.Math.multiply_add(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Multiply Add’.\n\n\n\nnodes.converter.Math.ping_pong(value=0.5, value_001=0.5)\nCreate Math with operation ‘Ping-Pong’.\n\n\n\nnodes.converter.Math.power(value=0.5, value_001=0.5)\nCreate Math with operation ‘Power’.\n\n\n\nnodes.converter.Math.round(value=0.5)\nCreate Math with operation ‘Round’.\n\n\n\nnodes.converter.Math.sign(value=0.5)\nCreate Math with operation ‘Sign’.\n\n\n\nnodes.converter.Math.sine(value=0.5)\nCreate Math with operation ‘Sine’.\n\n\n\nnodes.converter.Math.smooth_maximum(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Smooth Maximum’.\n\n\n\nnodes.converter.Math.smooth_minimum(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Smooth Minimum’.\n\n\n\nnodes.converter.Math.snap(value=0.5, value_001=0.5)\nCreate Math with operation ‘Snap’.\n\n\n\nnodes.converter.Math.square_root(value=0.5)\nCreate Math with operation ‘Square Root’.\n\n\n\nnodes.converter.Math.subtract(value=0.5, value_001=0.5)\nCreate Math with operation ‘Subtract’.\n\n\n\nnodes.converter.Math.tangent(value=0.5)\nCreate Math with operation ‘Tangent’.\n\n\n\nnodes.converter.Math.to_degrees(value=0.5)\nCreate Math with operation ‘To Degrees’.\n\n\n\nnodes.converter.Math.to_radians(value=0.5)\nCreate Math with operation ‘To Radians’.\n\n\n\nnodes.converter.Math.truncate(value=0.5)\nCreate Math with operation ‘Truncate’.\n\n\n\nnodes.converter.Math.truncated_modulo(value=0.5, value_001=0.5)\nCreate Math with operation ‘Truncated Modulo’.\n\n\n\nnodes.converter.Math.wrap(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.converter.MatrixDeterminant(matrix=None)\nCompute the determinant of the given matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_determinant\nOutput socket: Determinant\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.Mix(\n    factor_float=0.5,\n    factor_vector=None,\n    a_float=0.0,\n    b_float=0.0,\n    a_vector=None,\n    b_vector=None,\n    a_color=None,\n    b_color=None,\n    a_rotation=None,\n    b_rotation=None,\n    *,\n    data_type='FLOAT',\n    factor_mode='UNIFORM',\n    blend_type='MIX',\n    clamp_factor=False,\n    clamp_result=False,\n)\nMix values by a factor\n\n\n\n\n\nName\nDescription\n\n\n\n\nblend_type\n\n\n\nclamp_factor\n\n\n\nclamp_result\n\n\n\ndata_type\n\n\n\nfactor_mode\n\n\n\ni_a_color\nInput socket: A\n\n\ni_a_float\nInput socket: A\n\n\ni_a_rotation\nInput socket: A\n\n\ni_a_vector\nInput socket: A\n\n\ni_b_color\nInput socket: B\n\n\ni_b_float\nInput socket: B\n\n\ni_b_rotation\nInput socket: B\n\n\ni_b_vector\nInput socket: B\n\n\ni_factor_float\nInput socket: Factor\n\n\ni_factor_vector\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_result_color\nOutput socket: Result\n\n\no_result_float\nOutput socket: Result\n\n\no_result_rotation\nOutput socket: Result\n\n\no_result_vector\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Mix with operation ‘Color’.\n\n\nfloat\nCreate Mix with operation ‘Float’.\n\n\nrotation\nCreate Mix with operation ‘Rotation’.\n\n\nvector\nCreate Mix with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.Mix.color(factor=0.5, a_color=None, b_color=None)\nCreate Mix with operation ‘Color’.\n\n\n\nnodes.converter.Mix.float(factor=0.5, a=0.0, b=0.0)\nCreate Mix with operation ‘Float’.\n\n\n\nnodes.converter.Mix.rotation(factor=0.5, a_rotation=None, b_rotation=None)\nCreate Mix with operation ‘Rotation’.\n\n\n\nnodes.converter.Mix.vector(factor=0.5, a=None, b=None)\nCreate Mix with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MultiplyMatrices(matrix=None, matrix_001=None)\nPerform a matrix multiplication on two input matrices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\ni_matrix_001\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.PackUVIslands(\n    uv=None,\n    selection=True,\n    margin=0.001,\n    rotate=True,\n    method='Bounding Box',\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\nname\n\n\n\nnode\n\n\n\no_uv\nOutput socket: UV\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ProjectPoint(vector=None, transform=None)\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0)\nBuild a rotation from quaternion components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_w\nInput socket: W\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RandomValue(\n    min=None,\n    max=None,\n    min_001=0.0,\n    max_001=1.0,\n    min_002=0,\n    max_002=100,\n    probability=0.5,\n    id=0,\n    seed=0,\n    *,\n    data_type='FLOAT',\n)\nOutput a randomized value\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_id\nInput socket: ID\n\n\ni_max\nInput socket: Max\n\n\ni_max_001\nInput socket: Max\n\n\ni_max_002\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_min_001\nInput socket: Min\n\n\ni_min_002\nInput socket: Min\n\n\ni_probability\nInput socket: Probability\n\n\ni_seed\nInput socket: Seed\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\no_value_001\nOutput socket: Value\n\n\no_value_002\nOutput socket: Value\n\n\no_value_003\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Random Value with operation ‘Boolean’.\n\n\nfloat\nCreate Random Value with operation ‘Float’.\n\n\ninteger\nCreate Random Value with operation ‘Integer’.\n\n\nvector\nCreate Random Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.RandomValue.boolean(probability=0.5, id=0, seed=0)\nCreate Random Value with operation ‘Boolean’.\n\n\n\nnodes.converter.RandomValue.float(min=0.0, max=1.0, id=0, seed=0)\nCreate Random Value with operation ‘Float’.\n\n\n\nnodes.converter.RandomValue.integer(min=0, max=100, id=0, seed=0)\nCreate Random Value with operation ‘Integer’.\n\n\n\nnodes.converter.RandomValue.vector(min=None, max=None, id=0, seed=0)\nCreate Random Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.ReplaceString(string='', find='', replace='')\nReplace a given string segment with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_find\nInput socket: Find\n\n\ni_replace\nInput socket: Replace\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateEuler(\n    rotation=None,\n    rotate_by=None,\n    axis=None,\n    angle=0.0,\n    *,\n    rotation_type='EULER',\n    space='OBJECT',\n)\nApply a secondary Euler rotation to a given Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_type\n\n\n\nspace\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateRotation(\n    rotation=None,\n    rotate_by=None,\n    *,\n    rotation_space='GLOBAL',\n)\nApply a secondary rotation to a given rotation value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateVector(vector=None, rotation=None)\nApply a rotation to a given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToAxisAngle(rotation=None)\nConvert a rotation to axis angle components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_angle\nOutput socket: Angle\n\n\no_axis\nOutput socket: Axis\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToEuler(rotation=None)\nConvert a standard rotation value to an Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_euler\nOutput socket: Euler\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToQuaternion(rotation=None)\nRetrieve the quaternion components representing a rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_w\nOutput socket: W\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateBundle(bundle=None, *, define_signature=False)\nSplit a bundle into multiple sockets.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_signature\n\n\n\ni_bundle\nInput socket: Bundle\n\n\nname\n\n\n\nnode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateColor(color=None, *, mode='RGB')\nSplit a color into separate channels, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_blue\nOutput socket: Blue\n\n\no_green\nOutput socket: Green\n\n\no_red\nOutput socket: Red\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateMatrix(matrix=None)\nSplit a 4x4 matrix into its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_column_1_row_1\nOutput socket: Column 1 Row 1\n\n\no_column_1_row_2\nOutput socket: Column 1 Row 2\n\n\no_column_1_row_3\nOutput socket: Column 1 Row 3\n\n\no_column_1_row_4\nOutput socket: Column 1 Row 4\n\n\no_column_2_row_1\nOutput socket: Column 2 Row 1\n\n\no_column_2_row_2\nOutput socket: Column 2 Row 2\n\n\no_column_2_row_3\nOutput socket: Column 2 Row 3\n\n\no_column_2_row_4\nOutput socket: Column 2 Row 4\n\n\no_column_3_row_1\nOutput socket: Column 3 Row 1\n\n\no_column_3_row_2\nOutput socket: Column 3 Row 2\n\n\no_column_3_row_3\nOutput socket: Column 3 Row 3\n\n\no_column_3_row_4\nOutput socket: Column 3 Row 4\n\n\no_column_4_row_1\nOutput socket: Column 4 Row 1\n\n\no_column_4_row_2\nOutput socket: Column 4 Row 2\n\n\no_column_4_row_3\nOutput socket: Column 4 Row 3\n\n\no_column_4_row_4\nOutput socket: Column 4 Row 4\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateTransform(transform=None)\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_translation\nOutput socket: Translation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateXYZ(vector=None)\nSplit a vector into its X, Y, and Z components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SliceString(string='', position=0, length=10)\nExtract a string segment from a larger string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_length\nInput socket: Length\n\n\ni_position\nInput socket: Position\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.StringLength(string='')\nOutput the number of characters in the given string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.StringToValue(string='', *, data_type='FLOAT')\nDerive a numeric value from a given string representation\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate String to Value with operation ‘Float’.\n\n\ninteger\nCreate String to Value with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.StringToValue.float(string='')\nCreate String to Value with operation ‘Float’.\n\n\n\nnodes.converter.StringToValue.integer(string='')\nCreate String to Value with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    *,\n    input_type='GEOMETRY',\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\ninput_type\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Switch with operation ‘Boolean’.\n\n\nbundle\nCreate Switch with operation ‘Bundle’.\n\n\nclosure\nCreate Switch with operation ‘Closure’.\n\n\ncollection\nCreate Switch with operation ‘Collection’.\n\n\ncolor\nCreate Switch with operation ‘Color’.\n\n\nfloat\nCreate Switch with operation ‘Float’.\n\n\ngeometry\nCreate Switch with operation ‘Geometry’.\n\n\nimage\nCreate Switch with operation ‘Image’.\n\n\ninteger\nCreate Switch with operation ‘Integer’.\n\n\nmaterial\nCreate Switch with operation ‘Material’.\n\n\nmatrix\nCreate Switch with operation ‘Matrix’.\n\n\nmenu\nCreate Switch with operation ‘Menu’.\n\n\nobject\nCreate Switch with operation ‘Object’.\n\n\nrotation\nCreate Switch with operation ‘Rotation’.\n\n\nstring\nCreate Switch with operation ‘String’.\n\n\nvector\nCreate Switch with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.Switch.boolean(switch=False, false=False, true=False)\nCreate Switch with operation ‘Boolean’.\n\n\n\nnodes.converter.Switch.bundle(switch=False, false=None, true=None)\nCreate Switch with operation ‘Bundle’.\n\n\n\nnodes.converter.Switch.closure(switch=False, false=None, true=None)\nCreate Switch with operation ‘Closure’.\n\n\n\nnodes.converter.Switch.collection(switch=False, false=None, true=None)\nCreate Switch with operation ‘Collection’.\n\n\n\nnodes.converter.Switch.color(switch=False, false=None, true=None)\nCreate Switch with operation ‘Color’.\n\n\n\nnodes.converter.Switch.float(switch=False, false=0.0, true=0.0)\nCreate Switch with operation ‘Float’.\n\n\n\nnodes.converter.Switch.geometry(switch=False, false=None, true=None)\nCreate Switch with operation ‘Geometry’.\n\n\n\nnodes.converter.Switch.image(switch=False, false=None, true=None)\nCreate Switch with operation ‘Image’.\n\n\n\nnodes.converter.Switch.integer(switch=False, false=0, true=0)\nCreate Switch with operation ‘Integer’.\n\n\n\nnodes.converter.Switch.material(switch=False, false=None, true=None)\nCreate Switch with operation ‘Material’.\n\n\n\nnodes.converter.Switch.matrix(switch=False, false=None, true=None)\nCreate Switch with operation ‘Matrix’.\n\n\n\nnodes.converter.Switch.menu(switch=False, false='', true='')\nCreate Switch with operation ‘Menu’.\n\n\n\nnodes.converter.Switch.object(switch=False, false=None, true=None)\nCreate Switch with operation ‘Object’.\n\n\n\nnodes.converter.Switch.rotation(switch=False, false=None, true=None)\nCreate Switch with operation ‘Rotation’.\n\n\n\nnodes.converter.Switch.string(switch=False, false='', true='')\nCreate Switch with operation ‘String’.\n\n\n\nnodes.converter.Switch.vector(switch=False, false=None, true=None)\nCreate Switch with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.TransformDirection(direction=None, transform=None)\nApply a transformation matrix (excluding translation) to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_direction\nOutput socket: Direction\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.TransformPoint(vector=None, transform=None)\nApply a transformation matrix to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.TransposeMatrix(matrix=None)\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.UVUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.001,\n    fill_holes=True,\n    method='Angle Based',\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_uv\nOutput socket: UV\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ValueToString(value=0.0, decimals=0, *, data_type='FLOAT')\nGenerate a string representation of the given input value\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_decimals\nInput socket: Decimals\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Value to String with operation ‘Float’.\n\n\ninteger\nCreate Value to String with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.ValueToString.float(value=0.0, decimals=0)\nCreate Value to String with operation ‘Float’.\n\n\n\nnodes.converter.ValueToString.integer(value=0)\nCreate Value to String with operation ‘Integer’.",
    "crumbs": [
      "Some functions",
      "nodes.converter"
    ]
  },
  {
    "objectID": "reference/nodes.converter.html#classes",
    "href": "reference/nodes.converter.html#classes",
    "title": "nodes.converter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAlignRotationToVector\nOrient a rotation along the given direction\n\n\nAxesToRotation\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\nAxisAngleToRotation\nBuild a rotation from an axis and a rotation around that axis\n\n\nBitMath\nPerform bitwise operations on 32-bit integers\n\n\nBlackbody\nConvert a blackbody temperature to an RGB value\n\n\nBooleanMath\nPerform a logical operation on the given boolean inputs\n\n\nClamp\nClamp a value between a minimum and a maximum\n\n\nColorRamp\nMap values to colors with the use of a gradient\n\n\nCombineBundle\nCombine multiple socket values into one.\n\n\nCombineColor\nCombine four channels into a single color, based on a particular color model\n\n\nCombineMatrix\nConstruct a 4x4 matrix from its individual values\n\n\nCombineTransform\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\nCombineXYZ\nCreate a vector from X, Y, and Z components\n\n\nEulerToRotation\nBuild a rotation from separate angles around each axis\n\n\nFindInString\nFind the number of times a given string occurs in another string and the position of the first match\n\n\nFloatCurve\nMap an input float to a curve and outputs a float value\n\n\nFloatToInteger\nConvert the given floating-point number to an integer, with a choice of methods\n\n\nHashValue\nGenerate a randomized integer using the given input value as a seed\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nIntegerMath\nPerform various math operations on the given integer inputs\n\n\nInvertMatrix\nCompute the inverse of the given matrix, if one exists\n\n\nInvertRotation\nCompute the inverse of the given rotation\n\n\nJoinBundle\nJoin multiple bundles together\n\n\nMapRange\nRemap a value from a range to a target range\n\n\nMatchString\nCheck if a given string exists within another string\n\n\nMath\nPerform math operations\n\n\nMatrixDeterminant\nCompute the determinant of the given matrix\n\n\nMix\nMix values by a factor\n\n\nMultiplyMatrices\nPerform a matrix multiplication on two input matrices\n\n\nPackUVIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nProjectPoint\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\nQuaternionToRotation\nBuild a rotation from quaternion components\n\n\nRandomValue\nOutput a randomized value\n\n\nReplaceString\nReplace a given string segment with another\n\n\nRotateEuler\nApply a secondary Euler rotation to a given Euler rotation\n\n\nRotateRotation\nApply a secondary rotation to a given rotation value\n\n\nRotateVector\nApply a rotation to a given vector\n\n\nRotationToAxisAngle\nConvert a rotation to axis angle components\n\n\nRotationToEuler\nConvert a standard rotation value to an Euler rotation\n\n\nRotationToQuaternion\nRetrieve the quaternion components representing a rotation\n\n\nSeparateBundle\nSplit a bundle into multiple sockets.\n\n\nSeparateColor\nSplit a color into separate channels, based on a particular color model\n\n\nSeparateMatrix\nSplit a 4x4 matrix into its individual values\n\n\nSeparateTransform\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\nSeparateXYZ\nSplit a vector into its X, Y, and Z components\n\n\nSliceString\nExtract a string segment from a larger string\n\n\nStringLength\nOutput the number of characters in the given string\n\n\nStringToValue\nDerive a numeric value from a given string representation\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformDirection\nApply a transformation matrix (excluding translation) to the given vector\n\n\nTransformPoint\nApply a transformation matrix to the given vector\n\n\nTransposeMatrix\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\nUVUnwrap\nGenerate a UV map based on seam edges\n\n\nValueToString\nGenerate a string representation of the given input value\n\n\n\n\n\nnodes.converter.AlignRotationToVector(\n    rotation=None,\n    factor=1.0,\n    vector=None,\n    *,\n    axis='Z',\n    pivot_axis='AUTO',\n)\nOrient a rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\naxis\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\npivot_axis\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.AxesToRotation(\n    primary_axis=None,\n    secondary_axis=None,\n    *,\n    primary='Z',\n    secondary='X',\n)\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_primary_axis\nInput socket: Primary Axis\n\n\ni_secondary_axis\nInput socket: Secondary Axis\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nprimary\n\n\n\nprimary_axis\n\n\n\nsecondary\n\n\n\nsecondary_axis\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.AxisAngleToRotation(axis=None, angle=0.0)\nBuild a rotation from an axis and a rotation around that axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.BitMath(a=0, b=0, shift=0, *, operation='AND')\nPerform bitwise operations on 32-bit integers\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\ni_shift\nInput socket: Shift\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nexclusive_or\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\nl_and\nCreate Bit Math with operation ‘And’.\n\n\nl_not\nCreate Bit Math with operation ‘Not’.\n\n\nl_or\nCreate Bit Math with operation ‘Or’.\n\n\nrotate\nCreate Bit Math with operation ‘Rotate’.\n\n\nshift\nCreate Bit Math with operation ‘Shift’.\n\n\n\n\n\nnodes.converter.BitMath.exclusive_or(a=0, b=0)\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\nnodes.converter.BitMath.l_and(a=0, b=0)\nCreate Bit Math with operation ‘And’.\n\n\n\nnodes.converter.BitMath.l_not(a=0)\nCreate Bit Math with operation ‘Not’.\n\n\n\nnodes.converter.BitMath.l_or(a=0, b=0)\nCreate Bit Math with operation ‘Or’.\n\n\n\nnodes.converter.BitMath.rotate(a=0, shift=0)\nCreate Bit Math with operation ‘Rotate’.\n\n\n\nnodes.converter.BitMath.shift(a=0, shift=0)\nCreate Bit Math with operation ‘Shift’.\n\n\n\n\n\nnodes.converter.Blackbody(temperature=6500.0)\nConvert a blackbody temperature to an RGB value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_temperature\nInput socket: Temperature\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.BooleanMath(\n    boolean=False,\n    boolean_001=False,\n    *,\n    operation='AND',\n)\nPerform a logical operation on the given boolean inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boolean\nInput socket: Boolean\n\n\ni_boolean_001\nInput socket: Boolean\n\n\nname\n\n\n\nnode\n\n\n\no_boolean\nOutput socket: Boolean\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nequal\nCreate Boolean Math with operation ‘Equal’.\n\n\nimply\nCreate Boolean Math with operation ‘Imply’.\n\n\nl_and\nCreate Boolean Math with operation ‘And’.\n\n\nl_not\nCreate Boolean Math with operation ‘Not’.\n\n\nl_or\nCreate Boolean Math with operation ‘Or’.\n\n\nnor\nCreate Boolean Math with operation ‘Nor’.\n\n\nnot_and\nCreate Boolean Math with operation ‘Not And’.\n\n\nnot_equal\nCreate Boolean Math with operation ‘Not Equal’.\n\n\nsubtract\nCreate Boolean Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.BooleanMath.equal(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Equal’.\n\n\n\nnodes.converter.BooleanMath.imply(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Imply’.\n\n\n\nnodes.converter.BooleanMath.l_and(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘And’.\n\n\n\nnodes.converter.BooleanMath.l_not(boolean=False)\nCreate Boolean Math with operation ‘Not’.\n\n\n\nnodes.converter.BooleanMath.l_or(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Or’.\n\n\n\nnodes.converter.BooleanMath.nor(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Nor’.\n\n\n\nnodes.converter.BooleanMath.not_and(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Not And’.\n\n\n\nnodes.converter.BooleanMath.not_equal(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Not Equal’.\n\n\n\nnodes.converter.BooleanMath.subtract(boolean=False, boolean_001=False)\nCreate Boolean Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.Clamp(value=1.0, min=0.0, max=1.0, *, clamp_type='MINMAX')\nClamp a value between a minimum and a maximum\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp_type\n\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ColorRamp(fac=0.5)\nMap values to colors with the use of a gradient\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fac\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineBundle(define_signature=False)\nCombine multiple socket values into one.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_signature\n\n\n\nname\n\n\n\nnode\n\n\n\no_bundle\nOutput socket: Bundle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineColor(\n    red=0.0,\n    green=0.0,\n    blue=0.0,\n    alpha=1.0,\n    *,\n    mode='RGB',\n)\nCombine four channels into a single color, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_alpha\nInput socket: Alpha\n\n\ni_blue\nInput socket: Blue\n\n\ni_green\nInput socket: Green\n\n\ni_red\nInput socket: Red\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineMatrix(\n    column_1_row_1=1.0,\n    column_1_row_2=0.0,\n    column_1_row_3=0.0,\n    column_1_row_4=0.0,\n    column_2_row_1=0.0,\n    column_2_row_2=1.0,\n    column_2_row_3=0.0,\n    column_2_row_4=0.0,\n    column_3_row_1=0.0,\n    column_3_row_2=0.0,\n    column_3_row_3=1.0,\n    column_3_row_4=0.0,\n    column_4_row_1=0.0,\n    column_4_row_2=0.0,\n    column_4_row_3=0.0,\n    column_4_row_4=1.0,\n)\nConstruct a 4x4 matrix from its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_column_1_row_1\nInput socket: Column 1 Row 1\n\n\ni_column_1_row_2\nInput socket: Column 1 Row 2\n\n\ni_column_1_row_3\nInput socket: Column 1 Row 3\n\n\ni_column_1_row_4\nInput socket: Column 1 Row 4\n\n\ni_column_2_row_1\nInput socket: Column 2 Row 1\n\n\ni_column_2_row_2\nInput socket: Column 2 Row 2\n\n\ni_column_2_row_3\nInput socket: Column 2 Row 3\n\n\ni_column_2_row_4\nInput socket: Column 2 Row 4\n\n\ni_column_3_row_1\nInput socket: Column 3 Row 1\n\n\ni_column_3_row_2\nInput socket: Column 3 Row 2\n\n\ni_column_3_row_3\nInput socket: Column 3 Row 3\n\n\ni_column_3_row_4\nInput socket: Column 3 Row 4\n\n\ni_column_4_row_1\nInput socket: Column 4 Row 1\n\n\ni_column_4_row_2\nInput socket: Column 4 Row 2\n\n\ni_column_4_row_3\nInput socket: Column 4 Row 3\n\n\ni_column_4_row_4\nInput socket: Column 4 Row 4\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineTransform(translation=None, rotation=None, scale=None)\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.CombineXYZ(x=0.0, y=0.0, z=0.0)\nCreate a vector from X, Y, and Z components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.EulerToRotation(euler=None)\nBuild a rotation from separate angles around each axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_euler\nInput socket: Euler\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FindInString(string='', search='')\nFind the number of times a given string occurs in another string and the position of the first match\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_search\nInput socket: Search\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_count\nOutput socket: Count\n\n\no_first_found\nOutput socket: First Found\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FloatCurve(factor=1.0, value=1.0)\nMap an input float to a curve and outputs a float value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.FloatToInteger(float=0.0, *, rounding_mode='ROUND')\nConvert the given floating-point number to an integer, with a choice of methods\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_float\nInput socket: Float\n\n\nname\n\n\n\nnode\n\n\n\no_integer\nOutput socket: Integer\n\n\nrounding_mode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.HashValue(value=0, seed=0, *, data_type='INT')\nGenerate a randomized integer using the given input value as a seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_seed\nInput socket: Seed\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_hash\nOutput socket: Hash\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Hash Value with operation ‘Color’.\n\n\nfloat\nCreate Hash Value with operation ‘Float’.\n\n\ninteger\nCreate Hash Value with operation ‘Integer’.\n\n\nmatrix\nCreate Hash Value with operation ‘Matrix’.\n\n\nrotation\nCreate Hash Value with operation ‘Rotation’.\n\n\nstring\nCreate Hash Value with operation ‘String’.\n\n\nvector\nCreate Hash Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.HashValue.color(value=None, seed=0)\nCreate Hash Value with operation ‘Color’.\n\n\n\nnodes.converter.HashValue.float(value=0.0, seed=0)\nCreate Hash Value with operation ‘Float’.\n\n\n\nnodes.converter.HashValue.integer(value=0, seed=0)\nCreate Hash Value with operation ‘Integer’.\n\n\n\nnodes.converter.HashValue.matrix(value=None, seed=0)\nCreate Hash Value with operation ‘Matrix’.\n\n\n\nnodes.converter.HashValue.rotation(value=None, seed=0)\nCreate Hash Value with operation ‘Rotation’.\n\n\n\nnodes.converter.HashValue.string(value='', seed=0)\nCreate Hash Value with operation ‘String’.\n\n\n\nnodes.converter.HashValue.vector(value=None, seed=0)\nCreate Hash Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.IndexOfNearest(position=None, group_id=0)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\nname\n\n\n\nnode\n\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.IntegerMath(\n    value=0,\n    value_001=0,\n    value_002=0,\n    *,\n    operation='ADD',\n)\nPerform various math operations on the given integer inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\ni_value_002\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Integer Math with operation ‘Absolute’.\n\n\nadd\nCreate Integer Math with operation ‘Add’.\n\n\ndivide\nCreate Integer Math with operation ‘Divide’.\n\n\ndivide_ceiling\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\ndivide_floor\nCreate Integer Math with operation ‘Divide Floor’.\n\n\ndivide_round\nCreate Integer Math with operation ‘Divide Round’.\n\n\nfloored_modulo\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\ngreatest_common_divisor\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\nleast_common_multiple\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\nmaximum\nCreate Integer Math with operation ‘Maximum’.\n\n\nminimum\nCreate Integer Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Integer Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Integer Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Integer Math with operation ‘Multiply Add’.\n\n\nnegate\nCreate Integer Math with operation ‘Negate’.\n\n\npower\nCreate Integer Math with operation ‘Power’.\n\n\nsign\nCreate Integer Math with operation ‘Sign’.\n\n\nsubtract\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.IntegerMath.absolute(value=0)\nCreate Integer Math with operation ‘Absolute’.\n\n\n\nnodes.converter.IntegerMath.add(value=0, value_001=0)\nCreate Integer Math with operation ‘Add’.\n\n\n\nnodes.converter.IntegerMath.divide(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide’.\n\n\n\nnodes.converter.IntegerMath.divide_ceiling(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\n\nnodes.converter.IntegerMath.divide_floor(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Floor’.\n\n\n\nnodes.converter.IntegerMath.divide_round(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Round’.\n\n\n\nnodes.converter.IntegerMath.floored_modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\n\nnodes.converter.IntegerMath.greatest_common_divisor(value=0, value_001=0)\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\n\nnodes.converter.IntegerMath.least_common_multiple(value=0, value_001=0)\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\n\nnodes.converter.IntegerMath.maximum(value=0, value_001=0)\nCreate Integer Math with operation ‘Maximum’.\n\n\n\nnodes.converter.IntegerMath.minimum(value=0, value_001=0)\nCreate Integer Math with operation ‘Minimum’.\n\n\n\nnodes.converter.IntegerMath.modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Modulo’.\n\n\n\nnodes.converter.IntegerMath.multiply(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply’.\n\n\n\nnodes.converter.IntegerMath.multiply_add(value=0, value_001=0, value_002=0)\nCreate Integer Math with operation ‘Multiply Add’.\n\n\n\nnodes.converter.IntegerMath.negate(value=0)\nCreate Integer Math with operation ‘Negate’.\n\n\n\nnodes.converter.IntegerMath.power(value=0, value_001=0)\nCreate Integer Math with operation ‘Power’.\n\n\n\nnodes.converter.IntegerMath.sign(value=0)\nCreate Integer Math with operation ‘Sign’.\n\n\n\nnodes.converter.IntegerMath.subtract(value=0, value_001=0)\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.converter.InvertMatrix(matrix=None)\nCompute the inverse of the given matrix, if one exists\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_invertible\nOutput socket: Invertible\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.InvertRotation(rotation=None)\nCompute the inverse of the given rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.JoinBundle(bundle=None)\nJoin multiple bundles together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bundle\nInput socket: Bundle\n\n\nname\n\n\n\nnode\n\n\n\no_bundle\nOutput socket: Bundle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.MapRange(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n    steps=4.0,\n    vector=None,\n    from_min_float3=None,\n    from_max_float3=None,\n    to_min_float3=None,\n    to_max_float3=None,\n    steps_float3=None,\n    *,\n    clamp=False,\n    interpolation_type='LINEAR',\n    data_type='FLOAT',\n)\nRemap a value from a range to a target range\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp\n\n\n\ndata_type\n\n\n\ni_from_max\nInput socket: From Max\n\n\ni_from_max_float3\nInput socket: From Max\n\n\ni_from_min\nInput socket: From Min\n\n\ni_from_min_float3\nInput socket: From Min\n\n\ni_steps\nInput socket: Steps\n\n\ni_steps_float3\nInput socket: Steps\n\n\ni_to_max\nInput socket: To Max\n\n\ni_to_max_float3\nInput socket: To Max\n\n\ni_to_min\nInput socket: To Min\n\n\ni_to_min_float3\nInput socket: To Min\n\n\ni_value\nInput socket: Value\n\n\ni_vector\nInput socket: Vector\n\n\ninterpolation_type\n\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Map Range with operation ‘Float’.\n\n\nvector\nCreate Map Range with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MapRange.float(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n)\nCreate Map Range with operation ‘Float’.\n\n\n\nnodes.converter.MapRange.vector(\n    vector=None,\n    from_min3=None,\n    from_max3=None,\n    to_min3=None,\n    to_max3=None,\n)\nCreate Map Range with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MatchString(string='', operation='Starts With', key='')\nCheck if a given string exists within another string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_key\nInput socket: Key\n\n\ni_operation\nInput socket: Operation\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_result\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.Math(\n    value=0.5,\n    value_001=0.5,\n    value_002=0.5,\n    *,\n    operation='ADD',\n    use_clamp=False,\n)\nPerform math operations\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\ni_value_002\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\nuse_clamp\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Math with operation ‘Absolute’.\n\n\nadd\nCreate Math with operation ‘Add’.\n\n\narccosine\nCreate Math with operation ‘Arccosine’.\n\n\narcsine\nCreate Math with operation ‘Arcsine’.\n\n\narctan2\nCreate Math with operation ‘Arctan2’.\n\n\narctangent\nCreate Math with operation ‘Arctangent’.\n\n\nceil\nCreate Math with operation ‘Ceil’.\n\n\ncompare\nCreate Math with operation ‘Compare’.\n\n\ncosine\nCreate Math with operation ‘Cosine’.\n\n\ndivide\nCreate Math with operation ‘Divide’.\n\n\nexponent\nCreate Math with operation ‘Exponent’.\n\n\nfloor\nCreate Math with operation ‘Floor’.\n\n\nfloored_modulo\nCreate Math with operation ‘Floored Modulo’.\n\n\nfraction\nCreate Math with operation ‘Fraction’.\n\n\ngreater_than\nCreate Math with operation ‘Greater Than’.\n\n\nhyperbolic_cosine\nCreate Math with operation ‘Hyperbolic Cosine’.\n\n\nhyperbolic_sine\nCreate Math with operation ‘Hyperbolic Sine’.\n\n\nhyperbolic_tangent\nCreate Math with operation ‘Hyperbolic Tangent’.\n\n\ninverse_square_root\nCreate Math with operation ‘Inverse Square Root’.\n\n\nless_than\nCreate Math with operation ‘Less Than’.\n\n\nlogarithm\nCreate Math with operation ‘Logarithm’.\n\n\nmaximum\nCreate Math with operation ‘Maximum’.\n\n\nminimum\nCreate Math with operation ‘Minimum’.\n\n\nmultiply\nCreate Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Math with operation ‘Multiply Add’.\n\n\nping_pong\nCreate Math with operation ‘Ping-Pong’.\n\n\npower\nCreate Math with operation ‘Power’.\n\n\nround\nCreate Math with operation ‘Round’.\n\n\nsign\nCreate Math with operation ‘Sign’.\n\n\nsine\nCreate Math with operation ‘Sine’.\n\n\nsmooth_maximum\nCreate Math with operation ‘Smooth Maximum’.\n\n\nsmooth_minimum\nCreate Math with operation ‘Smooth Minimum’.\n\n\nsnap\nCreate Math with operation ‘Snap’.\n\n\nsquare_root\nCreate Math with operation ‘Square Root’.\n\n\nsubtract\nCreate Math with operation ‘Subtract’.\n\n\ntangent\nCreate Math with operation ‘Tangent’.\n\n\nto_degrees\nCreate Math with operation ‘To Degrees’.\n\n\nto_radians\nCreate Math with operation ‘To Radians’.\n\n\ntruncate\nCreate Math with operation ‘Truncate’.\n\n\ntruncated_modulo\nCreate Math with operation ‘Truncated Modulo’.\n\n\nwrap\nCreate Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.converter.Math.absolute(value=0.5)\nCreate Math with operation ‘Absolute’.\n\n\n\nnodes.converter.Math.add(value=0.5, value_001=0.5)\nCreate Math with operation ‘Add’.\n\n\n\nnodes.converter.Math.arccosine(value=0.5)\nCreate Math with operation ‘Arccosine’.\n\n\n\nnodes.converter.Math.arcsine(value=0.5)\nCreate Math with operation ‘Arcsine’.\n\n\n\nnodes.converter.Math.arctan2(value=0.5, value_001=0.5)\nCreate Math with operation ‘Arctan2’.\n\n\n\nnodes.converter.Math.arctangent(value=0.5)\nCreate Math with operation ‘Arctangent’.\n\n\n\nnodes.converter.Math.ceil(value=0.5)\nCreate Math with operation ‘Ceil’.\n\n\n\nnodes.converter.Math.compare(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Compare’.\n\n\n\nnodes.converter.Math.cosine(value=0.5)\nCreate Math with operation ‘Cosine’.\n\n\n\nnodes.converter.Math.divide(value=0.5, value_001=0.5)\nCreate Math with operation ‘Divide’.\n\n\n\nnodes.converter.Math.exponent(value=0.5)\nCreate Math with operation ‘Exponent’.\n\n\n\nnodes.converter.Math.floor(value=0.5)\nCreate Math with operation ‘Floor’.\n\n\n\nnodes.converter.Math.floored_modulo(value=0.5, value_001=0.5)\nCreate Math with operation ‘Floored Modulo’.\n\n\n\nnodes.converter.Math.fraction(value=0.5)\nCreate Math with operation ‘Fraction’.\n\n\n\nnodes.converter.Math.greater_than(value=0.5, value_001=0.5)\nCreate Math with operation ‘Greater Than’.\n\n\n\nnodes.converter.Math.hyperbolic_cosine(value=0.5)\nCreate Math with operation ‘Hyperbolic Cosine’.\n\n\n\nnodes.converter.Math.hyperbolic_sine(value=0.5)\nCreate Math with operation ‘Hyperbolic Sine’.\n\n\n\nnodes.converter.Math.hyperbolic_tangent(value=0.5)\nCreate Math with operation ‘Hyperbolic Tangent’.\n\n\n\nnodes.converter.Math.inverse_square_root(value=0.5)\nCreate Math with operation ‘Inverse Square Root’.\n\n\n\nnodes.converter.Math.less_than(value=0.5, value_001=0.5)\nCreate Math with operation ‘Less Than’.\n\n\n\nnodes.converter.Math.logarithm(value=0.5, value_001=0.5)\nCreate Math with operation ‘Logarithm’.\n\n\n\nnodes.converter.Math.maximum(value=0.5, value_001=0.5)\nCreate Math with operation ‘Maximum’.\n\n\n\nnodes.converter.Math.minimum(value=0.5, value_001=0.5)\nCreate Math with operation ‘Minimum’.\n\n\n\nnodes.converter.Math.multiply(value=0.5, value_001=0.5)\nCreate Math with operation ‘Multiply’.\n\n\n\nnodes.converter.Math.multiply_add(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Multiply Add’.\n\n\n\nnodes.converter.Math.ping_pong(value=0.5, value_001=0.5)\nCreate Math with operation ‘Ping-Pong’.\n\n\n\nnodes.converter.Math.power(value=0.5, value_001=0.5)\nCreate Math with operation ‘Power’.\n\n\n\nnodes.converter.Math.round(value=0.5)\nCreate Math with operation ‘Round’.\n\n\n\nnodes.converter.Math.sign(value=0.5)\nCreate Math with operation ‘Sign’.\n\n\n\nnodes.converter.Math.sine(value=0.5)\nCreate Math with operation ‘Sine’.\n\n\n\nnodes.converter.Math.smooth_maximum(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Smooth Maximum’.\n\n\n\nnodes.converter.Math.smooth_minimum(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Smooth Minimum’.\n\n\n\nnodes.converter.Math.snap(value=0.5, value_001=0.5)\nCreate Math with operation ‘Snap’.\n\n\n\nnodes.converter.Math.square_root(value=0.5)\nCreate Math with operation ‘Square Root’.\n\n\n\nnodes.converter.Math.subtract(value=0.5, value_001=0.5)\nCreate Math with operation ‘Subtract’.\n\n\n\nnodes.converter.Math.tangent(value=0.5)\nCreate Math with operation ‘Tangent’.\n\n\n\nnodes.converter.Math.to_degrees(value=0.5)\nCreate Math with operation ‘To Degrees’.\n\n\n\nnodes.converter.Math.to_radians(value=0.5)\nCreate Math with operation ‘To Radians’.\n\n\n\nnodes.converter.Math.truncate(value=0.5)\nCreate Math with operation ‘Truncate’.\n\n\n\nnodes.converter.Math.truncated_modulo(value=0.5, value_001=0.5)\nCreate Math with operation ‘Truncated Modulo’.\n\n\n\nnodes.converter.Math.wrap(value=0.5, value_001=0.5, value_002=0.5)\nCreate Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.converter.MatrixDeterminant(matrix=None)\nCompute the determinant of the given matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_determinant\nOutput socket: Determinant\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.Mix(\n    factor_float=0.5,\n    factor_vector=None,\n    a_float=0.0,\n    b_float=0.0,\n    a_vector=None,\n    b_vector=None,\n    a_color=None,\n    b_color=None,\n    a_rotation=None,\n    b_rotation=None,\n    *,\n    data_type='FLOAT',\n    factor_mode='UNIFORM',\n    blend_type='MIX',\n    clamp_factor=False,\n    clamp_result=False,\n)\nMix values by a factor\n\n\n\n\n\nName\nDescription\n\n\n\n\nblend_type\n\n\n\nclamp_factor\n\n\n\nclamp_result\n\n\n\ndata_type\n\n\n\nfactor_mode\n\n\n\ni_a_color\nInput socket: A\n\n\ni_a_float\nInput socket: A\n\n\ni_a_rotation\nInput socket: A\n\n\ni_a_vector\nInput socket: A\n\n\ni_b_color\nInput socket: B\n\n\ni_b_float\nInput socket: B\n\n\ni_b_rotation\nInput socket: B\n\n\ni_b_vector\nInput socket: B\n\n\ni_factor_float\nInput socket: Factor\n\n\ni_factor_vector\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_result_color\nOutput socket: Result\n\n\no_result_float\nOutput socket: Result\n\n\no_result_rotation\nOutput socket: Result\n\n\no_result_vector\nOutput socket: Result\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Mix with operation ‘Color’.\n\n\nfloat\nCreate Mix with operation ‘Float’.\n\n\nrotation\nCreate Mix with operation ‘Rotation’.\n\n\nvector\nCreate Mix with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.Mix.color(factor=0.5, a_color=None, b_color=None)\nCreate Mix with operation ‘Color’.\n\n\n\nnodes.converter.Mix.float(factor=0.5, a=0.0, b=0.0)\nCreate Mix with operation ‘Float’.\n\n\n\nnodes.converter.Mix.rotation(factor=0.5, a_rotation=None, b_rotation=None)\nCreate Mix with operation ‘Rotation’.\n\n\n\nnodes.converter.Mix.vector(factor=0.5, a=None, b=None)\nCreate Mix with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.MultiplyMatrices(matrix=None, matrix_001=None)\nPerform a matrix multiplication on two input matrices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\ni_matrix_001\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.PackUVIslands(\n    uv=None,\n    selection=True,\n    margin=0.001,\n    rotate=True,\n    method='Bounding Box',\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\nname\n\n\n\nnode\n\n\n\no_uv\nOutput socket: UV\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ProjectPoint(vector=None, transform=None)\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0)\nBuild a rotation from quaternion components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_w\nInput socket: W\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RandomValue(\n    min=None,\n    max=None,\n    min_001=0.0,\n    max_001=1.0,\n    min_002=0,\n    max_002=100,\n    probability=0.5,\n    id=0,\n    seed=0,\n    *,\n    data_type='FLOAT',\n)\nOutput a randomized value\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_id\nInput socket: ID\n\n\ni_max\nInput socket: Max\n\n\ni_max_001\nInput socket: Max\n\n\ni_max_002\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_min_001\nInput socket: Min\n\n\ni_min_002\nInput socket: Min\n\n\ni_probability\nInput socket: Probability\n\n\ni_seed\nInput socket: Seed\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\no_value_001\nOutput socket: Value\n\n\no_value_002\nOutput socket: Value\n\n\no_value_003\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Random Value with operation ‘Boolean’.\n\n\nfloat\nCreate Random Value with operation ‘Float’.\n\n\ninteger\nCreate Random Value with operation ‘Integer’.\n\n\nvector\nCreate Random Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.RandomValue.boolean(probability=0.5, id=0, seed=0)\nCreate Random Value with operation ‘Boolean’.\n\n\n\nnodes.converter.RandomValue.float(min=0.0, max=1.0, id=0, seed=0)\nCreate Random Value with operation ‘Float’.\n\n\n\nnodes.converter.RandomValue.integer(min=0, max=100, id=0, seed=0)\nCreate Random Value with operation ‘Integer’.\n\n\n\nnodes.converter.RandomValue.vector(min=None, max=None, id=0, seed=0)\nCreate Random Value with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.ReplaceString(string='', find='', replace='')\nReplace a given string segment with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_find\nInput socket: Find\n\n\ni_replace\nInput socket: Replace\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateEuler(\n    rotation=None,\n    rotate_by=None,\n    axis=None,\n    angle=0.0,\n    *,\n    rotation_type='EULER',\n    space='OBJECT',\n)\nApply a secondary Euler rotation to a given Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_type\n\n\n\nspace\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateRotation(\n    rotation=None,\n    rotate_by=None,\n    *,\n    rotation_space='GLOBAL',\n)\nApply a secondary rotation to a given rotation value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotateVector(vector=None, rotation=None)\nApply a rotation to a given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToAxisAngle(rotation=None)\nConvert a rotation to axis angle components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_angle\nOutput socket: Angle\n\n\no_axis\nOutput socket: Axis\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToEuler(rotation=None)\nConvert a standard rotation value to an Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_euler\nOutput socket: Euler\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.RotationToQuaternion(rotation=None)\nRetrieve the quaternion components representing a rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\nname\n\n\n\nnode\n\n\n\no_w\nOutput socket: W\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateBundle(bundle=None, *, define_signature=False)\nSplit a bundle into multiple sockets.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefine_signature\n\n\n\ni_bundle\nInput socket: Bundle\n\n\nname\n\n\n\nnode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateColor(color=None, *, mode='RGB')\nSplit a color into separate channels, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_blue\nOutput socket: Blue\n\n\no_green\nOutput socket: Green\n\n\no_red\nOutput socket: Red\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateMatrix(matrix=None)\nSplit a 4x4 matrix into its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_column_1_row_1\nOutput socket: Column 1 Row 1\n\n\no_column_1_row_2\nOutput socket: Column 1 Row 2\n\n\no_column_1_row_3\nOutput socket: Column 1 Row 3\n\n\no_column_1_row_4\nOutput socket: Column 1 Row 4\n\n\no_column_2_row_1\nOutput socket: Column 2 Row 1\n\n\no_column_2_row_2\nOutput socket: Column 2 Row 2\n\n\no_column_2_row_3\nOutput socket: Column 2 Row 3\n\n\no_column_2_row_4\nOutput socket: Column 2 Row 4\n\n\no_column_3_row_1\nOutput socket: Column 3 Row 1\n\n\no_column_3_row_2\nOutput socket: Column 3 Row 2\n\n\no_column_3_row_3\nOutput socket: Column 3 Row 3\n\n\no_column_3_row_4\nOutput socket: Column 3 Row 4\n\n\no_column_4_row_1\nOutput socket: Column 4 Row 1\n\n\no_column_4_row_2\nOutput socket: Column 4 Row 2\n\n\no_column_4_row_3\nOutput socket: Column 4 Row 3\n\n\no_column_4_row_4\nOutput socket: Column 4 Row 4\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateTransform(transform=None)\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_translation\nOutput socket: Translation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SeparateXYZ(vector=None)\nSplit a vector into its X, Y, and Z components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.SliceString(string='', position=0, length=10)\nExtract a string segment from a larger string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_length\nInput socket: Length\n\n\ni_position\nInput socket: Position\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.StringLength(string='')\nOutput the number of characters in the given string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.StringToValue(string='', *, data_type='FLOAT')\nDerive a numeric value from a given string representation\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_string\nInput socket: String\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate String to Value with operation ‘Float’.\n\n\ninteger\nCreate String to Value with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.StringToValue.float(string='')\nCreate String to Value with operation ‘Float’.\n\n\n\nnodes.converter.StringToValue.integer(string='')\nCreate String to Value with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    *,\n    input_type='GEOMETRY',\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\ninput_type\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Switch with operation ‘Boolean’.\n\n\nbundle\nCreate Switch with operation ‘Bundle’.\n\n\nclosure\nCreate Switch with operation ‘Closure’.\n\n\ncollection\nCreate Switch with operation ‘Collection’.\n\n\ncolor\nCreate Switch with operation ‘Color’.\n\n\nfloat\nCreate Switch with operation ‘Float’.\n\n\ngeometry\nCreate Switch with operation ‘Geometry’.\n\n\nimage\nCreate Switch with operation ‘Image’.\n\n\ninteger\nCreate Switch with operation ‘Integer’.\n\n\nmaterial\nCreate Switch with operation ‘Material’.\n\n\nmatrix\nCreate Switch with operation ‘Matrix’.\n\n\nmenu\nCreate Switch with operation ‘Menu’.\n\n\nobject\nCreate Switch with operation ‘Object’.\n\n\nrotation\nCreate Switch with operation ‘Rotation’.\n\n\nstring\nCreate Switch with operation ‘String’.\n\n\nvector\nCreate Switch with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.Switch.boolean(switch=False, false=False, true=False)\nCreate Switch with operation ‘Boolean’.\n\n\n\nnodes.converter.Switch.bundle(switch=False, false=None, true=None)\nCreate Switch with operation ‘Bundle’.\n\n\n\nnodes.converter.Switch.closure(switch=False, false=None, true=None)\nCreate Switch with operation ‘Closure’.\n\n\n\nnodes.converter.Switch.collection(switch=False, false=None, true=None)\nCreate Switch with operation ‘Collection’.\n\n\n\nnodes.converter.Switch.color(switch=False, false=None, true=None)\nCreate Switch with operation ‘Color’.\n\n\n\nnodes.converter.Switch.float(switch=False, false=0.0, true=0.0)\nCreate Switch with operation ‘Float’.\n\n\n\nnodes.converter.Switch.geometry(switch=False, false=None, true=None)\nCreate Switch with operation ‘Geometry’.\n\n\n\nnodes.converter.Switch.image(switch=False, false=None, true=None)\nCreate Switch with operation ‘Image’.\n\n\n\nnodes.converter.Switch.integer(switch=False, false=0, true=0)\nCreate Switch with operation ‘Integer’.\n\n\n\nnodes.converter.Switch.material(switch=False, false=None, true=None)\nCreate Switch with operation ‘Material’.\n\n\n\nnodes.converter.Switch.matrix(switch=False, false=None, true=None)\nCreate Switch with operation ‘Matrix’.\n\n\n\nnodes.converter.Switch.menu(switch=False, false='', true='')\nCreate Switch with operation ‘Menu’.\n\n\n\nnodes.converter.Switch.object(switch=False, false=None, true=None)\nCreate Switch with operation ‘Object’.\n\n\n\nnodes.converter.Switch.rotation(switch=False, false=None, true=None)\nCreate Switch with operation ‘Rotation’.\n\n\n\nnodes.converter.Switch.string(switch=False, false='', true='')\nCreate Switch with operation ‘String’.\n\n\n\nnodes.converter.Switch.vector(switch=False, false=None, true=None)\nCreate Switch with operation ‘Vector’.\n\n\n\n\n\nnodes.converter.TransformDirection(direction=None, transform=None)\nApply a transformation matrix (excluding translation) to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_direction\nOutput socket: Direction\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.TransformPoint(vector=None, transform=None)\nApply a transformation matrix to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.TransposeMatrix(matrix=None)\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\nname\n\n\n\nnode\n\n\n\no_matrix\nOutput socket: Matrix\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.UVUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.001,\n    fill_holes=True,\n    method='Angle Based',\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_uv\nOutput socket: UV\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.converter.ValueToString(value=0.0, decimals=0, *, data_type='FLOAT')\nGenerate a string representation of the given input value\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_decimals\nInput socket: Decimals\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Value to String with operation ‘Float’.\n\n\ninteger\nCreate Value to String with operation ‘Integer’.\n\n\n\n\n\nnodes.converter.ValueToString.float(value=0.0, decimals=0)\nCreate Value to String with operation ‘Float’.\n\n\n\nnodes.converter.ValueToString.integer(value=0)\nCreate Value to String with operation ‘Integer’.",
    "crumbs": [
      "Some functions",
      "nodes.converter"
    ]
  },
  {
    "objectID": "reference/nodes.input.html",
    "href": "reference/nodes.input.html",
    "title": "nodes.input",
    "section": "",
    "text": "nodes.input\n\n\n\n\n\nName\nDescription\n\n\n\n\nActiveCamera\nRetrieve the scene’s active camera\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nBoolean\nProvide a True/False value that can be connected to other nodes in the tree\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollection\nOutput a single collection\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nColor\nOutput a color value chosen with the color picker widget\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nCursor3D\nThe scene’s 3D cursor location and rotation\n\n\nCurveHandlePositions\nRetrieve the position of each Bézier control point’s handles\n\n\nCurveOfPoint\nRetrieve the curve a control point is part of\n\n\nCurveTangent\nRetrieve the direction of curves at each control point\n\n\nCurveTilt\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\nEdgeAngle\nThe angle between the normals of connected manifold faces\n\n\nEdgeNeighbors\nRetrieve the number of faces that use each edge as one of their sides\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgeVertices\nRetrieve topology information relating to each edge of a mesh\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEndpointSelection\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\nFaceArea\nCalculate the surface area of a mesh’s faces\n\n\nFaceGroupBoundaries\nFind edges on the boundaries between groups of faces with the same ID value\n\n\nFaceNeighbors\nRetrieve topology information relating to each face of a mesh\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nID\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\nImage\nInput an image data-block\n\n\nImageInfo\nRetrieve information about an image\n\n\nImportCSV\nImport geometry from an CSV file\n\n\nImportOBJ\nImport geometry from an OBJ file\n\n\nImportPLY\nImport a point cloud from a PLY file\n\n\nImportSTL\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVDB\nImport volume data from a .vdb file\n\n\nIndex\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\nInstanceBounds\nCalculate position bounds of each instance’s geometry set\n\n\nInstanceRotation\nRetrieve the rotation of each instance in the geometry\n\n\nInstanceScale\nRetrieve the scale of each instance in the geometry\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInteger\nProvide an integer value that can be connected to other nodes in the tree\n\n\nIsEdgeSmooth\nRetrieve whether each edge is marked for smooth or split normals\n\n\nIsFacePlanar\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\nIsFaceSmooth\nRetrieve whether each face is marked for smooth or sharp normals\n\n\nIsSplineCyclic\nRetrieve whether each spline endpoint connects to the beginning\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nMaterial\nOutput a single material\n\n\nMaterialIndex\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\nMeshIsland\nRetrieve information about separate connected regions in a mesh\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nNamedAttribute\nRetrieve the data of a specified attribute\n\n\nNamedLayerSelection\nOutput a selection of a Grease Pencil layer\n\n\nNormal\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\nObject\nOutput a single object\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nOffsetPointInCurve\nOffset a control point index within its curve\n\n\nPointsOfCurve\nRetrieve a point index within a curve\n\n\nPosition\nRetrieve a vector indicating the location of each element\n\n\nRadius\nRetrieve the radius at each point on curve or point cloud geometry\n\n\nRotation\nProvide a rotation value that can be connected to other nodes in the tree\n\n\nSceneTime\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nShortestEdgePaths\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\nSpecialCharacters\nOutput string characters that cannot be typed directly with the keyboard\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplineResolution\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\nString\nProvide a string value that can be connected to other nodes in the tree\n\n\nUVTangent\nGenerate tangent directions based on a UV map\n\n\nVector\nProvide a vector value that can be connected to other nodes in the tree\n\n\nVertexNeighbors\nRetrieve topology information relating to each vertex of a mesh\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVoxelIndex\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nnodes.input.ActiveCamera()\nRetrieve the scene’s active camera\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_active_camera\nOutput socket: Active Camera\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ActiveElement(domain='POINT')\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\nname\n\n\n\nnode\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Active Element with operation ‘Edge’.\n\n\nface\nCreate Active Element with operation ‘Face’.\n\n\nlayer\nCreate Active Element with operation ‘Layer’.\n\n\npoint\nCreate Active Element with operation ‘Point’.\n\n\n\n\n\nnodes.input.ActiveElement.edge()\nCreate Active Element with operation ‘Edge’.\n\n\n\nnodes.input.ActiveElement.face()\nCreate Active Element with operation ‘Face’.\n\n\n\nnodes.input.ActiveElement.layer()\nCreate Active Element with operation ‘Layer’.\n\n\n\nnodes.input.ActiveElement.point()\nCreate Active Element with operation ‘Point’.\n\n\n\n\n\nnodes.input.Boolean(boolean=False)\nProvide a True/False value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nname\n\n\n\nnode\n\n\n\no_boolean\nOutput socket: Boolean\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CameraInfo(camera=None)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\nname\n\n\n\nnode\n\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Collection()\nOutput a single collection\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_collection\nOutput socket: Collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    *,\n    transform_space='ORIGINAL',\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntransform_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Color(value=(0.735, 0.735, 0.735, 1.0))\nOutput a color value chosen with the color picker widget\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\nvalue\n\n\n\n\n\n\n\n\nnodes.input.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CornersOfFace(face_index=0, weights=0.0, sort_index=0)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CornersOfVertex(vertex_index=0, weights=0.0, sort_index=0)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Cursor3D()\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveHandlePositions(relative=False)\nRetrieve the position of each Bézier control point’s handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_relative\nInput socket: Relative\n\n\nname\n\n\n\nnode\n\n\n\no_left\nOutput socket: Left\n\n\no_right\nOutput socket: Right\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveOfPoint(point_index=0)\nRetrieve the curve a control point is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_index\nInput socket: Point Index\n\n\nname\n\n\n\nnode\n\n\n\no_curve_index\nOutput socket: Curve Index\n\n\no_index_in_curve\nOutput socket: Index in Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveTangent()\nRetrieve the direction of curves at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveTilt()\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_tilt\nOutput socket: Tilt\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeAngle()\nThe angle between the normals of connected manifold faces\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_signed_angle\nOutput socket: Signed Angle\n\n\no_unsigned_angle\nOutput socket: Unsigned Angle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeNeighbors()\nRetrieve the number of faces that use each edge as one of their sides\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgePathsToSelection(start_vertices=True, next_vertex_index=-1)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeVertices()\nRetrieve topology information relating to each edge of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_position_1\nOutput socket: Position 1\n\n\no_position_2\nOutput socket: Position 2\n\n\no_vertex_index_1\nOutput socket: Vertex Index 1\n\n\no_vertex_index_2\nOutput socket: Vertex Index 2\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesOfCorner(corner_index=0)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesOfVertex(vertex_index=0, weights=0.0, sort_index=0)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesToFaceGroups(boundary_edges=True)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\nname\n\n\n\nnode\n\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EndpointSelection(start_size=1, end_size=1)\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_size\nInput socket: End Size\n\n\ni_start_size\nInput socket: Start Size\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceArea()\nCalculate the surface area of a mesh’s faces\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_area\nOutput socket: Area\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceGroupBoundaries(face_set=0)\nFind edges on the boundaries between groups of faces with the same ID value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Group ID\n\n\nname\n\n\n\nnode\n\n\n\no_boundary_edges\nOutput socket: Boundary Edges\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceNeighbors()\nRetrieve topology information relating to each face of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceOfCorner(corner_index=0)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceSet()\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ID()\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_id\nOutput socket: ID\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Image()\nInput an image data-block\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_image\nOutput socket: Image\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImageInfo(image=None, frame=0)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\nname\n\n\n\nnode\n\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportCSV(path='', delimiter=',')\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportOBJ(path='')\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportPLY(path='')\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportSTL(path='')\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportText(path='')\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportVDB(path='')\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Index()\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceBounds(use_radius=True)\nCalculate position bounds of each instance’s geometry set\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_use_radius\nInput socket: Use Radius\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceRotation()\nRetrieve the rotation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceScale()\nRetrieve the scale of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_scale\nOutput socket: Scale\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceTransform()\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Integer(integer=1)\nProvide an integer value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\ninteger\n\n\n\nname\n\n\n\nnode\n\n\n\no_integer\nOutput socket: Integer\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsEdgeSmooth()\nRetrieve whether each edge is marked for smooth or split normals\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_smooth\nOutput socket: Smooth\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsFacePlanar(threshold=0.01)\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_planar\nOutput socket: Planar\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsFaceSmooth()\nRetrieve whether each face is marked for smooth or sharp normals\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_smooth\nOutput socket: Smooth\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsSplineCyclic()\nRetrieve whether each spline endpoint connects to the beginning\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_cyclic\nOutput socket: Cyclic\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsViewport()\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Material()\nOutput a single material\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_material\nOutput socket: Material\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MaterialIndex()\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_material_index\nOutput socket: Material Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MeshIsland()\nRetrieve information about separate connected regions in a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_island_count\nOutput socket: Island Count\n\n\no_island_index\nOutput socket: Island Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MousePosition()\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.NamedAttribute(name='', *, data_type='FLOAT')\nRetrieve the data of a specified attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_attribute\nOutput socket: Attribute\n\n\no_exists\nOutput socket: Exists\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Named Attribute with operation ‘Boolean’.\n\n\ncolor\nCreate Named Attribute with operation ‘Color’.\n\n\nfloat\nCreate Named Attribute with operation ‘Float’.\n\n\ninteger\nCreate Named Attribute with operation ‘Integer’.\n\n\nmatrix\nCreate Named Attribute with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Named Attribute with operation ‘Quaternion’.\n\n\nvector\nCreate Named Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.input.NamedAttribute.boolean(name='')\nCreate Named Attribute with operation ‘Boolean’.\n\n\n\nnodes.input.NamedAttribute.color(name='')\nCreate Named Attribute with operation ‘Color’.\n\n\n\nnodes.input.NamedAttribute.float(name='')\nCreate Named Attribute with operation ‘Float’.\n\n\n\nnodes.input.NamedAttribute.integer(name='')\nCreate Named Attribute with operation ‘Integer’.\n\n\n\nnodes.input.NamedAttribute.matrix(name='')\nCreate Named Attribute with operation ‘4x4 Matrix’.\n\n\n\nnodes.input.NamedAttribute.quaternion(name='')\nCreate Named Attribute with operation ‘Quaternion’.\n\n\n\nnodes.input.NamedAttribute.vector(name='')\nCreate Named Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.input.NamedLayerSelection(name='')\nOutput a selection of a Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Normal(legacy_corner_normals=False)\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\n\n\n\nName\nDescription\n\n\n\n\nlegacy_corner_normals\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_true_normal\nOutput socket: True Normal\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Object()\nOutput a single object\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_object\nOutput socket: Object\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ObjectInfo(\n    object=None,\n    as_instance=False,\n    *,\n    transform_space='ORIGINAL',\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\ntransform_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.OffsetCornerInFace(corner_index=0, offset=0)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.OffsetPointInCurve(point_index=0, offset=0)\nOffset a control point index within its curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_index\nInput socket: Point Index\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid_offset\nOutput socket: Is Valid Offset\n\n\no_point_index\nOutput socket: Point Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0)\nRetrieve a point index within a curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_point_index\nOutput socket: Point Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Position()\nRetrieve a vector indicating the location of each element\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_position\nOutput socket: Position\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Radius()\nRetrieve the radius at each point on curve or point cloud geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_radius\nOutput socket: Radius\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Rotation(rotation_euler=(0.0, 0.0, 0.0))\nProvide a rotation value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_euler\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SceneTime()\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_frame\nOutput socket: Frame\n\n\no_seconds\nOutput socket: Seconds\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Selection()\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_float\nOutput socket: Float\n\n\no_selection\nOutput socket: Boolean\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SelfObject()\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_self_object\nOutput socket: Self Object\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0)\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_cost\nInput socket: Edge Cost\n\n\ni_end_vertex\nInput socket: End Vertex\n\n\nname\n\n\n\nnode\n\n\n\no_next_vertex_index\nOutput socket: Next Vertex Index\n\n\no_total_cost\nOutput socket: Total Cost\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SpecialCharacters()\nOutput string characters that cannot be typed directly with the keyboard\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_line_break\nOutput socket: Line Break\n\n\no_tab\nOutput socket: Tab\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineLength()\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineParameter()\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineResolution()\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_resolution\nOutput socket: Resolution\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.String(string='')\nProvide a string value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.UVTangent(method='Exact', uv=None)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\nname\n\n\n\nnode\n\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Vector(vector=(0.0, 0.0, 0.0))\nProvide a vector value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.input.VertexNeighbors()\nRetrieve topology information relating to each vertex of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.VertexOfCorner(corner_index=0)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ViewportTransform()\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.VoxelIndex()\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_extent_x\nOutput socket: Extent X\n\n\no_extent_y\nOutput socket: Extent Y\n\n\no_extent_z\nOutput socket: Extent Z\n\n\no_is_tile\nOutput socket: Is Tile\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.input"
    ]
  },
  {
    "objectID": "reference/nodes.input.html#classes",
    "href": "reference/nodes.input.html#classes",
    "title": "nodes.input",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nActiveCamera\nRetrieve the scene’s active camera\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nBoolean\nProvide a True/False value that can be connected to other nodes in the tree\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollection\nOutput a single collection\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nColor\nOutput a color value chosen with the color picker widget\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nCursor3D\nThe scene’s 3D cursor location and rotation\n\n\nCurveHandlePositions\nRetrieve the position of each Bézier control point’s handles\n\n\nCurveOfPoint\nRetrieve the curve a control point is part of\n\n\nCurveTangent\nRetrieve the direction of curves at each control point\n\n\nCurveTilt\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\nEdgeAngle\nThe angle between the normals of connected manifold faces\n\n\nEdgeNeighbors\nRetrieve the number of faces that use each edge as one of their sides\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgeVertices\nRetrieve topology information relating to each edge of a mesh\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEndpointSelection\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\nFaceArea\nCalculate the surface area of a mesh’s faces\n\n\nFaceGroupBoundaries\nFind edges on the boundaries between groups of faces with the same ID value\n\n\nFaceNeighbors\nRetrieve topology information relating to each face of a mesh\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nID\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\nImage\nInput an image data-block\n\n\nImageInfo\nRetrieve information about an image\n\n\nImportCSV\nImport geometry from an CSV file\n\n\nImportOBJ\nImport geometry from an OBJ file\n\n\nImportPLY\nImport a point cloud from a PLY file\n\n\nImportSTL\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVDB\nImport volume data from a .vdb file\n\n\nIndex\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\nInstanceBounds\nCalculate position bounds of each instance’s geometry set\n\n\nInstanceRotation\nRetrieve the rotation of each instance in the geometry\n\n\nInstanceScale\nRetrieve the scale of each instance in the geometry\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInteger\nProvide an integer value that can be connected to other nodes in the tree\n\n\nIsEdgeSmooth\nRetrieve whether each edge is marked for smooth or split normals\n\n\nIsFacePlanar\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\nIsFaceSmooth\nRetrieve whether each face is marked for smooth or sharp normals\n\n\nIsSplineCyclic\nRetrieve whether each spline endpoint connects to the beginning\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nMaterial\nOutput a single material\n\n\nMaterialIndex\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\nMeshIsland\nRetrieve information about separate connected regions in a mesh\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nNamedAttribute\nRetrieve the data of a specified attribute\n\n\nNamedLayerSelection\nOutput a selection of a Grease Pencil layer\n\n\nNormal\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\nObject\nOutput a single object\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nOffsetPointInCurve\nOffset a control point index within its curve\n\n\nPointsOfCurve\nRetrieve a point index within a curve\n\n\nPosition\nRetrieve a vector indicating the location of each element\n\n\nRadius\nRetrieve the radius at each point on curve or point cloud geometry\n\n\nRotation\nProvide a rotation value that can be connected to other nodes in the tree\n\n\nSceneTime\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nShortestEdgePaths\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\nSpecialCharacters\nOutput string characters that cannot be typed directly with the keyboard\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplineResolution\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\nString\nProvide a string value that can be connected to other nodes in the tree\n\n\nUVTangent\nGenerate tangent directions based on a UV map\n\n\nVector\nProvide a vector value that can be connected to other nodes in the tree\n\n\nVertexNeighbors\nRetrieve topology information relating to each vertex of a mesh\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVoxelIndex\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nnodes.input.ActiveCamera()\nRetrieve the scene’s active camera\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_active_camera\nOutput socket: Active Camera\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ActiveElement(domain='POINT')\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\nname\n\n\n\nnode\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Active Element with operation ‘Edge’.\n\n\nface\nCreate Active Element with operation ‘Face’.\n\n\nlayer\nCreate Active Element with operation ‘Layer’.\n\n\npoint\nCreate Active Element with operation ‘Point’.\n\n\n\n\n\nnodes.input.ActiveElement.edge()\nCreate Active Element with operation ‘Edge’.\n\n\n\nnodes.input.ActiveElement.face()\nCreate Active Element with operation ‘Face’.\n\n\n\nnodes.input.ActiveElement.layer()\nCreate Active Element with operation ‘Layer’.\n\n\n\nnodes.input.ActiveElement.point()\nCreate Active Element with operation ‘Point’.\n\n\n\n\n\nnodes.input.Boolean(boolean=False)\nProvide a True/False value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nname\n\n\n\nnode\n\n\n\no_boolean\nOutput socket: Boolean\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CameraInfo(camera=None)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\nname\n\n\n\nnode\n\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Collection()\nOutput a single collection\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_collection\nOutput socket: Collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    *,\n    transform_space='ORIGINAL',\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntransform_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Color(value=(0.735, 0.735, 0.735, 1.0))\nOutput a color value chosen with the color picker widget\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\nvalue\n\n\n\n\n\n\n\n\nnodes.input.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CornersOfFace(face_index=0, weights=0.0, sort_index=0)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CornersOfVertex(vertex_index=0, weights=0.0, sort_index=0)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Cursor3D()\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveHandlePositions(relative=False)\nRetrieve the position of each Bézier control point’s handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_relative\nInput socket: Relative\n\n\nname\n\n\n\nnode\n\n\n\no_left\nOutput socket: Left\n\n\no_right\nOutput socket: Right\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveOfPoint(point_index=0)\nRetrieve the curve a control point is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_index\nInput socket: Point Index\n\n\nname\n\n\n\nnode\n\n\n\no_curve_index\nOutput socket: Curve Index\n\n\no_index_in_curve\nOutput socket: Index in Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveTangent()\nRetrieve the direction of curves at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.CurveTilt()\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_tilt\nOutput socket: Tilt\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeAngle()\nThe angle between the normals of connected manifold faces\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_signed_angle\nOutput socket: Signed Angle\n\n\no_unsigned_angle\nOutput socket: Unsigned Angle\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeNeighbors()\nRetrieve the number of faces that use each edge as one of their sides\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgePathsToSelection(start_vertices=True, next_vertex_index=-1)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgeVertices()\nRetrieve topology information relating to each edge of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_position_1\nOutput socket: Position 1\n\n\no_position_2\nOutput socket: Position 2\n\n\no_vertex_index_1\nOutput socket: Vertex Index 1\n\n\no_vertex_index_2\nOutput socket: Vertex Index 2\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesOfCorner(corner_index=0)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesOfVertex(vertex_index=0, weights=0.0, sort_index=0)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EdgesToFaceGroups(boundary_edges=True)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\nname\n\n\n\nnode\n\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.EndpointSelection(start_size=1, end_size=1)\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_size\nInput socket: End Size\n\n\ni_start_size\nInput socket: Start Size\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceArea()\nCalculate the surface area of a mesh’s faces\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_area\nOutput socket: Area\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceGroupBoundaries(face_set=0)\nFind edges on the boundaries between groups of faces with the same ID value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Group ID\n\n\nname\n\n\n\nnode\n\n\n\no_boundary_edges\nOutput socket: Boundary Edges\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceNeighbors()\nRetrieve topology information relating to each face of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceOfCorner(corner_index=0)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.FaceSet()\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ID()\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_id\nOutput socket: ID\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Image()\nInput an image data-block\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_image\nOutput socket: Image\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImageInfo(image=None, frame=0)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\nname\n\n\n\nnode\n\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportCSV(path='', delimiter=',')\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportOBJ(path='')\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportPLY(path='')\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportSTL(path='')\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportText(path='')\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ImportVDB(path='')\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Index()\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceBounds(use_radius=True)\nCalculate position bounds of each instance’s geometry set\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_use_radius\nInput socket: Use Radius\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceRotation()\nRetrieve the rotation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceScale()\nRetrieve the scale of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_scale\nOutput socket: Scale\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.InstanceTransform()\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Integer(integer=1)\nProvide an integer value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\ninteger\n\n\n\nname\n\n\n\nnode\n\n\n\no_integer\nOutput socket: Integer\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsEdgeSmooth()\nRetrieve whether each edge is marked for smooth or split normals\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_smooth\nOutput socket: Smooth\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsFacePlanar(threshold=0.01)\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_planar\nOutput socket: Planar\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsFaceSmooth()\nRetrieve whether each face is marked for smooth or sharp normals\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_smooth\nOutput socket: Smooth\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsSplineCyclic()\nRetrieve whether each spline endpoint connects to the beginning\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_cyclic\nOutput socket: Cyclic\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.IsViewport()\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Material()\nOutput a single material\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_material\nOutput socket: Material\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MaterialIndex()\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_material_index\nOutput socket: Material Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MeshIsland()\nRetrieve information about separate connected regions in a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_island_count\nOutput socket: Island Count\n\n\no_island_index\nOutput socket: Island Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.MousePosition()\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.NamedAttribute(name='', *, data_type='FLOAT')\nRetrieve the data of a specified attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_attribute\nOutput socket: Attribute\n\n\no_exists\nOutput socket: Exists\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Named Attribute with operation ‘Boolean’.\n\n\ncolor\nCreate Named Attribute with operation ‘Color’.\n\n\nfloat\nCreate Named Attribute with operation ‘Float’.\n\n\ninteger\nCreate Named Attribute with operation ‘Integer’.\n\n\nmatrix\nCreate Named Attribute with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Named Attribute with operation ‘Quaternion’.\n\n\nvector\nCreate Named Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.input.NamedAttribute.boolean(name='')\nCreate Named Attribute with operation ‘Boolean’.\n\n\n\nnodes.input.NamedAttribute.color(name='')\nCreate Named Attribute with operation ‘Color’.\n\n\n\nnodes.input.NamedAttribute.float(name='')\nCreate Named Attribute with operation ‘Float’.\n\n\n\nnodes.input.NamedAttribute.integer(name='')\nCreate Named Attribute with operation ‘Integer’.\n\n\n\nnodes.input.NamedAttribute.matrix(name='')\nCreate Named Attribute with operation ‘4x4 Matrix’.\n\n\n\nnodes.input.NamedAttribute.quaternion(name='')\nCreate Named Attribute with operation ‘Quaternion’.\n\n\n\nnodes.input.NamedAttribute.vector(name='')\nCreate Named Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.input.NamedLayerSelection(name='')\nOutput a selection of a Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Normal(legacy_corner_normals=False)\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\n\n\n\nName\nDescription\n\n\n\n\nlegacy_corner_normals\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_true_normal\nOutput socket: True Normal\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Object()\nOutput a single object\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_object\nOutput socket: Object\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ObjectInfo(\n    object=None,\n    as_instance=False,\n    *,\n    transform_space='ORIGINAL',\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\ntransform_space\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.OffsetCornerInFace(corner_index=0, offset=0)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\nname\n\n\n\nnode\n\n\n\no_corner_index\nOutput socket: Corner Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.OffsetPointInCurve(point_index=0, offset=0)\nOffset a control point index within its curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_index\nInput socket: Point Index\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid_offset\nOutput socket: Is Valid Offset\n\n\no_point_index\nOutput socket: Point Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0)\nRetrieve a point index within a curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\nname\n\n\n\nnode\n\n\n\no_point_index\nOutput socket: Point Index\n\n\no_total\nOutput socket: Total\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Position()\nRetrieve a vector indicating the location of each element\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_position\nOutput socket: Position\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Radius()\nRetrieve the radius at each point on curve or point cloud geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_radius\nOutput socket: Radius\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Rotation(rotation_euler=(0.0, 0.0, 0.0))\nProvide a rotation value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_rotation\nOutput socket: Rotation\n\n\nrotation_euler\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SceneTime()\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_frame\nOutput socket: Frame\n\n\no_seconds\nOutput socket: Seconds\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Selection()\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_float\nOutput socket: Float\n\n\no_selection\nOutput socket: Boolean\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SelfObject()\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_self_object\nOutput socket: Self Object\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0)\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_cost\nInput socket: Edge Cost\n\n\ni_end_vertex\nInput socket: End Vertex\n\n\nname\n\n\n\nnode\n\n\n\no_next_vertex_index\nOutput socket: Next Vertex Index\n\n\no_total_cost\nOutput socket: Total Cost\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SpecialCharacters()\nOutput string characters that cannot be typed directly with the keyboard\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_line_break\nOutput socket: Line Break\n\n\no_tab\nOutput socket: Tab\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineLength()\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineParameter()\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.SplineResolution()\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_resolution\nOutput socket: Resolution\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.String(string='')\nProvide a string value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.UVTangent(method='Exact', uv=None)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\nname\n\n\n\nnode\n\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.Vector(vector=(0.0, 0.0, 0.0))\nProvide a vector value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.input.VertexNeighbors()\nRetrieve topology information relating to each vertex of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.VertexOfCorner(corner_index=0)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\nname\n\n\n\nnode\n\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.ViewportTransform()\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.input.VoxelIndex()\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_extent_x\nOutput socket: Extent X\n\n\no_extent_y\nOutput socket: Extent Y\n\n\no_extent_z\nOutput socket: Extent Z\n\n\no_is_tile\nOutput socket: Is Tile\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.input"
    ]
  },
  {
    "objectID": "reference/nodes.vector.html",
    "href": "reference/nodes.vector.html",
    "title": "nodes.vector",
    "section": "",
    "text": "nodes.vector\n\n\n\n\n\nName\nDescription\n\n\n\n\nRadialTiling\nTransform Coordinate System for Radial Tiling\n\n\nVectorCurves\nMap input vector components with curves\n\n\nVectorMath\nPerform vector math operation\n\n\nVectorRotate\nRotate a vector around a pivot point (center)\n\n\n\n\n\nnodes.vector.RadialTiling(\n    vector=None,\n    sides=5.0,\n    roundness=0.0,\n    *,\n    normalize=False,\n)\nTransform Coordinate System for Radial Tiling\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_roundness\nInput socket: Roundness\n\n\ni_sides\nInput socket: Sides\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\nnormalize\n\n\n\no_segment_coordinates\nOutput socket: Segment Coordinates\n\n\no_segment_id\nOutput socket: Segment ID\n\n\no_segment_rotation\nOutput socket: Segment Rotation\n\n\no_segment_width\nOutput socket: Segment Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.vector.VectorCurves(fac=1.0, vector=None)\nMap input vector components with curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fac\nInput socket: Factor\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.vector.VectorMath(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n    scale=1.0,\n    *,\n    operation='ADD',\n)\nPerform vector math operation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\ni_vector_001\nInput socket: Vector\n\n\ni_vector_002\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\no_vector\nOutput socket: Vector\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Vector Math with operation ‘Absolute’.\n\n\nadd\nCreate Vector Math with operation ‘Add’.\n\n\nceil\nCreate Vector Math with operation ‘Ceil’.\n\n\ncosine\nCreate Vector Math with operation ‘Cosine’.\n\n\ncross_product\nCreate Vector Math with operation ‘Cross Product’.\n\n\ndistance\nCreate Vector Math with operation ‘Distance’.\n\n\ndivide\nCreate Vector Math with operation ‘Divide’.\n\n\ndot_product\nCreate Vector Math with operation ‘Dot Product’.\n\n\nfaceforward\nCreate Vector Math with operation ‘Faceforward’.\n\n\nfloor\nCreate Vector Math with operation ‘Floor’.\n\n\nfraction\nCreate Vector Math with operation ‘Fraction’.\n\n\nlength\nCreate Vector Math with operation ‘Length’.\n\n\nmaximum\nCreate Vector Math with operation ‘Maximum’.\n\n\nminimum\nCreate Vector Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Vector Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Vector Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Vector Math with operation ‘Multiply Add’.\n\n\nnormalize\nCreate Vector Math with operation ‘Normalize’.\n\n\npower\nCreate Vector Math with operation ‘Power’.\n\n\nproject\nCreate Vector Math with operation ‘Project’.\n\n\nreflect\nCreate Vector Math with operation ‘Reflect’.\n\n\nrefract\nCreate Vector Math with operation ‘Refract’.\n\n\nscale\nCreate Vector Math with operation ‘Scale’.\n\n\nsign\nCreate Vector Math with operation ‘Sign’.\n\n\nsine\nCreate Vector Math with operation ‘Sine’.\n\n\nsnap\nCreate Vector Math with operation ‘Snap’.\n\n\nsubtract\nCreate Vector Math with operation ‘Subtract’.\n\n\ntangent\nCreate Vector Math with operation ‘Tangent’.\n\n\nwrap\nCreate Vector Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.vector.VectorMath.absolute(vector=None)\nCreate Vector Math with operation ‘Absolute’.\n\n\n\nnodes.vector.VectorMath.add(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Add’.\n\n\n\nnodes.vector.VectorMath.ceil(vector=None)\nCreate Vector Math with operation ‘Ceil’.\n\n\n\nnodes.vector.VectorMath.cosine(vector=None)\nCreate Vector Math with operation ‘Cosine’.\n\n\n\nnodes.vector.VectorMath.cross_product(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Cross Product’.\n\n\n\nnodes.vector.VectorMath.distance(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Distance’.\n\n\n\nnodes.vector.VectorMath.divide(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Divide’.\n\n\n\nnodes.vector.VectorMath.dot_product(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Dot Product’.\n\n\n\nnodes.vector.VectorMath.faceforward(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n)\nCreate Vector Math with operation ‘Faceforward’.\n\n\n\nnodes.vector.VectorMath.floor(vector=None)\nCreate Vector Math with operation ‘Floor’.\n\n\n\nnodes.vector.VectorMath.fraction(vector=None)\nCreate Vector Math with operation ‘Fraction’.\n\n\n\nnodes.vector.VectorMath.length(vector=None)\nCreate Vector Math with operation ‘Length’.\n\n\n\nnodes.vector.VectorMath.maximum(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Maximum’.\n\n\n\nnodes.vector.VectorMath.minimum(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Minimum’.\n\n\n\nnodes.vector.VectorMath.modulo(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Modulo’.\n\n\n\nnodes.vector.VectorMath.multiply(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Multiply’.\n\n\n\nnodes.vector.VectorMath.multiply_add(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n)\nCreate Vector Math with operation ‘Multiply Add’.\n\n\n\nnodes.vector.VectorMath.normalize(vector=None)\nCreate Vector Math with operation ‘Normalize’.\n\n\n\nnodes.vector.VectorMath.power(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Power’.\n\n\n\nnodes.vector.VectorMath.project(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Project’.\n\n\n\nnodes.vector.VectorMath.reflect(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Reflect’.\n\n\n\nnodes.vector.VectorMath.refract(vector=None, vector_001=None, scale=1.0)\nCreate Vector Math with operation ‘Refract’.\n\n\n\nnodes.vector.VectorMath.scale(vector=None, scale=1.0)\nCreate Vector Math with operation ‘Scale’.\n\n\n\nnodes.vector.VectorMath.sign(vector=None)\nCreate Vector Math with operation ‘Sign’.\n\n\n\nnodes.vector.VectorMath.sine(vector=None)\nCreate Vector Math with operation ‘Sine’.\n\n\n\nnodes.vector.VectorMath.snap(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Snap’.\n\n\n\nnodes.vector.VectorMath.subtract(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Subtract’.\n\n\n\nnodes.vector.VectorMath.tangent(vector=None)\nCreate Vector Math with operation ‘Tangent’.\n\n\n\nnodes.vector.VectorMath.wrap(vector=None, vector_001=None, vector_002=None)\nCreate Vector Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.vector.VectorRotate(\n    vector=None,\n    center=None,\n    axis=None,\n    angle=0.0,\n    rotation=None,\n    *,\n    rotation_type='AXIS_ANGLE',\n    invert=False,\n)\nRotate a vector around a pivot point (center)\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\ninvert\n\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\nrotation_type\n\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.vector"
    ]
  },
  {
    "objectID": "reference/nodes.vector.html#classes",
    "href": "reference/nodes.vector.html#classes",
    "title": "nodes.vector",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nRadialTiling\nTransform Coordinate System for Radial Tiling\n\n\nVectorCurves\nMap input vector components with curves\n\n\nVectorMath\nPerform vector math operation\n\n\nVectorRotate\nRotate a vector around a pivot point (center)\n\n\n\n\n\nnodes.vector.RadialTiling(\n    vector=None,\n    sides=5.0,\n    roundness=0.0,\n    *,\n    normalize=False,\n)\nTransform Coordinate System for Radial Tiling\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_roundness\nInput socket: Roundness\n\n\ni_sides\nInput socket: Sides\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\nnormalize\n\n\n\no_segment_coordinates\nOutput socket: Segment Coordinates\n\n\no_segment_id\nOutput socket: Segment ID\n\n\no_segment_rotation\nOutput socket: Segment Rotation\n\n\no_segment_width\nOutput socket: Segment Width\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.vector.VectorCurves(fac=1.0, vector=None)\nMap input vector components with curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fac\nInput socket: Factor\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.vector.VectorMath(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n    scale=1.0,\n    *,\n    operation='ADD',\n)\nPerform vector math operation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\ni_vector_001\nInput socket: Vector\n\n\ni_vector_002\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\no_vector\nOutput socket: Vector\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Vector Math with operation ‘Absolute’.\n\n\nadd\nCreate Vector Math with operation ‘Add’.\n\n\nceil\nCreate Vector Math with operation ‘Ceil’.\n\n\ncosine\nCreate Vector Math with operation ‘Cosine’.\n\n\ncross_product\nCreate Vector Math with operation ‘Cross Product’.\n\n\ndistance\nCreate Vector Math with operation ‘Distance’.\n\n\ndivide\nCreate Vector Math with operation ‘Divide’.\n\n\ndot_product\nCreate Vector Math with operation ‘Dot Product’.\n\n\nfaceforward\nCreate Vector Math with operation ‘Faceforward’.\n\n\nfloor\nCreate Vector Math with operation ‘Floor’.\n\n\nfraction\nCreate Vector Math with operation ‘Fraction’.\n\n\nlength\nCreate Vector Math with operation ‘Length’.\n\n\nmaximum\nCreate Vector Math with operation ‘Maximum’.\n\n\nminimum\nCreate Vector Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Vector Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Vector Math with operation ‘Multiply’.\n\n\nmultiply_add\nCreate Vector Math with operation ‘Multiply Add’.\n\n\nnormalize\nCreate Vector Math with operation ‘Normalize’.\n\n\npower\nCreate Vector Math with operation ‘Power’.\n\n\nproject\nCreate Vector Math with operation ‘Project’.\n\n\nreflect\nCreate Vector Math with operation ‘Reflect’.\n\n\nrefract\nCreate Vector Math with operation ‘Refract’.\n\n\nscale\nCreate Vector Math with operation ‘Scale’.\n\n\nsign\nCreate Vector Math with operation ‘Sign’.\n\n\nsine\nCreate Vector Math with operation ‘Sine’.\n\n\nsnap\nCreate Vector Math with operation ‘Snap’.\n\n\nsubtract\nCreate Vector Math with operation ‘Subtract’.\n\n\ntangent\nCreate Vector Math with operation ‘Tangent’.\n\n\nwrap\nCreate Vector Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.vector.VectorMath.absolute(vector=None)\nCreate Vector Math with operation ‘Absolute’.\n\n\n\nnodes.vector.VectorMath.add(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Add’.\n\n\n\nnodes.vector.VectorMath.ceil(vector=None)\nCreate Vector Math with operation ‘Ceil’.\n\n\n\nnodes.vector.VectorMath.cosine(vector=None)\nCreate Vector Math with operation ‘Cosine’.\n\n\n\nnodes.vector.VectorMath.cross_product(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Cross Product’.\n\n\n\nnodes.vector.VectorMath.distance(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Distance’.\n\n\n\nnodes.vector.VectorMath.divide(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Divide’.\n\n\n\nnodes.vector.VectorMath.dot_product(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Dot Product’.\n\n\n\nnodes.vector.VectorMath.faceforward(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n)\nCreate Vector Math with operation ‘Faceforward’.\n\n\n\nnodes.vector.VectorMath.floor(vector=None)\nCreate Vector Math with operation ‘Floor’.\n\n\n\nnodes.vector.VectorMath.fraction(vector=None)\nCreate Vector Math with operation ‘Fraction’.\n\n\n\nnodes.vector.VectorMath.length(vector=None)\nCreate Vector Math with operation ‘Length’.\n\n\n\nnodes.vector.VectorMath.maximum(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Maximum’.\n\n\n\nnodes.vector.VectorMath.minimum(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Minimum’.\n\n\n\nnodes.vector.VectorMath.modulo(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Modulo’.\n\n\n\nnodes.vector.VectorMath.multiply(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Multiply’.\n\n\n\nnodes.vector.VectorMath.multiply_add(\n    vector=None,\n    vector_001=None,\n    vector_002=None,\n)\nCreate Vector Math with operation ‘Multiply Add’.\n\n\n\nnodes.vector.VectorMath.normalize(vector=None)\nCreate Vector Math with operation ‘Normalize’.\n\n\n\nnodes.vector.VectorMath.power(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Power’.\n\n\n\nnodes.vector.VectorMath.project(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Project’.\n\n\n\nnodes.vector.VectorMath.reflect(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Reflect’.\n\n\n\nnodes.vector.VectorMath.refract(vector=None, vector_001=None, scale=1.0)\nCreate Vector Math with operation ‘Refract’.\n\n\n\nnodes.vector.VectorMath.scale(vector=None, scale=1.0)\nCreate Vector Math with operation ‘Scale’.\n\n\n\nnodes.vector.VectorMath.sign(vector=None)\nCreate Vector Math with operation ‘Sign’.\n\n\n\nnodes.vector.VectorMath.sine(vector=None)\nCreate Vector Math with operation ‘Sine’.\n\n\n\nnodes.vector.VectorMath.snap(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Snap’.\n\n\n\nnodes.vector.VectorMath.subtract(vector=None, vector_001=None)\nCreate Vector Math with operation ‘Subtract’.\n\n\n\nnodes.vector.VectorMath.tangent(vector=None)\nCreate Vector Math with operation ‘Tangent’.\n\n\n\nnodes.vector.VectorMath.wrap(vector=None, vector_001=None, vector_002=None)\nCreate Vector Math with operation ‘Wrap’.\n\n\n\n\n\nnodes.vector.VectorRotate(\n    vector=None,\n    center=None,\n    axis=None,\n    angle=0.0,\n    rotation=None,\n    *,\n    rotation_type='AXIS_ANGLE',\n    invert=False,\n)\nRotate a vector around a pivot point (center)\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\ninvert\n\n\n\nname\n\n\n\nnode\n\n\n\no_vector\nOutput socket: Vector\n\n\nrotation_type\n\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.vector"
    ]
  },
  {
    "objectID": "reference/nodes.zone.html",
    "href": "reference/nodes.zone.html",
    "title": "nodes.zone",
    "section": "",
    "text": "nodes.zone\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseRepeatZone\n\n\n\nBaseSimulationZone\n\n\n\nBaseZone\n\n\n\nBaseZoneInput\nBase class for zone input nodes\n\n\nBaseZoneOutput\nBase class for zone output nodes\n\n\nForEachGeometryElementInput\nFor Each Geometry Element Input node\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nForEachGeometryElementZone\n\n\n\nRepeatInput\nRepeat Input node\n\n\nRepeatOutput\nRepeat Output node\n\n\nRepeatZone\nWrapper that supports both direct unpacking and iteration\n\n\nSimulationInput\nSimulation Input node\n\n\nSimulationOutput\nSimulation Output node\n\n\nSimulationZone\n\n\n\n\n\n\nnodes.zone.BaseRepeatZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseRepeatZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseSimulationZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseSimulationZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneInput()\nBase class for zone input nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneOutput()\nBase class for zone output nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementInput(geometry=None, selection=True)\nFor Each Geometry Element Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementOutput(domain='POINT', **kwargs)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nitems_generated\n\n\n\nname\n\n\n\nnode\n\n\n\no_generation\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\ncapture_generated\n\n\n\n\n\n\nnodes.zone.ForEachGeometryElementOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\nnodes.zone.ForEachGeometryElementOutput.capture_generated(value)\n\n\n\n\n\nnodes.zone.ForEachGeometryElementZone(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n)\n\n\n\n\n\nName\nDescription\n\n\n\n\nindex\n\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\nnodes.zone.RepeatInput(iterations=1)\nRepeat Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_iteration\nOutput socket: Iteration\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatOutput()\nRepeat Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatZone(iterations=1, *args, **kwargs)\nWrapper that supports both direct unpacking and iteration\n\n\n\n\n\nName\nDescription\n\n\n\n\ni\nInput socket: Skip simluation frame\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\nnodes.zone.SimulationInput()\nSimulation Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_delta_time\nOutput socket: Delta Time\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationOutput()\nSimulation Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_skip\nInput socket: Skip simluation frame\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationZone(*args, **kwargs)\n\n\n\n\n\nName\nDescription\n\n\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndelta_time\n\n\n\n\n\n\nnodes.zone.SimulationZone.delta_time()",
    "crumbs": [
      "Some functions",
      "nodes.zone"
    ]
  },
  {
    "objectID": "reference/nodes.zone.html#classes",
    "href": "reference/nodes.zone.html#classes",
    "title": "nodes.zone",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseRepeatZone\n\n\n\nBaseSimulationZone\n\n\n\nBaseZone\n\n\n\nBaseZoneInput\nBase class for zone input nodes\n\n\nBaseZoneOutput\nBase class for zone output nodes\n\n\nForEachGeometryElementInput\nFor Each Geometry Element Input node\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nForEachGeometryElementZone\n\n\n\nRepeatInput\nRepeat Input node\n\n\nRepeatOutput\nRepeat Output node\n\n\nRepeatZone\nWrapper that supports both direct unpacking and iteration\n\n\nSimulationInput\nSimulation Input node\n\n\nSimulationOutput\nSimulation Output node\n\n\nSimulationZone\n\n\n\n\n\n\nnodes.zone.BaseRepeatZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseRepeatZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseSimulationZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseSimulationZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZone()\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZone.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneInput()\nBase class for zone input nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneOutput()\nBase class for zone output nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\nReturn the items collection\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.BaseZoneOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementInput(geometry=None, selection=True)\nFor Each Geometry Element Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.ForEachGeometryElementOutput(domain='POINT', **kwargs)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nitems_generated\n\n\n\nname\n\n\n\nnode\n\n\n\no_generation\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\ncapture_generated\n\n\n\n\n\n\nnodes.zone.ForEachGeometryElementOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\nnodes.zone.ForEachGeometryElementOutput.capture_generated(value)\n\n\n\n\n\nnodes.zone.ForEachGeometryElementZone(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n)\n\n\n\n\n\nName\nDescription\n\n\n\n\nindex\n\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\nnodes.zone.RepeatInput(iterations=1)\nRepeat Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_iteration\nOutput socket: Iteration\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatOutput()\nRepeat Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.RepeatZone(iterations=1, *args, **kwargs)\nWrapper that supports both direct unpacking and iteration\n\n\n\n\n\nName\nDescription\n\n\n\n\ni\nInput socket: Skip simluation frame\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\nnodes.zone.SimulationInput()\nSimulation Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\no_delta_time\nOutput socket: Delta Time\n\n\noutput\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationInput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationOutput()\nSimulation Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_skip\nInput socket: Skip simluation frame\n\n\ninputs\nGet all input sockets based on items collection\n\n\nitems\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\nGet all output sockets based on items collection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationOutput.capture(value, domain='POINT')\nCapture something as an input to the simulation\n\n\n\n\n\nnodes.zone.SimulationZone(*args, **kwargs)\n\n\n\n\n\nName\nDescription\n\n\n\n\ninput\n\n\n\noutput\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndelta_time\n\n\n\n\n\n\nnodes.zone.SimulationZone.delta_time()",
    "crumbs": [
      "Some functions",
      "nodes.zone"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.input\n\n\n\nnodes.attribute\n\n\n\nnodes.color\n\n\n\nnodes.converter\n\n\n\nnodes.texture\n\n\n\nnodes.grid\n\n\n\nnodes.geometry\n\n\n\nnodes.attribute\n\n\n\nnodes.vector\n\n\n\nnodes.manual\n\n\n\nnodes.zone",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#some-functions",
    "href": "reference/index.html#some-functions",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.input\n\n\n\nnodes.attribute\n\n\n\nnodes.color\n\n\n\nnodes.converter\n\n\n\nnodes.texture\n\n\n\nnodes.grid\n\n\n\nnodes.geometry\n\n\n\nnodes.attribute\n\n\n\nnodes.vector\n\n\n\nnodes.manual\n\n\n\nnodes.zone",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nodebpy",
    "section": "",
    "text": "A package to help build node trees in blender more elegantly with python code."
  },
  {
    "objectID": "index.html#the-design-idea",
    "href": "index.html#the-design-idea",
    "title": "nodebpy",
    "section": "The Design Idea",
    "text": "The Design Idea\nOther projects have attempted similar but none quite handled the API how I felt it should be done. Notable existing projects are geometry-script, geonodes, NodeToPython.\nOther projects implement chaining of nodes mostly as dot methos of nodes to chain them (InstanceOnPoints().set_position()). This has the potential to crowd the API for individual nodes and easy chaining is instead approached via overriding the &gt;&gt; operator.\n\nChain Nodes with &gt;&gt;\nBy default the operator attempts to link the first output of the previous node with the first input of the next. You can override this behaviour by being explicit with the socket you are passing out (AccumulateField().o_total) or using the ... for the inputs into the next node. The dots can appear at multiple locations and each input will be linked to the previous node via the inferred or specified socket."
  },
  {
    "objectID": "reference/nodes.texture.html",
    "href": "reference/nodes.texture.html",
    "title": "nodes.texture",
    "section": "",
    "text": "nodes.texture\n\n\n\n\n\nName\nDescription\n\n\n\n\nBrickTexture\nGenerate a procedural texture producing bricks\n\n\nCheckerTexture\nGenerate a checkerboard texture\n\n\nGaborTexture\nGenerate Gabor noise\n\n\nGradientTexture\nGenerate interpolated color and intensity values based on the input vector\n\n\nImageTexture\nSample values from an image texture\n\n\nMagicTexture\nGenerate a psychedelic color texture\n\n\nNoiseTexture\nGenerate fractal Perlin noise\n\n\nVoronoiTexture\nGenerate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells\n\n\nWaveTexture\nGenerate procedural bands or rings with noise\n\n\nWhiteNoiseTexture\nCalculate a random value or color based on an input seed\n\n\n\n\n\nnodes.texture.BrickTexture(\n    vector=None,\n    color1=None,\n    color2=None,\n    mortar=None,\n    scale=5.0,\n    mortar_size=0.02,\n    mortar_smooth=0.1,\n    bias=0.0,\n    brick_width=0.5,\n    row_height=0.25,\n    *,\n    offset_frequency=2,\n    squash_frequency=2,\n    offset=0.5,\n    squash=1.0,\n)\nGenerate a procedural texture producing bricks\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bias\nInput socket: Bias\n\n\ni_brick_width\nInput socket: Brick Width\n\n\ni_color1\nInput socket: Color1\n\n\ni_color2\nInput socket: Color2\n\n\ni_mortar\nInput socket: Mortar\n\n\ni_mortar_size\nInput socket: Mortar Size\n\n\ni_mortar_smooth\nInput socket: Mortar Smooth\n\n\ni_row_height\nInput socket: Row Height\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\noffset\n\n\n\noffset_frequency\n\n\n\nsquash\n\n\n\nsquash_frequency\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.CheckerTexture(vector=None, color1=None, color2=None, scale=5.0)\nGenerate a checkerboard texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color1\nInput socket: Color1\n\n\ni_color2\nInput socket: Color2\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.GaborTexture(\n    vector=None,\n    scale=5.0,\n    frequency=2.0,\n    anisotropy=1.0,\n    orientation_2d=0.7854,\n    orientation_3d=None,\n    *,\n    gabor_type='2D',\n)\nGenerate Gabor noise\n\n\n\n\n\nName\nDescription\n\n\n\n\ngabor_type\n\n\n\ni_anisotropy\nInput socket: Anisotropy\n\n\ni_frequency\nInput socket: Frequency\n\n\ni_orientation_2d\nInput socket: Orientation\n\n\ni_orientation_3d\nInput socket: Orientation\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_intensity\nOutput socket: Intensity\n\n\no_phase\nOutput socket: Phase\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.GradientTexture(vector=None, *, gradient_type='LINEAR')\nGenerate interpolated color and intensity values based on the input vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ngradient_type\n\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.ImageTexture(\n    image=None,\n    vector=None,\n    frame=0,\n    *,\n    interpolation='Linear',\n    extension='REPEAT',\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\nextension\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\ninterpolation\n\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.MagicTexture(\n    vector=None,\n    scale=5.0,\n    distortion=1.0,\n    *,\n    turbulence_depth=0,\n)\nGenerate a psychedelic color texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\nturbulence_depth\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.NoiseTexture(\n    vector=None,\n    w=0.0,\n    scale=5.0,\n    detail=2.0,\n    roughness=0.5,\n    lacunarity=2.0,\n    offset=0.0,\n    gain=1.0,\n    distortion=0.0,\n    *,\n    noise_dimensions='3D',\n    noise_type='FBM',\n    normalize=False,\n)\nGenerate fractal Perlin noise\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_gain\nInput socket: Gain\n\n\ni_lacunarity\nInput socket: Lacunarity\n\n\ni_offset\nInput socket: Offset\n\n\ni_roughness\nInput socket: Roughness\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnoise_dimensions\n\n\n\nnoise_type\n\n\n\nnormalize\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.VoronoiTexture(\n    vector=None,\n    w=0.0,\n    scale=5.0,\n    detail=0.0,\n    roughness=0.5,\n    lacunarity=2.0,\n    smoothness=1.0,\n    exponent=0.5,\n    randomness=1.0,\n    *,\n    voronoi_dimensions='3D',\n    distance='EUCLIDEAN',\n    feature='F1',\n    normalize=False,\n)\nGenerate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells\n\n\n\n\n\nName\nDescription\n\n\n\n\ndistance\n\n\n\nfeature\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_exponent\nInput socket: Exponent\n\n\ni_lacunarity\nInput socket: Lacunarity\n\n\ni_randomness\nInput socket: Randomness\n\n\ni_roughness\nInput socket: Roughness\n\n\ni_scale\nInput socket: Scale\n\n\ni_smoothness\nInput socket: Smoothness\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnormalize\n\n\n\no_color\nOutput socket: Color\n\n\no_distance\nOutput socket: Distance\n\n\no_position\nOutput socket: Position\n\n\no_radius\nOutput socket: Radius\n\n\no_w\nOutput socket: W\n\n\ntree\n\n\n\ntype\n\n\n\nvoronoi_dimensions\n\n\n\n\n\n\n\n\nnodes.texture.WaveTexture(\n    vector=None,\n    scale=5.0,\n    distortion=0.0,\n    detail=2.0,\n    detail_scale=1.0,\n    detail_roughness=0.5,\n    phase_offset=0.0,\n    *,\n    wave_type='BANDS',\n    bands_direction='X',\n    rings_direction='X',\n    wave_profile='SIN',\n)\nGenerate procedural bands or rings with noise\n\n\n\n\n\nName\nDescription\n\n\n\n\nbands_direction\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_detail_roughness\nInput socket: Detail Roughness\n\n\ni_detail_scale\nInput socket: Detail Scale\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_phase_offset\nInput socket: Phase Offset\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\nrings_direction\n\n\n\ntree\n\n\n\ntype\n\n\n\nwave_profile\n\n\n\nwave_type\n\n\n\n\n\n\n\n\nnodes.texture.WhiteNoiseTexture(vector=None, w=0.0, *, noise_dimensions='3D')\nCalculate a random value or color based on an input seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnoise_dimensions\n\n\n\no_color\nOutput socket: Color\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.texture"
    ]
  },
  {
    "objectID": "reference/nodes.texture.html#classes",
    "href": "reference/nodes.texture.html#classes",
    "title": "nodes.texture",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBrickTexture\nGenerate a procedural texture producing bricks\n\n\nCheckerTexture\nGenerate a checkerboard texture\n\n\nGaborTexture\nGenerate Gabor noise\n\n\nGradientTexture\nGenerate interpolated color and intensity values based on the input vector\n\n\nImageTexture\nSample values from an image texture\n\n\nMagicTexture\nGenerate a psychedelic color texture\n\n\nNoiseTexture\nGenerate fractal Perlin noise\n\n\nVoronoiTexture\nGenerate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells\n\n\nWaveTexture\nGenerate procedural bands or rings with noise\n\n\nWhiteNoiseTexture\nCalculate a random value or color based on an input seed\n\n\n\n\n\nnodes.texture.BrickTexture(\n    vector=None,\n    color1=None,\n    color2=None,\n    mortar=None,\n    scale=5.0,\n    mortar_size=0.02,\n    mortar_smooth=0.1,\n    bias=0.0,\n    brick_width=0.5,\n    row_height=0.25,\n    *,\n    offset_frequency=2,\n    squash_frequency=2,\n    offset=0.5,\n    squash=1.0,\n)\nGenerate a procedural texture producing bricks\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bias\nInput socket: Bias\n\n\ni_brick_width\nInput socket: Brick Width\n\n\ni_color1\nInput socket: Color1\n\n\ni_color2\nInput socket: Color2\n\n\ni_mortar\nInput socket: Mortar\n\n\ni_mortar_size\nInput socket: Mortar Size\n\n\ni_mortar_smooth\nInput socket: Mortar Smooth\n\n\ni_row_height\nInput socket: Row Height\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\noffset\n\n\n\noffset_frequency\n\n\n\nsquash\n\n\n\nsquash_frequency\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.CheckerTexture(vector=None, color1=None, color2=None, scale=5.0)\nGenerate a checkerboard texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color1\nInput socket: Color1\n\n\ni_color2\nInput socket: Color2\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.GaborTexture(\n    vector=None,\n    scale=5.0,\n    frequency=2.0,\n    anisotropy=1.0,\n    orientation_2d=0.7854,\n    orientation_3d=None,\n    *,\n    gabor_type='2D',\n)\nGenerate Gabor noise\n\n\n\n\n\nName\nDescription\n\n\n\n\ngabor_type\n\n\n\ni_anisotropy\nInput socket: Anisotropy\n\n\ni_frequency\nInput socket: Frequency\n\n\ni_orientation_2d\nInput socket: Orientation\n\n\ni_orientation_3d\nInput socket: Orientation\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_intensity\nOutput socket: Intensity\n\n\no_phase\nOutput socket: Phase\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.GradientTexture(vector=None, *, gradient_type='LINEAR')\nGenerate interpolated color and intensity values based on the input vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ngradient_type\n\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.ImageTexture(\n    image=None,\n    vector=None,\n    frame=0,\n    *,\n    interpolation='Linear',\n    extension='REPEAT',\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\nextension\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\ninterpolation\n\n\n\nname\n\n\n\nnode\n\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.MagicTexture(\n    vector=None,\n    scale=5.0,\n    distortion=1.0,\n    *,\n    turbulence_depth=0,\n)\nGenerate a psychedelic color texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\nturbulence_depth\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.NoiseTexture(\n    vector=None,\n    w=0.0,\n    scale=5.0,\n    detail=2.0,\n    roughness=0.5,\n    lacunarity=2.0,\n    offset=0.0,\n    gain=1.0,\n    distortion=0.0,\n    *,\n    noise_dimensions='3D',\n    noise_type='FBM',\n    normalize=False,\n)\nGenerate fractal Perlin noise\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_gain\nInput socket: Gain\n\n\ni_lacunarity\nInput socket: Lacunarity\n\n\ni_offset\nInput socket: Offset\n\n\ni_roughness\nInput socket: Roughness\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnoise_dimensions\n\n\n\nnoise_type\n\n\n\nnormalize\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.texture.VoronoiTexture(\n    vector=None,\n    w=0.0,\n    scale=5.0,\n    detail=0.0,\n    roughness=0.5,\n    lacunarity=2.0,\n    smoothness=1.0,\n    exponent=0.5,\n    randomness=1.0,\n    *,\n    voronoi_dimensions='3D',\n    distance='EUCLIDEAN',\n    feature='F1',\n    normalize=False,\n)\nGenerate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells\n\n\n\n\n\nName\nDescription\n\n\n\n\ndistance\n\n\n\nfeature\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_exponent\nInput socket: Exponent\n\n\ni_lacunarity\nInput socket: Lacunarity\n\n\ni_randomness\nInput socket: Randomness\n\n\ni_roughness\nInput socket: Roughness\n\n\ni_scale\nInput socket: Scale\n\n\ni_smoothness\nInput socket: Smoothness\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnormalize\n\n\n\no_color\nOutput socket: Color\n\n\no_distance\nOutput socket: Distance\n\n\no_position\nOutput socket: Position\n\n\no_radius\nOutput socket: Radius\n\n\no_w\nOutput socket: W\n\n\ntree\n\n\n\ntype\n\n\n\nvoronoi_dimensions\n\n\n\n\n\n\n\n\nnodes.texture.WaveTexture(\n    vector=None,\n    scale=5.0,\n    distortion=0.0,\n    detail=2.0,\n    detail_scale=1.0,\n    detail_roughness=0.5,\n    phase_offset=0.0,\n    *,\n    wave_type='BANDS',\n    bands_direction='X',\n    rings_direction='X',\n    wave_profile='SIN',\n)\nGenerate procedural bands or rings with noise\n\n\n\n\n\nName\nDescription\n\n\n\n\nbands_direction\n\n\n\ni_detail\nInput socket: Detail\n\n\ni_detail_roughness\nInput socket: Detail Roughness\n\n\ni_detail_scale\nInput socket: Detail Scale\n\n\ni_distortion\nInput socket: Distortion\n\n\ni_phase_offset\nInput socket: Phase Offset\n\n\ni_scale\nInput socket: Scale\n\n\ni_vector\nInput socket: Vector\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\no_fac\nOutput socket: Factor\n\n\nrings_direction\n\n\n\ntree\n\n\n\ntype\n\n\n\nwave_profile\n\n\n\nwave_type\n\n\n\n\n\n\n\n\nnodes.texture.WhiteNoiseTexture(vector=None, w=0.0, *, noise_dimensions='3D')\nCalculate a random value or color based on an input seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_vector\nInput socket: Vector\n\n\ni_w\nInput socket: W\n\n\nname\n\n\n\nnode\n\n\n\nnoise_dimensions\n\n\n\no_color\nOutput socket: Color\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.texture"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html",
    "href": "reference/nodes.geometry.html",
    "title": "nodes.geometry",
    "section": "",
    "text": "nodes.geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\nArc\nGenerate a poly spline arc\n\n\nBezierSegment\nGenerate a 2D Bézier spline from the given control points and handles\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCone\nGenerate a cone mesh\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCube\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\nCurveCircle\nGenerate a poly spline circle\n\n\nCurveLength\nRetrieve the length of all splines added together\n\n\nCurveLine\nGenerate a poly spline line with two points\n\n\nCurveToMesh\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\nCurveToPoints\nGenerate a point cloud by sampling positions along curves\n\n\nCurvesToGreasePencil\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\nCylinder\nGenerate a cylinder mesh\n\n\nDeformCurvesOnSurface\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDualMesh\nConvert Faces into vertices and vertices into faces\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToCurves\nOutput curves following paths across mesh edges\n\n\nExtrudeMesh\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\nFillCurve\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\nFilletCurve\nRound corners by generating circular arcs on each control point\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGreasePencilToCurves\nConvert Grease Pencil layers into curve instances\n\n\nGrid\nGenerate a planar mesh on the XY plane\n\n\nIcoSphere\nGenerate a spherical mesh that consists of equally sized triangles\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nInterpolateCurves\nGenerate new curves on points by interpolating between existing curves\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMeshBoolean\nCut, subtract, or join multiple mesh inputs\n\n\nMeshCircle\nGenerate a circular ring of edges\n\n\nMeshLine\nGenerate vertices in a line and connect them with edges\n\n\nMeshToCurve\nGenerate a curve from a mesh\n\n\nMeshToPoints\nGenerate a point cloud from a mesh’s vertices\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToCurves\nSplit all points to curve by its group ID and reorder by weight\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nQuadraticBezier\nGenerate a poly spline in a parabola shape with control points positions\n\n\nQuadrilateral\nGenerate a polygon with four points\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nResampleCurve\nGenerate a poly spline for each input spline\n\n\nReverseCurve\nChange the direction of curves by swapping their start and end data\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSampleCurve\nRetrieve data from a point on a curve at a certain distance from its start\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUVSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetCurveNormal\nSet the evaluation mode for curve normals\n\n\nSetCurveRadius\nSet the radius of the curve at each control point\n\n\nSetCurveTilt\nSet the tilt angle at each curve control point\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetHandlePositions\nSet the positions for the handles of Bézier curves\n\n\nSetID\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetMeshNormal\nStore a normal vector for each mesh element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSetSplineType\nChange the type of curves\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSpiral\nGenerate a poly spline in a spiral shape\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStar\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\nStringToCurves\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\nSubdivideCurve\nDividing each curve segment into a specified number of pieces\n\n\nSubdivideMesh\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nTrimCurve\nShorten curves by removing portions at the start or end\n\n\nUVSphere\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nnodes.geometry.Arc(\n    resolution=16,\n    start=None,\n    middle=None,\n    end=None,\n    radius=1.0,\n    start_angle=0.0,\n    sweep_angle=5.4978,\n    offset_angle=0.0,\n    connect_center=False,\n    invert_arc=False,\n    *,\n    mode='RADIUS',\n)\nGenerate a poly spline arc\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_connect_center\nInput socket: Connect Center\n\n\ni_end\nInput socket: End\n\n\ni_invert_arc\nInput socket: Invert Arc\n\n\ni_middle\nInput socket: Middle\n\n\ni_offset_angle\nInput socket: Offset Angle\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_angle\nInput socket: Start Angle\n\n\ni_sweep_angle\nInput socket: Sweep Angle\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_center\nOutput socket: Center\n\n\no_curve\nOutput socket: Curve\n\n\no_normal\nOutput socket: Normal\n\n\no_radius\nOutput socket: Radius\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.BezierSegment(\n    resolution=16,\n    start=None,\n    start_handle=None,\n    end_handle=None,\n    end=None,\n    *,\n    mode='POSITION',\n)\nGenerate a 2D Bézier spline from the given control points and handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_end_handle\nInput socket: End Handle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_handle\nInput socket: Start Handle\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\nname\n\n\n\nnode\n\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cone(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius_top=0.0,\n    radius_bottom=1.0,\n    depth=2.0,\n    *,\n    fill_type='NGON',\n)\nGenerate a cone mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius_bottom\nInput socket: Radius Bottom\n\n\ni_radius_top\nInput socket: Radius Top\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cube(size=None, vertices_x=2, vertices_y=2, vertices_z=2)\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size\nInput socket: Size\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\ni_vertices_z\nInput socket: Vertices Z\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveCircle(\n    resolution=32,\n    point_1=None,\n    point_2=None,\n    point_3=None,\n    radius=1.0,\n    *,\n    mode='RADIUS',\n)\nGenerate a poly spline circle\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_1\nInput socket: Point 1\n\n\ni_point_2\nInput socket: Point 2\n\n\ni_point_3\nInput socket: Point 3\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_center\nOutput socket: Center\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveLength(curve=None)\nRetrieve the length of all splines added together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveLine(\n    start=None,\n    end=None,\n    direction=None,\n    length=1.0,\n    *,\n    mode='POINTS',\n)\nGenerate a poly spline line with two points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_end\nInput socket: End\n\n\ni_length\nInput socket: Length\n\n\ni_start\nInput socket: Start\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveToMesh(\n    curve=None,\n    profile_curve=None,\n    scale=1.0,\n    fill_caps=False,\n)\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_fill_caps\nInput socket: Fill Caps\n\n\ni_profile_curve\nInput socket: Profile Curve\n\n\ni_scale\nInput socket: Scale\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveToPoints(curve=None, count=10, length=0.1, *, mode='COUNT')\nGenerate a point cloud by sampling positions along curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurvesToGreasePencil(\n    curves=None,\n    selection=True,\n    instances_as_layers=True,\n)\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\ni_instances_as_layers\nInput socket: Instances as Layers\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cylinder(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius=1.0,\n    depth=2.0,\n    *,\n    fill_type='NGON',\n)\nGenerate a cylinder mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius\nInput socket: Radius\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DeformCurvesOnSurface(curves=None)\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    *,\n    mode='ALL',\n    domain='POINT',\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Delete Geometry with operation ‘Edge’.\n\n\nface\nCreate Delete Geometry with operation ‘Face’.\n\n\ninstance\nCreate Delete Geometry with operation ‘Instance’.\n\n\nlayer\nCreate Delete Geometry with operation ‘Layer’.\n\n\npoint\nCreate Delete Geometry with operation ‘Point’.\n\n\nspline\nCreate Delete Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DeleteGeometry.edge(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Edge’.\n\n\n\nnodes.geometry.DeleteGeometry.face(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Face’.\n\n\n\nnodes.geometry.DeleteGeometry.instance(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Instance’.\n\n\n\nnodes.geometry.DeleteGeometry.layer(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Layer’.\n\n\n\nnodes.geometry.DeleteGeometry.point(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Point’.\n\n\n\nnodes.geometry.DeleteGeometry.spline(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    distance_min=0.0,\n    density_max=10.0,\n    density=10.0,\n    density_factor=1.0,\n    seed=0,\n    *,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ndistribute_method\n\n\n\ni_density\nInput socket: Density\n\n\ni_density_factor\nInput socket: Density Factor\n\n\ni_density_max\nInput socket: Density Max\n\n\ni_distance_min\nInput socket: Distance Min\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\nuse_legacy_normal\n\n\n\n\n\n\n\n\nnodes.geometry.DualMesh(mesh=None, keep_boundaries=False)\nConvert Faces into vertices and vertices into faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_keep_boundaries\nInput socket: Keep Boundaries\n\n\ni_mesh\nInput socket: Mesh\n\n\nname\n\n\n\nnode\n\n\n\no_dual_mesh\nOutput socket: Dual Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    *,\n    domain='POINT',\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Duplicate Elements with operation ‘Edge’.\n\n\nface\nCreate Duplicate Elements with operation ‘Face’.\n\n\ninstance\nCreate Duplicate Elements with operation ‘Instance’.\n\n\nlayer\nCreate Duplicate Elements with operation ‘Layer’.\n\n\npoint\nCreate Duplicate Elements with operation ‘Point’.\n\n\nspline\nCreate Duplicate Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DuplicateElements.edge(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.DuplicateElements.face(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Face’.\n\n\n\nnodes.geometry.DuplicateElements.instance(\n    geometry=None,\n    selection=True,\n    amount=1,\n)\nCreate Duplicate Elements with operation ‘Instance’.\n\n\n\nnodes.geometry.DuplicateElements.layer(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Layer’.\n\n\n\nnodes.geometry.DuplicateElements.point(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Point’.\n\n\n\nnodes.geometry.DuplicateElements.spline(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.EdgePathsToCurves(\n    mesh=None,\n    start_vertices=True,\n    next_vertex_index=-1,\n)\nOutput curves following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ExtrudeMesh(\n    mesh=None,\n    selection=True,\n    offset=None,\n    offset_scale=1.0,\n    individual=True,\n    *,\n    mode='FACES',\n)\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_individual\nInput socket: Individual\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_offset\nInput socket: Offset\n\n\ni_offset_scale\nInput socket: Offset Scale\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FillCurve(curve=None, group_id=0, mode='Triangles')\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mode\nInput socket: Mode\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FilletCurve(\n    curve=None,\n    radius=0.25,\n    limit_radius=False,\n    mode='Bézier',\n    count=1,\n)\nRound corners by generating circular arcs on each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_limit_radius\nInput socket: Limit Radius\n\n\ni_mode\nInput socket: Mode\n\n\ni_radius\nInput socket: Radius\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=None,\n    sample_group_id=0,\n    *,\n    target_element='FACES',\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_source_position\nInput socket: Sample Position\n\n\ni_target\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\ntarget_element\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.GreasePencilToCurves(\n    grease_pencil=None,\n    selection=True,\n    layers_as_instances=True,\n)\nConvert Grease Pencil layers into curve instances\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_layers_as_instances\nInput socket: Layers as Instances\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3)\nGenerate a planar mesh on the XY plane\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size_x\nInput socket: Size X\n\n\ni_size_y\nInput socket: Size Y\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.IcoSphere(radius=1.0, subdivisions=1)\nGenerate a spherical mesh that consists of equally sized triangles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_subdivisions\nInput socket: Subdivisions\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=None,\n    scale=None,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=None,\n    radius=0.05,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InterpolateCurves(\n    guide_curves=None,\n    guide_up=None,\n    guide_group_id=0,\n    points=None,\n    point_up=None,\n    point_group_id=0,\n    max_neighbors=4,\n)\nGenerate new curves on points by interpolating between existing curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_guide_curves\nInput socket: Guide Curves\n\n\ni_guide_group_id\nInput socket: Guide Group ID\n\n\ni_guide_up\nInput socket: Guide Up\n\n\ni_max_neighbors\nInput socket: Max Neighbors\n\n\ni_point_group_id\nInput socket: Point Group ID\n\n\ni_point_up\nInput socket: Point Up\n\n\ni_points\nInput socket: Points\n\n\nname\n\n\n\nnode\n\n\n\no_closest_index\nOutput socket: Closest Index\n\n\no_closest_weight\nOutput socket: Closest Weight\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.001,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    group_id=0,\n    *,\n    mode='MERGE_BY_NAME',\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshBoolean(\n    mesh_1=None,\n    mesh_2=None,\n    self_intersection=False,\n    hole_tolerant=False,\n    *,\n    operation='DIFFERENCE',\n    solver='FLOAT',\n)\nCut, subtract, or join multiple mesh inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_hole_tolerant\nInput socket: Hole Tolerant\n\n\ni_mesh_1\nInput socket: Mesh 1\n\n\ni_mesh_2\nInput socket: Mesh 2\n\n\ni_self_intersection\nInput socket: Self Intersection\n\n\nname\n\n\n\nnode\n\n\n\no_intersecting_edges\nOutput socket: Intersecting Edges\n\n\no_mesh\nOutput socket: Mesh\n\n\noperation\n\n\n\nsolver\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate Mesh Boolean with operation ‘Difference’.\n\n\nintersect\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\nunion\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.MeshBoolean.difference(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.MeshBoolean.intersect(mesh_2=None)\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.MeshBoolean.union(mesh_2=None)\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.MeshCircle(vertices=32, radius=1.0, *, fill_type='NONE')\nGenerate a circular ring of edges\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshLine(\n    count=10,\n    resolution=1.0,\n    start_location=None,\n    offset=None,\n    *,\n    mode='OFFSET',\n    count_mode='TOTAL',\n)\nGenerate vertices in a line and connect them with edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ncount_mode\n\n\n\ni_count\nInput socket: Count\n\n\ni_offset\nInput socket: Offset\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start_location\nInput socket: Start Location\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshToCurve(mesh=None, selection=True, *, mode='EDGES')\nGenerate a curve from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshToPoints(\n    mesh=None,\n    selection=True,\n    position=None,\n    radius=0.05,\n    *,\n    mode='VERTICES',\n)\nGenerate a point cloud from a mesh’s vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Points(count=1, position=None, radius=0.1)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.PointsToCurves(points=None, curve_group_id=0, weight=0.0)\nSplit all points to curve by its group ID and reorder by weight\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_group_id\nInput socket: Curve Group ID\n\n\ni_points\nInput socket: Points\n\n\ni_weight\nInput socket: Weight\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.QuadraticBezier(resolution=16, start=None, middle=None, end=None)\nGenerate a poly spline in a parabola shape with control points positions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_middle\nInput socket: Middle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Quadrilateral(\n    width=2.0,\n    height=2.0,\n    bottom_width=4.0,\n    top_width=2.0,\n    offset=1.0,\n    bottom_height=3.0,\n    top_height=1.0,\n    point_1=None,\n    point_2=None,\n    point_3=None,\n    point_4=None,\n    *,\n    mode='RECTANGLE',\n)\nGenerate a polygon with four points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bottom_height\nInput socket: Bottom Height\n\n\ni_bottom_width\nInput socket: Bottom Width\n\n\ni_height\nInput socket: Height\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_1\nInput socket: Point 1\n\n\ni_point_2\nInput socket: Point 2\n\n\ni_point_3\nInput socket: Point 3\n\n\ni_point_4\nInput socket: Point 4\n\n\ni_top_height\nInput socket: Top Height\n\n\ni_top_width\nInput socket: Top Width\n\n\ni_width\nInput socket: Width\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n    *,\n    data_type='FLOAT',\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Raycast with operation ‘Boolean’.\n\n\ncolor\nCreate Raycast with operation ‘Color’.\n\n\nfloat\nCreate Raycast with operation ‘Float’.\n\n\ninteger\nCreate Raycast with operation ‘Integer’.\n\n\nmatrix\nCreate Raycast with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Raycast with operation ‘Quaternion’.\n\n\nvector\nCreate Raycast with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.Raycast.boolean(\n    target_geometry=None,\n    attribute=False,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Boolean’.\n\n\n\nnodes.geometry.Raycast.color(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Color’.\n\n\n\nnodes.geometry.Raycast.float(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Float’.\n\n\n\nnodes.geometry.Raycast.integer(\n    target_geometry=None,\n    attribute=0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Integer’.\n\n\n\nnodes.geometry.Raycast.matrix(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.Raycast.quaternion(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Quaternion’.\n\n\n\nnodes.geometry.Raycast.vector(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ResampleCurve(\n    curve=None,\n    selection=True,\n    mode='Count',\n    count=10,\n    length=0.1,\n    *,\n    keep_last_segment=False,\n)\nGenerate a poly spline for each input spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\nkeep_last_segment\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ReverseCurve(curve=None, selection=True)\nChange the direction of curves by swapping their start and end data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=None,\n    pivot_point=None,\n    local_space=True,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SampleCurve(\n    curves=None,\n    value=0.0,\n    factor=0.0,\n    length=0.0,\n    curve_index=0,\n    *,\n    mode='FACTOR',\n    use_all_curves=False,\n    data_type='FLOAT',\n)\nRetrieve data from a point on a curve at a certain distance from its start\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_curves\nInput socket: Curves\n\n\ni_factor\nInput socket: Factor\n\n\ni_length\nInput socket: Length\n\n\ni_value\nInput socket: Value\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_position\nOutput socket: Position\n\n\no_tangent\nOutput socket: Tangent\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\nuse_all_curves\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Curve with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Curve with operation ‘Color’.\n\n\nfloat\nCreate Sample Curve with operation ‘Float’.\n\n\ninteger\nCreate Sample Curve with operation ‘Integer’.\n\n\nmatrix\nCreate Sample Curve with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample Curve with operation ‘Quaternion’.\n\n\nvector\nCreate Sample Curve with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleCurve.boolean(\n    curves=None,\n    value=False,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleCurve.color(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Color’.\n\n\n\nnodes.geometry.SampleCurve.float(\n    curves=None,\n    value=0.0,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Float’.\n\n\n\nnodes.geometry.SampleCurve.integer(\n    curves=None,\n    value=0,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleCurve.matrix(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleCurve.quaternion(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleCurve.vector(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Index with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Index with operation ‘Color’.\n\n\nedge\nCreate Sample Index with operation ‘Edge’.\n\n\nface\nCreate Sample Index with operation ‘Face’.\n\n\nface_corner\nCreate Sample Index with operation ‘Face Corner’.\n\n\nfloat\nCreate Sample Index with operation ‘Float’.\n\n\ninstance\nCreate Sample Index with operation ‘Instance’.\n\n\ninteger\nCreate Sample Index with operation ‘Integer’.\n\n\nlayer\nCreate Sample Index with operation ‘Layer’.\n\n\nmatrix\nCreate Sample Index with operation ‘4x4 Matrix’.\n\n\npoint\nCreate Sample Index with operation ‘Point’.\n\n\nquaternion\nCreate Sample Index with operation ‘Quaternion’.\n\n\nspline\nCreate Sample Index with operation ‘Spline’.\n\n\nvector\nCreate Sample Index with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleIndex.boolean(geometry=None, value=False, index=0)\nCreate Sample Index with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleIndex.color(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Color’.\n\n\n\nnodes.geometry.SampleIndex.edge(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Edge’.\n\n\n\nnodes.geometry.SampleIndex.face(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Face’.\n\n\n\nnodes.geometry.SampleIndex.face_corner(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SampleIndex.float(geometry=None, value=0.0, index=0)\nCreate Sample Index with operation ‘Float’.\n\n\n\nnodes.geometry.SampleIndex.instance(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Instance’.\n\n\n\nnodes.geometry.SampleIndex.integer(geometry=None, value=0, index=0)\nCreate Sample Index with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleIndex.layer(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Layer’.\n\n\n\nnodes.geometry.SampleIndex.matrix(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleIndex.point(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Point’.\n\n\n\nnodes.geometry.SampleIndex.quaternion(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleIndex.spline(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Spline’.\n\n\n\nnodes.geometry.SampleIndex.vector(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=None,\n    *,\n    domain='POINT',\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Sample Nearest with operation ‘Edge’.\n\n\nface\nCreate Sample Nearest with operation ‘Face’.\n\n\nface_corner\nCreate Sample Nearest with operation ‘Face Corner’.\n\n\npoint\nCreate Sample Nearest with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SampleNearest.edge(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Edge’.\n\n\n\nnodes.geometry.SampleNearest.face(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Face’.\n\n\n\nnodes.geometry.SampleNearest.face_corner(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SampleNearest.point(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n    *,\n    data_type='FLOAT',\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Nearest Surface with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Nearest Surface with operation ‘Color’.\n\n\nfloat\nCreate Sample Nearest Surface with operation ‘Float’.\n\n\ninteger\nCreate Sample Nearest Surface with operation ‘Integer’.\n\n\nmatrix\nCreate Sample Nearest Surface with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample Nearest Surface with operation ‘Quaternion’.\n\n\nvector\nCreate Sample Nearest Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleNearestSurface.boolean(\n    mesh=None,\n    value=False,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleNearestSurface.color(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Color’.\n\n\n\nnodes.geometry.SampleNearestSurface.float(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Float’.\n\n\n\nnodes.geometry.SampleNearestSurface.integer(\n    mesh=None,\n    value=0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleNearestSurface.matrix(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleNearestSurface.quaternion(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleNearestSurface.vector(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleUVSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=None,\n    sample_uv=None,\n    *,\n    data_type='FLOAT',\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_source_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample UV Surface with operation ‘Boolean’.\n\n\ncolor\nCreate Sample UV Surface with operation ‘Color’.\n\n\nfloat\nCreate Sample UV Surface with operation ‘Float’.\n\n\ninteger\nCreate Sample UV Surface with operation ‘Integer’.\n\n\nmatrix\nCreate Sample UV Surface with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample UV Surface with operation ‘Quaternion’.\n\n\nvector\nCreate Sample UV Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleUVSurface.boolean(\n    mesh=None,\n    value=False,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleUVSurface.color(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Color’.\n\n\n\nnodes.geometry.SampleUVSurface.float(\n    mesh=None,\n    value=0.0,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Float’.\n\n\n\nnodes.geometry.SampleUVSurface.integer(\n    mesh=None,\n    value=0,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleUVSurface.matrix(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleUVSurface.quaternion(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleUVSurface.vector(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n    axis=None,\n    *,\n    domain='FACE',\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Scale Elements with operation ‘Edge’.\n\n\nface\nCreate Scale Elements with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.ScaleElements.edge(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n)\nCreate Scale Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.ScaleElements.face(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n)\nCreate Scale Elements with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=None,\n    center=None,\n    local_space=True,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Separate Geometry with operation ‘Edge’.\n\n\nface\nCreate Separate Geometry with operation ‘Face’.\n\n\ninstance\nCreate Separate Geometry with operation ‘Instance’.\n\n\nlayer\nCreate Separate Geometry with operation ‘Layer’.\n\n\npoint\nCreate Separate Geometry with operation ‘Point’.\n\n\nspline\nCreate Separate Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SeparateGeometry.edge(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Edge’.\n\n\n\nnodes.geometry.SeparateGeometry.face(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Face’.\n\n\n\nnodes.geometry.SeparateGeometry.instance(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Instance’.\n\n\n\nnodes.geometry.SeparateGeometry.layer(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Layer’.\n\n\n\nnodes.geometry.SeparateGeometry.point(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Point’.\n\n\n\nnodes.geometry.SeparateGeometry.spline(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetCurveNormal(\n    curve=None,\n    selection=True,\n    mode='Minimum Twist',\n    normal=None,\n)\nSet the evaluation mode for curve normals\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_mode\nInput socket: Mode\n\n\ni_normal\nInput socket: Normal\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetCurveRadius(curve=None, selection=True, radius=0.005)\nSet the radius of the curve at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetCurveTilt(curve=None, selection=True, tilt=0.0)\nSet the tilt angle at each curve control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\ni_tilt\nInput socket: Tilt\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='')\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=None,\n    opacity=1.0,\n    *,\n    mode='STROKE',\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(grease_pencil=None, *, depth_order='2D')\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ndepth_order\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetHandlePositions(\n    curve=None,\n    selection=True,\n    position=None,\n    offset=None,\n    *,\n    mode='LEFT',\n)\nSet the positions for the handles of Bézier curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetID(geometry=None, selection=True, id=0)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(geometry=None, selection=True, material=None)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(geometry=None, selection=True, material_index=0)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMeshNormal(\n    mesh=None,\n    remove_custom=True,\n    edge_sharpness=False,\n    face_sharpness=False,\n    *,\n    mode='SHARPNESS',\n    domain='POINT',\n)\nStore a normal vector for each mesh element\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_edge_sharpness\nInput socket: Edge Sharpness\n\n\ni_face_sharpness\nInput socket: Face Sharpness\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_remove_custom\nInput socket: Remove Custom\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nface\nCreate Set Mesh Normal with operation ‘Face’.\n\n\nface_corner\nCreate Set Mesh Normal with operation ‘Face Corner’.\n\n\npoint\nCreate Set Mesh Normal with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SetMeshNormal.face(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Face’.\n\n\n\nnodes.geometry.SetMeshNormal.face_corner(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SetMeshNormal.point(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SetPointRadius(points=None, selection=True, radius=0.05)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=None,\n    offset=None,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n    selection_type='BOOLEAN',\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\nselection_type\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Set Selection with operation ‘Edge’.\n\n\nface\nCreate Set Selection with operation ‘Face’.\n\n\npoint\nCreate Set Selection with operation ‘Point’.\n\n\nspline\nCreate Set Selection with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetSelection.edge(geometry=None, selection=True)\nCreate Set Selection with operation ‘Edge’.\n\n\n\nnodes.geometry.SetSelection.face(geometry=None, selection=True)\nCreate Set Selection with operation ‘Face’.\n\n\n\nnodes.geometry.SetSelection.point(geometry=None, selection=True)\nCreate Set Selection with operation ‘Point’.\n\n\n\nnodes.geometry.SetSelection.spline(geometry=None, selection=True)\nCreate Set Selection with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    *,\n    domain='FACE',\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Set Shade Smooth with operation ‘Edge’.\n\n\nface\nCreate Set Shade Smooth with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.SetShadeSmooth.edge(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n)\nCreate Set Shade Smooth with operation ‘Edge’.\n\n\n\nnodes.geometry.SetShadeSmooth.face(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n)\nCreate Set Shade Smooth with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(geometry=None, selection=True, cyclic=False)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_geometry\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(geometry=None, selection=True, resolution=12)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSplineType(curve=None, selection=True, *, spline_type='POLY')\nChange the type of curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\nspline_type\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    *,\n    domain='POINT',\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Sort Elements with operation ‘Edge’.\n\n\nface\nCreate Sort Elements with operation ‘Face’.\n\n\ninstance\nCreate Sort Elements with operation ‘Instance’.\n\n\npoint\nCreate Sort Elements with operation ‘Point’.\n\n\nspline\nCreate Sort Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SortElements.edge(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.SortElements.face(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Face’.\n\n\n\nnodes.geometry.SortElements.instance(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Instance’.\n\n\n\nnodes.geometry.SortElements.point(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Point’.\n\n\n\nnodes.geometry.SortElements.spline(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.Spiral(\n    resolution=32,\n    rotations=2.0,\n    start_radius=1.0,\n    end_radius=2.0,\n    height=2.0,\n    reverse=False,\n)\nGenerate a poly spline in a spiral shape\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_radius\nInput socket: End Radius\n\n\ni_height\nInput socket: Height\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_reverse\nInput socket: Reverse\n\n\ni_rotations\nInput socket: Rotations\n\n\ni_start_radius\nInput socket: Start Radius\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    *,\n    domain='POINT',\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Split to Instances with operation ‘Edge’.\n\n\nface\nCreate Split to Instances with operation ‘Face’.\n\n\ninstance\nCreate Split to Instances with operation ‘Instance’.\n\n\nlayer\nCreate Split to Instances with operation ‘Layer’.\n\n\npoint\nCreate Split to Instances with operation ‘Point’.\n\n\nspline\nCreate Split to Instances with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SplitToInstances.edge(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Edge’.\n\n\n\nnodes.geometry.SplitToInstances.face(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Face’.\n\n\n\nnodes.geometry.SplitToInstances.instance(\n    geometry=None,\n    selection=True,\n    group_id=0,\n)\nCreate Split to Instances with operation ‘Instance’.\n\n\n\nnodes.geometry.SplitToInstances.layer(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Layer’.\n\n\n\nnodes.geometry.SplitToInstances.point(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Point’.\n\n\n\nnodes.geometry.SplitToInstances.spline(\n    geometry=None,\n    selection=True,\n    group_id=0,\n)\nCreate Split to Instances with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.Star(points=8, inner_radius=1.0, outer_radius=2.0, twist=0.0)\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_inner_radius\nInput socket: Inner Radius\n\n\ni_outer_radius\nInput socket: Outer Radius\n\n\ni_points\nInput socket: Points\n\n\ni_twist\nInput socket: Twist\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\no_outer_points\nOutput socket: Outer Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.StringToCurves(\n    string='',\n    size=1.0,\n    character_spacing=1.0,\n    word_spacing=1.0,\n    line_spacing=1.0,\n    text_box_width=0.0,\n    text_box_height=0.0,\n    *,\n    overflow='OVERFLOW',\n    align_x='LEFT',\n    align_y='TOP_BASELINE',\n    pivot_mode='BOTTOM_LEFT',\n)\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\n\n\n\nName\nDescription\n\n\n\n\nalign_x\n\n\n\nalign_y\n\n\n\ni_character_spacing\nInput socket: Character Spacing\n\n\ni_line_spacing\nInput socket: Line Spacing\n\n\ni_size\nInput socket: Size\n\n\ni_string\nInput socket: String\n\n\ni_text_box_height\nInput socket: Text Box Height\n\n\ni_text_box_width\nInput socket: Text Box Width\n\n\ni_word_spacing\nInput socket: Word Spacing\n\n\nname\n\n\n\nnode\n\n\n\no_curve_instances\nOutput socket: Curve Instances\n\n\no_line\nOutput socket: Line\n\n\no_pivot_point\nOutput socket: Pivot Point\n\n\no_remainder\nOutput socket: Remainder\n\n\noverflow\n\n\n\npivot_mode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivideCurve(curve=None, cuts=1)\nDividing each curve segment into a specified number of pieces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cuts\nInput socket: Cuts\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivideMesh(mesh=None, level=1)\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_level\nInput socket: Level\n\n\ni_mesh\nInput socket: Mesh\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=None,\n    rotation=None,\n    scale=None,\n    transform=None,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=None,\n    local_space=True,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TrimCurve(\n    curve=None,\n    selection=True,\n    start=0.0,\n    end=1.0,\n    start_001=0.0,\n    end_001=1.0,\n    *,\n    mode='FACTOR',\n)\nShorten curves by removing portions at the start or end\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_end\nInput socket: End\n\n\ni_end_001\nInput socket: End\n\n\ni_selection\nInput socket: Selection\n\n\ni_start\nInput socket: Start\n\n\ni_start_001\nInput socket: Start\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.UVSphere(segments=32, rings=16, radius=1.0)\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_rings\nInput socket: Rings\n\n\ni_segments\nInput socket: Segments\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html#classes",
    "href": "reference/nodes.geometry.html#classes",
    "title": "nodes.geometry",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArc\nGenerate a poly spline arc\n\n\nBezierSegment\nGenerate a 2D Bézier spline from the given control points and handles\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCone\nGenerate a cone mesh\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCube\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\nCurveCircle\nGenerate a poly spline circle\n\n\nCurveLength\nRetrieve the length of all splines added together\n\n\nCurveLine\nGenerate a poly spline line with two points\n\n\nCurveToMesh\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\nCurveToPoints\nGenerate a point cloud by sampling positions along curves\n\n\nCurvesToGreasePencil\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\nCylinder\nGenerate a cylinder mesh\n\n\nDeformCurvesOnSurface\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDualMesh\nConvert Faces into vertices and vertices into faces\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToCurves\nOutput curves following paths across mesh edges\n\n\nExtrudeMesh\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\nFillCurve\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\nFilletCurve\nRound corners by generating circular arcs on each control point\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGreasePencilToCurves\nConvert Grease Pencil layers into curve instances\n\n\nGrid\nGenerate a planar mesh on the XY plane\n\n\nIcoSphere\nGenerate a spherical mesh that consists of equally sized triangles\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nInterpolateCurves\nGenerate new curves on points by interpolating between existing curves\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMeshBoolean\nCut, subtract, or join multiple mesh inputs\n\n\nMeshCircle\nGenerate a circular ring of edges\n\n\nMeshLine\nGenerate vertices in a line and connect them with edges\n\n\nMeshToCurve\nGenerate a curve from a mesh\n\n\nMeshToPoints\nGenerate a point cloud from a mesh’s vertices\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToCurves\nSplit all points to curve by its group ID and reorder by weight\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nQuadraticBezier\nGenerate a poly spline in a parabola shape with control points positions\n\n\nQuadrilateral\nGenerate a polygon with four points\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nResampleCurve\nGenerate a poly spline for each input spline\n\n\nReverseCurve\nChange the direction of curves by swapping their start and end data\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSampleCurve\nRetrieve data from a point on a curve at a certain distance from its start\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUVSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetCurveNormal\nSet the evaluation mode for curve normals\n\n\nSetCurveRadius\nSet the radius of the curve at each control point\n\n\nSetCurveTilt\nSet the tilt angle at each curve control point\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetHandlePositions\nSet the positions for the handles of Bézier curves\n\n\nSetID\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetMeshNormal\nStore a normal vector for each mesh element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSetSplineType\nChange the type of curves\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSpiral\nGenerate a poly spline in a spiral shape\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStar\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\nStringToCurves\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\nSubdivideCurve\nDividing each curve segment into a specified number of pieces\n\n\nSubdivideMesh\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nTrimCurve\nShorten curves by removing portions at the start or end\n\n\nUVSphere\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nnodes.geometry.Arc(\n    resolution=16,\n    start=None,\n    middle=None,\n    end=None,\n    radius=1.0,\n    start_angle=0.0,\n    sweep_angle=5.4978,\n    offset_angle=0.0,\n    connect_center=False,\n    invert_arc=False,\n    *,\n    mode='RADIUS',\n)\nGenerate a poly spline arc\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_connect_center\nInput socket: Connect Center\n\n\ni_end\nInput socket: End\n\n\ni_invert_arc\nInput socket: Invert Arc\n\n\ni_middle\nInput socket: Middle\n\n\ni_offset_angle\nInput socket: Offset Angle\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_angle\nInput socket: Start Angle\n\n\ni_sweep_angle\nInput socket: Sweep Angle\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_center\nOutput socket: Center\n\n\no_curve\nOutput socket: Curve\n\n\no_normal\nOutput socket: Normal\n\n\no_radius\nOutput socket: Radius\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.BezierSegment(\n    resolution=16,\n    start=None,\n    start_handle=None,\n    end_handle=None,\n    end=None,\n    *,\n    mode='POSITION',\n)\nGenerate a 2D Bézier spline from the given control points and handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_end_handle\nInput socket: End Handle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_handle\nInput socket: Start Handle\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\nname\n\n\n\nnode\n\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cone(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius_top=0.0,\n    radius_bottom=1.0,\n    depth=2.0,\n    *,\n    fill_type='NGON',\n)\nGenerate a cone mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius_bottom\nInput socket: Radius Bottom\n\n\ni_radius_top\nInput socket: Radius Top\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cube(size=None, vertices_x=2, vertices_y=2, vertices_z=2)\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size\nInput socket: Size\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\ni_vertices_z\nInput socket: Vertices Z\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveCircle(\n    resolution=32,\n    point_1=None,\n    point_2=None,\n    point_3=None,\n    radius=1.0,\n    *,\n    mode='RADIUS',\n)\nGenerate a poly spline circle\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_1\nInput socket: Point 1\n\n\ni_point_2\nInput socket: Point 2\n\n\ni_point_3\nInput socket: Point 3\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_center\nOutput socket: Center\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveLength(curve=None)\nRetrieve the length of all splines added together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\nname\n\n\n\nnode\n\n\n\no_length\nOutput socket: Length\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveLine(\n    start=None,\n    end=None,\n    direction=None,\n    length=1.0,\n    *,\n    mode='POINTS',\n)\nGenerate a poly spline line with two points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_end\nInput socket: End\n\n\ni_length\nInput socket: Length\n\n\ni_start\nInput socket: Start\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveToMesh(\n    curve=None,\n    profile_curve=None,\n    scale=1.0,\n    fill_caps=False,\n)\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_fill_caps\nInput socket: Fill Caps\n\n\ni_profile_curve\nInput socket: Profile Curve\n\n\ni_scale\nInput socket: Scale\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurveToPoints(curve=None, count=10, length=0.1, *, mode='COUNT')\nGenerate a point cloud by sampling positions along curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\no_tangent\nOutput socket: Tangent\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.CurvesToGreasePencil(\n    curves=None,\n    selection=True,\n    instances_as_layers=True,\n)\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\ni_instances_as_layers\nInput socket: Instances as Layers\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Cylinder(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius=1.0,\n    depth=2.0,\n    *,\n    fill_type='NGON',\n)\nGenerate a cylinder mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius\nInput socket: Radius\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DeformCurvesOnSurface(curves=None)\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    *,\n    mode='ALL',\n    domain='POINT',\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Delete Geometry with operation ‘Edge’.\n\n\nface\nCreate Delete Geometry with operation ‘Face’.\n\n\ninstance\nCreate Delete Geometry with operation ‘Instance’.\n\n\nlayer\nCreate Delete Geometry with operation ‘Layer’.\n\n\npoint\nCreate Delete Geometry with operation ‘Point’.\n\n\nspline\nCreate Delete Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DeleteGeometry.edge(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Edge’.\n\n\n\nnodes.geometry.DeleteGeometry.face(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Face’.\n\n\n\nnodes.geometry.DeleteGeometry.instance(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Instance’.\n\n\n\nnodes.geometry.DeleteGeometry.layer(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Layer’.\n\n\n\nnodes.geometry.DeleteGeometry.point(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Point’.\n\n\n\nnodes.geometry.DeleteGeometry.spline(geometry=None, selection=True)\nCreate Delete Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    distance_min=0.0,\n    density_max=10.0,\n    density=10.0,\n    density_factor=1.0,\n    seed=0,\n    *,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ndistribute_method\n\n\n\ni_density\nInput socket: Density\n\n\ni_density_factor\nInput socket: Density Factor\n\n\ni_density_max\nInput socket: Density Max\n\n\ni_distance_min\nInput socket: Distance Min\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\ntree\n\n\n\ntype\n\n\n\nuse_legacy_normal\n\n\n\n\n\n\n\n\nnodes.geometry.DualMesh(mesh=None, keep_boundaries=False)\nConvert Faces into vertices and vertices into faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_keep_boundaries\nInput socket: Keep Boundaries\n\n\ni_mesh\nInput socket: Mesh\n\n\nname\n\n\n\nnode\n\n\n\no_dual_mesh\nOutput socket: Dual Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    *,\n    domain='POINT',\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Duplicate Elements with operation ‘Edge’.\n\n\nface\nCreate Duplicate Elements with operation ‘Face’.\n\n\ninstance\nCreate Duplicate Elements with operation ‘Instance’.\n\n\nlayer\nCreate Duplicate Elements with operation ‘Layer’.\n\n\npoint\nCreate Duplicate Elements with operation ‘Point’.\n\n\nspline\nCreate Duplicate Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.DuplicateElements.edge(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.DuplicateElements.face(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Face’.\n\n\n\nnodes.geometry.DuplicateElements.instance(\n    geometry=None,\n    selection=True,\n    amount=1,\n)\nCreate Duplicate Elements with operation ‘Instance’.\n\n\n\nnodes.geometry.DuplicateElements.layer(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Layer’.\n\n\n\nnodes.geometry.DuplicateElements.point(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Point’.\n\n\n\nnodes.geometry.DuplicateElements.spline(geometry=None, selection=True, amount=1)\nCreate Duplicate Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.EdgePathsToCurves(\n    mesh=None,\n    start_vertices=True,\n    next_vertex_index=-1,\n)\nOutput curves following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ExtrudeMesh(\n    mesh=None,\n    selection=True,\n    offset=None,\n    offset_scale=1.0,\n    individual=True,\n    *,\n    mode='FACES',\n)\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_individual\nInput socket: Individual\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_offset\nInput socket: Offset\n\n\ni_offset_scale\nInput socket: Offset Scale\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FillCurve(curve=None, group_id=0, mode='Triangles')\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mode\nInput socket: Mode\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FilletCurve(\n    curve=None,\n    radius=0.25,\n    limit_radius=False,\n    mode='Bézier',\n    count=1,\n)\nRound corners by generating circular arcs on each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_limit_radius\nInput socket: Limit Radius\n\n\ni_mode\nInput socket: Mode\n\n\ni_radius\nInput socket: Radius\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=None,\n    sample_group_id=0,\n    *,\n    target_element='FACES',\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_source_position\nInput socket: Sample Position\n\n\ni_target\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\ntarget_element\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.GreasePencilToCurves(\n    grease_pencil=None,\n    selection=True,\n    layers_as_instances=True,\n)\nConvert Grease Pencil layers into curve instances\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_layers_as_instances\nInput socket: Layers as Instances\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3)\nGenerate a planar mesh on the XY plane\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size_x\nInput socket: Size X\n\n\ni_size_y\nInput socket: Size Y\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.IcoSphere(radius=1.0, subdivisions=1)\nGenerate a spherical mesh that consists of equally sized triangles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_subdivisions\nInput socket: Subdivisions\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=None,\n    scale=None,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=None,\n    radius=0.05,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.InterpolateCurves(\n    guide_curves=None,\n    guide_up=None,\n    guide_group_id=0,\n    points=None,\n    point_up=None,\n    point_group_id=0,\n    max_neighbors=4,\n)\nGenerate new curves on points by interpolating between existing curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_guide_curves\nInput socket: Guide Curves\n\n\ni_guide_group_id\nInput socket: Guide Group ID\n\n\ni_guide_up\nInput socket: Guide Up\n\n\ni_max_neighbors\nInput socket: Max Neighbors\n\n\ni_point_group_id\nInput socket: Point Group ID\n\n\ni_point_up\nInput socket: Point Up\n\n\ni_points\nInput socket: Points\n\n\nname\n\n\n\nnode\n\n\n\no_closest_index\nOutput socket: Closest Index\n\n\no_closest_weight\nOutput socket: Closest Weight\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.001,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    group_id=0,\n    *,\n    mode='MERGE_BY_NAME',\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshBoolean(\n    mesh_1=None,\n    mesh_2=None,\n    self_intersection=False,\n    hole_tolerant=False,\n    *,\n    operation='DIFFERENCE',\n    solver='FLOAT',\n)\nCut, subtract, or join multiple mesh inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_hole_tolerant\nInput socket: Hole Tolerant\n\n\ni_mesh_1\nInput socket: Mesh 1\n\n\ni_mesh_2\nInput socket: Mesh 2\n\n\ni_self_intersection\nInput socket: Self Intersection\n\n\nname\n\n\n\nnode\n\n\n\no_intersecting_edges\nOutput socket: Intersecting Edges\n\n\no_mesh\nOutput socket: Mesh\n\n\noperation\n\n\n\nsolver\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate Mesh Boolean with operation ‘Difference’.\n\n\nintersect\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\nunion\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.MeshBoolean.difference(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.MeshBoolean.intersect(mesh_2=None)\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.MeshBoolean.union(mesh_2=None)\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.MeshCircle(vertices=32, radius=1.0, *, fill_type='NONE')\nGenerate a circular ring of edges\n\n\n\n\n\nName\nDescription\n\n\n\n\nfill_type\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_vertices\nInput socket: Vertices\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshLine(\n    count=10,\n    resolution=1.0,\n    start_location=None,\n    offset=None,\n    *,\n    mode='OFFSET',\n    count_mode='TOTAL',\n)\nGenerate vertices in a line and connect them with edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ncount_mode\n\n\n\ni_count\nInput socket: Count\n\n\ni_offset\nInput socket: Offset\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start_location\nInput socket: Start Location\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshToCurve(mesh=None, selection=True, *, mode='EDGES')\nGenerate a curve from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.MeshToPoints(\n    mesh=None,\n    selection=True,\n    position=None,\n    radius=0.05,\n    *,\n    mode='VERTICES',\n)\nGenerate a point cloud from a mesh’s vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Points(count=1, position=None, radius=0.1)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.PointsToCurves(points=None, curve_group_id=0, weight=0.0)\nSplit all points to curve by its group ID and reorder by weight\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_group_id\nInput socket: Curve Group ID\n\n\ni_points\nInput socket: Points\n\n\ni_weight\nInput socket: Weight\n\n\nname\n\n\n\nnode\n\n\n\no_curves\nOutput socket: Curves\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.QuadraticBezier(resolution=16, start=None, middle=None, end=None)\nGenerate a poly spline in a parabola shape with control points positions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_middle\nInput socket: Middle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Quadrilateral(\n    width=2.0,\n    height=2.0,\n    bottom_width=4.0,\n    top_width=2.0,\n    offset=1.0,\n    bottom_height=3.0,\n    top_height=1.0,\n    point_1=None,\n    point_2=None,\n    point_3=None,\n    point_4=None,\n    *,\n    mode='RECTANGLE',\n)\nGenerate a polygon with four points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_bottom_height\nInput socket: Bottom Height\n\n\ni_bottom_width\nInput socket: Bottom Width\n\n\ni_height\nInput socket: Height\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_1\nInput socket: Point 1\n\n\ni_point_2\nInput socket: Point 2\n\n\ni_point_3\nInput socket: Point 3\n\n\ni_point_4\nInput socket: Point 4\n\n\ni_top_height\nInput socket: Top Height\n\n\ni_top_width\nInput socket: Top Width\n\n\ni_width\nInput socket: Width\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n    *,\n    data_type='FLOAT',\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Raycast with operation ‘Boolean’.\n\n\ncolor\nCreate Raycast with operation ‘Color’.\n\n\nfloat\nCreate Raycast with operation ‘Float’.\n\n\ninteger\nCreate Raycast with operation ‘Integer’.\n\n\nmatrix\nCreate Raycast with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Raycast with operation ‘Quaternion’.\n\n\nvector\nCreate Raycast with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.Raycast.boolean(\n    target_geometry=None,\n    attribute=False,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Boolean’.\n\n\n\nnodes.geometry.Raycast.color(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Color’.\n\n\n\nnodes.geometry.Raycast.float(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Float’.\n\n\n\nnodes.geometry.Raycast.integer(\n    target_geometry=None,\n    attribute=0,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Integer’.\n\n\n\nnodes.geometry.Raycast.matrix(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.Raycast.quaternion(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Quaternion’.\n\n\n\nnodes.geometry.Raycast.vector(\n    target_geometry=None,\n    attribute=None,\n    interpolation='Interpolated',\n    source_position=None,\n    ray_direction=None,\n    ray_length=100.0,\n)\nCreate Raycast with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ResampleCurve(\n    curve=None,\n    selection=True,\n    mode='Count',\n    count=10,\n    length=0.1,\n    *,\n    keep_last_segment=False,\n)\nGenerate a poly spline for each input spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\nkeep_last_segment\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.ReverseCurve(curve=None, selection=True)\nChange the direction of curves by swapping their start and end data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=None,\n    pivot_point=None,\n    local_space=True,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SampleCurve(\n    curves=None,\n    value=0.0,\n    factor=0.0,\n    length=0.0,\n    curve_index=0,\n    *,\n    mode='FACTOR',\n    use_all_curves=False,\n    data_type='FLOAT',\n)\nRetrieve data from a point on a curve at a certain distance from its start\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_curves\nInput socket: Curves\n\n\ni_factor\nInput socket: Factor\n\n\ni_length\nInput socket: Length\n\n\ni_value\nInput socket: Value\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_normal\nOutput socket: Normal\n\n\no_position\nOutput socket: Position\n\n\no_tangent\nOutput socket: Tangent\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\nuse_all_curves\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Curve with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Curve with operation ‘Color’.\n\n\nfloat\nCreate Sample Curve with operation ‘Float’.\n\n\ninteger\nCreate Sample Curve with operation ‘Integer’.\n\n\nmatrix\nCreate Sample Curve with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample Curve with operation ‘Quaternion’.\n\n\nvector\nCreate Sample Curve with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleCurve.boolean(\n    curves=None,\n    value=False,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleCurve.color(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Color’.\n\n\n\nnodes.geometry.SampleCurve.float(\n    curves=None,\n    value=0.0,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Float’.\n\n\n\nnodes.geometry.SampleCurve.integer(\n    curves=None,\n    value=0,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleCurve.matrix(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleCurve.quaternion(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleCurve.vector(\n    curves=None,\n    value=None,\n    length=0.0,\n    curve_index=0,\n)\nCreate Sample Curve with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\nclamp\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Index with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Index with operation ‘Color’.\n\n\nedge\nCreate Sample Index with operation ‘Edge’.\n\n\nface\nCreate Sample Index with operation ‘Face’.\n\n\nface_corner\nCreate Sample Index with operation ‘Face Corner’.\n\n\nfloat\nCreate Sample Index with operation ‘Float’.\n\n\ninstance\nCreate Sample Index with operation ‘Instance’.\n\n\ninteger\nCreate Sample Index with operation ‘Integer’.\n\n\nlayer\nCreate Sample Index with operation ‘Layer’.\n\n\nmatrix\nCreate Sample Index with operation ‘4x4 Matrix’.\n\n\npoint\nCreate Sample Index with operation ‘Point’.\n\n\nquaternion\nCreate Sample Index with operation ‘Quaternion’.\n\n\nspline\nCreate Sample Index with operation ‘Spline’.\n\n\nvector\nCreate Sample Index with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleIndex.boolean(geometry=None, value=False, index=0)\nCreate Sample Index with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleIndex.color(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Color’.\n\n\n\nnodes.geometry.SampleIndex.edge(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Edge’.\n\n\n\nnodes.geometry.SampleIndex.face(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Face’.\n\n\n\nnodes.geometry.SampleIndex.face_corner(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SampleIndex.float(geometry=None, value=0.0, index=0)\nCreate Sample Index with operation ‘Float’.\n\n\n\nnodes.geometry.SampleIndex.instance(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Instance’.\n\n\n\nnodes.geometry.SampleIndex.integer(geometry=None, value=0, index=0)\nCreate Sample Index with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleIndex.layer(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Layer’.\n\n\n\nnodes.geometry.SampleIndex.matrix(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleIndex.point(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Point’.\n\n\n\nnodes.geometry.SampleIndex.quaternion(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleIndex.spline(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Spline’.\n\n\n\nnodes.geometry.SampleIndex.vector(geometry=None, value=None, index=0)\nCreate Sample Index with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=None,\n    *,\n    domain='POINT',\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\nname\n\n\n\nnode\n\n\n\no_index\nOutput socket: Index\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Sample Nearest with operation ‘Edge’.\n\n\nface\nCreate Sample Nearest with operation ‘Face’.\n\n\nface_corner\nCreate Sample Nearest with operation ‘Face Corner’.\n\n\npoint\nCreate Sample Nearest with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SampleNearest.edge(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Edge’.\n\n\n\nnodes.geometry.SampleNearest.face(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Face’.\n\n\n\nnodes.geometry.SampleNearest.face_corner(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SampleNearest.point(geometry=None, sample_position=None)\nCreate Sample Nearest with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n    *,\n    data_type='FLOAT',\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Nearest Surface with operation ‘Boolean’.\n\n\ncolor\nCreate Sample Nearest Surface with operation ‘Color’.\n\n\nfloat\nCreate Sample Nearest Surface with operation ‘Float’.\n\n\ninteger\nCreate Sample Nearest Surface with operation ‘Integer’.\n\n\nmatrix\nCreate Sample Nearest Surface with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample Nearest Surface with operation ‘Quaternion’.\n\n\nvector\nCreate Sample Nearest Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleNearestSurface.boolean(\n    mesh=None,\n    value=False,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleNearestSurface.color(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Color’.\n\n\n\nnodes.geometry.SampleNearestSurface.float(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Float’.\n\n\n\nnodes.geometry.SampleNearestSurface.integer(\n    mesh=None,\n    value=0,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleNearestSurface.matrix(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleNearestSurface.quaternion(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleNearestSurface.vector(\n    mesh=None,\n    value=None,\n    group_id=0,\n    sample_position=None,\n    sample_group_id=0,\n)\nCreate Sample Nearest Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleUVSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=None,\n    sample_uv=None,\n    *,\n    data_type='FLOAT',\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_source_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample UV Surface with operation ‘Boolean’.\n\n\ncolor\nCreate Sample UV Surface with operation ‘Color’.\n\n\nfloat\nCreate Sample UV Surface with operation ‘Float’.\n\n\ninteger\nCreate Sample UV Surface with operation ‘Integer’.\n\n\nmatrix\nCreate Sample UV Surface with operation ‘4x4 Matrix’.\n\n\nquaternion\nCreate Sample UV Surface with operation ‘Quaternion’.\n\n\nvector\nCreate Sample UV Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.SampleUVSurface.boolean(\n    mesh=None,\n    value=False,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Boolean’.\n\n\n\nnodes.geometry.SampleUVSurface.color(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Color’.\n\n\n\nnodes.geometry.SampleUVSurface.float(\n    mesh=None,\n    value=0.0,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Float’.\n\n\n\nnodes.geometry.SampleUVSurface.integer(\n    mesh=None,\n    value=0,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Integer’.\n\n\n\nnodes.geometry.SampleUVSurface.matrix(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘4x4 Matrix’.\n\n\n\nnodes.geometry.SampleUVSurface.quaternion(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Quaternion’.\n\n\n\nnodes.geometry.SampleUVSurface.vector(\n    mesh=None,\n    value=None,\n    source_uv_map=None,\n    sample_uv=None,\n)\nCreate Sample UV Surface with operation ‘Vector’.\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n    axis=None,\n    *,\n    domain='FACE',\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Scale Elements with operation ‘Edge’.\n\n\nface\nCreate Scale Elements with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.ScaleElements.edge(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n)\nCreate Scale Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.ScaleElements.face(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=None,\n    scale_mode='Uniform',\n)\nCreate Scale Elements with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=None,\n    center=None,\n    local_space=True,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Separate Geometry with operation ‘Edge’.\n\n\nface\nCreate Separate Geometry with operation ‘Face’.\n\n\ninstance\nCreate Separate Geometry with operation ‘Instance’.\n\n\nlayer\nCreate Separate Geometry with operation ‘Layer’.\n\n\npoint\nCreate Separate Geometry with operation ‘Point’.\n\n\nspline\nCreate Separate Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SeparateGeometry.edge(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Edge’.\n\n\n\nnodes.geometry.SeparateGeometry.face(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Face’.\n\n\n\nnodes.geometry.SeparateGeometry.instance(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Instance’.\n\n\n\nnodes.geometry.SeparateGeometry.layer(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Layer’.\n\n\n\nnodes.geometry.SeparateGeometry.point(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Point’.\n\n\n\nnodes.geometry.SeparateGeometry.spline(geometry=None, selection=True)\nCreate Separate Geometry with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetCurveNormal(\n    curve=None,\n    selection=True,\n    mode='Minimum Twist',\n    normal=None,\n)\nSet the evaluation mode for curve normals\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_mode\nInput socket: Mode\n\n\ni_normal\nInput socket: Normal\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetCurveRadius(curve=None, selection=True, radius=0.005)\nSet the radius of the curve at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetCurveTilt(curve=None, selection=True, tilt=0.0)\nSet the tilt angle at each curve control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\ni_tilt\nInput socket: Tilt\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='')\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=None,\n    opacity=1.0,\n    *,\n    mode='STROKE',\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(grease_pencil=None, *, depth_order='2D')\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ndepth_order\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\nname\n\n\n\nnode\n\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetHandlePositions(\n    curve=None,\n    selection=True,\n    position=None,\n    offset=None,\n    *,\n    mode='LEFT',\n)\nSet the positions for the handles of Bézier curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetID(geometry=None, selection=True, id=0)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(geometry=None, selection=True, material=None)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(geometry=None, selection=True, material_index=0)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetMeshNormal(\n    mesh=None,\n    remove_custom=True,\n    edge_sharpness=False,\n    face_sharpness=False,\n    *,\n    mode='SHARPNESS',\n    domain='POINT',\n)\nStore a normal vector for each mesh element\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_edge_sharpness\nInput socket: Edge Sharpness\n\n\ni_face_sharpness\nInput socket: Face Sharpness\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_remove_custom\nInput socket: Remove Custom\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nface\nCreate Set Mesh Normal with operation ‘Face’.\n\n\nface_corner\nCreate Set Mesh Normal with operation ‘Face Corner’.\n\n\npoint\nCreate Set Mesh Normal with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SetMeshNormal.face(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Face’.\n\n\n\nnodes.geometry.SetMeshNormal.face_corner(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Face Corner’.\n\n\n\nnodes.geometry.SetMeshNormal.point(mesh=None, custom_normal=None)\nCreate Set Mesh Normal with operation ‘Point’.\n\n\n\n\n\nnodes.geometry.SetPointRadius(points=None, selection=True, radius=0.05)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=None,\n    offset=None,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    *,\n    domain='POINT',\n    selection_type='BOOLEAN',\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\nselection_type\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Set Selection with operation ‘Edge’.\n\n\nface\nCreate Set Selection with operation ‘Face’.\n\n\npoint\nCreate Set Selection with operation ‘Point’.\n\n\nspline\nCreate Set Selection with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetSelection.edge(geometry=None, selection=True)\nCreate Set Selection with operation ‘Edge’.\n\n\n\nnodes.geometry.SetSelection.face(geometry=None, selection=True)\nCreate Set Selection with operation ‘Face’.\n\n\n\nnodes.geometry.SetSelection.point(geometry=None, selection=True)\nCreate Set Selection with operation ‘Point’.\n\n\n\nnodes.geometry.SetSelection.spline(geometry=None, selection=True)\nCreate Set Selection with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    *,\n    domain='FACE',\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Set Shade Smooth with operation ‘Edge’.\n\n\nface\nCreate Set Shade Smooth with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.SetShadeSmooth.edge(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n)\nCreate Set Shade Smooth with operation ‘Edge’.\n\n\n\nnodes.geometry.SetShadeSmooth.face(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n)\nCreate Set Shade Smooth with operation ‘Face’.\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(geometry=None, selection=True, cyclic=False)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_geometry\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(geometry=None, selection=True, resolution=12)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SetSplineType(curve=None, selection=True, *, spline_type='POLY')\nChange the type of curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\nspline_type\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    *,\n    domain='POINT',\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Sort Elements with operation ‘Edge’.\n\n\nface\nCreate Sort Elements with operation ‘Face’.\n\n\ninstance\nCreate Sort Elements with operation ‘Instance’.\n\n\npoint\nCreate Sort Elements with operation ‘Point’.\n\n\nspline\nCreate Sort Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SortElements.edge(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Edge’.\n\n\n\nnodes.geometry.SortElements.face(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Face’.\n\n\n\nnodes.geometry.SortElements.instance(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Instance’.\n\n\n\nnodes.geometry.SortElements.point(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Point’.\n\n\n\nnodes.geometry.SortElements.spline(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n)\nCreate Sort Elements with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.Spiral(\n    resolution=32,\n    rotations=2.0,\n    start_radius=1.0,\n    end_radius=2.0,\n    height=2.0,\n    reverse=False,\n)\nGenerate a poly spline in a spiral shape\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_radius\nInput socket: End Radius\n\n\ni_height\nInput socket: Height\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_reverse\nInput socket: Reverse\n\n\ni_rotations\nInput socket: Rotations\n\n\ni_start_radius\nInput socket: Start Radius\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    *,\n    domain='POINT',\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nedge\nCreate Split to Instances with operation ‘Edge’.\n\n\nface\nCreate Split to Instances with operation ‘Face’.\n\n\ninstance\nCreate Split to Instances with operation ‘Instance’.\n\n\nlayer\nCreate Split to Instances with operation ‘Layer’.\n\n\npoint\nCreate Split to Instances with operation ‘Point’.\n\n\nspline\nCreate Split to Instances with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.SplitToInstances.edge(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Edge’.\n\n\n\nnodes.geometry.SplitToInstances.face(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Face’.\n\n\n\nnodes.geometry.SplitToInstances.instance(\n    geometry=None,\n    selection=True,\n    group_id=0,\n)\nCreate Split to Instances with operation ‘Instance’.\n\n\n\nnodes.geometry.SplitToInstances.layer(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Layer’.\n\n\n\nnodes.geometry.SplitToInstances.point(geometry=None, selection=True, group_id=0)\nCreate Split to Instances with operation ‘Point’.\n\n\n\nnodes.geometry.SplitToInstances.spline(\n    geometry=None,\n    selection=True,\n    group_id=0,\n)\nCreate Split to Instances with operation ‘Spline’.\n\n\n\n\n\nnodes.geometry.Star(points=8, inner_radius=1.0, outer_radius=2.0, twist=0.0)\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_inner_radius\nInput socket: Inner Radius\n\n\ni_outer_radius\nInput socket: Outer Radius\n\n\ni_points\nInput socket: Points\n\n\ni_twist\nInput socket: Twist\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\no_outer_points\nOutput socket: Outer Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.StringToCurves(\n    string='',\n    size=1.0,\n    character_spacing=1.0,\n    word_spacing=1.0,\n    line_spacing=1.0,\n    text_box_width=0.0,\n    text_box_height=0.0,\n    *,\n    overflow='OVERFLOW',\n    align_x='LEFT',\n    align_y='TOP_BASELINE',\n    pivot_mode='BOTTOM_LEFT',\n)\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\n\n\n\nName\nDescription\n\n\n\n\nalign_x\n\n\n\nalign_y\n\n\n\ni_character_spacing\nInput socket: Character Spacing\n\n\ni_line_spacing\nInput socket: Line Spacing\n\n\ni_size\nInput socket: Size\n\n\ni_string\nInput socket: String\n\n\ni_text_box_height\nInput socket: Text Box Height\n\n\ni_text_box_width\nInput socket: Text Box Width\n\n\ni_word_spacing\nInput socket: Word Spacing\n\n\nname\n\n\n\nnode\n\n\n\no_curve_instances\nOutput socket: Curve Instances\n\n\no_line\nOutput socket: Line\n\n\no_pivot_point\nOutput socket: Pivot Point\n\n\no_remainder\nOutput socket: Remainder\n\n\noverflow\n\n\n\npivot_mode\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivideCurve(curve=None, cuts=1)\nDividing each curve segment into a specified number of pieces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cuts\nInput socket: Cuts\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivideMesh(mesh=None, level=1)\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_level\nInput socket: Level\n\n\ni_mesh\nInput socket: Mesh\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=None,\n    rotation=None,\n    scale=None,\n    transform=None,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=None,\n    local_space=True,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.TrimCurve(\n    curve=None,\n    selection=True,\n    start=0.0,\n    end=1.0,\n    start_001=0.0,\n    end_001=1.0,\n    *,\n    mode='FACTOR',\n)\nShorten curves by removing portions at the start or end\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_end\nInput socket: End\n\n\ni_end_001\nInput socket: End\n\n\ni_selection\nInput socket: Selection\n\n\ni_start\nInput socket: Start\n\n\ni_start_001\nInput socket: Start\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.geometry.UVSphere(segments=32, rings=16, radius=1.0)\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_rings\nInput socket: Rings\n\n\ni_segments\nInput socket: Segments\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  },
  {
    "objectID": "reference/nodes.manual.html",
    "href": "reference/nodes.manual.html",
    "title": "nodes.manual",
    "section": "",
    "text": "nodes.manual\n\n\n\n\n\nName\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nAttributeStatistic\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nCaptureAttribute\nStore the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation\n\n\nCompare\nPerform a comparison operation on the two given inputs\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinAndMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFormatString\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nHandleTypeSelection\nProvide a selection based on the handle types of Bézier control points\n\n\nIndexSwitch\nNode builder for the Index Switch node\n\n\nJoinGeometry\nMerge separately generated geometries into a single one\n\n\nJoinStrings\nCombine any number of input strings\n\n\nMenuSwitch\nNode builder for the Index Switch node\n\n\nSDFGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSetHandleType\nSet the handle type for the control points of a Bézier curve\n\n\nValue\nInput numerical values to other nodes in the tree\n\n\n\n\n\nnodes.manual.AccumulateField(\n    value=1.0,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.AttributeStatistic(\n    geometry=None,\n    selection=True,\n    attribute=None,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\no_min\nOutput socket: Min\n\n\no_range\nOutput socket: Range\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_sum\nOutput socket: Sum\n\n\no_variance\nOutput socket: Variance\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.Bake(*args, **kwargs)\nCache the incoming data so that it can be used without recomputation\nTODO: properly handle Animation / Still bake opations and ability to bake to a file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ninputs\n\n\n\nname\n\n\n\nnode\n\n\n\no_input_socket\nOutput socket:\n\n\noutputs\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.CaptureAttribute(*args, geometry=None, domain='POINT', **kwargs)\nStore the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ncurve\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ninputs\n\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\noutputs\n\n\n\npoint\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture the value to store in the attribute\n\n\n\n\n\nnodes.manual.CaptureAttribute.capture(value)\nCapture the value to store in the attribute\nReturn the SocketLinker for the output socket\n\n\n\n\n\nnodes.manual.Compare(operation='GREATER_THAN', data_type='FLOAT', **kwargs)\nPerform a comparison operation on the two given inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrighter\n\n\n\ndarker\n\n\n\ndata_type\n\n\n\nequal\n\n\n\ngreater_equal\n\n\n\ngreater_than\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\nless_equal\n\n\n\nless_than\n\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\nnot_equal\n\n\n\no_result\nOutput socket: Result\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Compare with operation ‘Color’.\n\n\nfloat\n\n\n\ninteger\n\n\n\nstring\nCreate Compare with operation ‘String’.\n\n\nvector\n\n\n\n\n\n\nnodes.manual.Compare.color(a=None, b=None, operation='EQUAL', *, epsilon=None)\nCreate Compare with operation ‘Color’.\n\n\n\nnodes.manual.Compare.float(\n    a=0.0,\n    b=0.0,\n    operation='LESS_THAN',\n    *,\n    epsilon=0.0001,\n)\n\n\n\nnodes.manual.Compare.integer(a=0, b=0, operation='LESS_THAN')\n\n\n\nnodes.manual.Compare.string(a, b)\nCreate Compare with operation ‘String’.\n\n\n\nnodes.manual.Compare.vector(\n    a=(0.0, 0.0, 0.0),\n    b=(0.0, 0.0, 0.0),\n    operation='LESS_THAN',\n    *,\n    mode='ELEMENT',\n    c=None,\n    angle=None,\n    epsilon=None,\n)\n\n\n\n\n\nnodes.manual.EvaluateAtIndex(\n    value=None,\n    index=0,\n    *,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.EvaluateOnDomain(value=None, *, domain='POINT', data_type='FLOAT')\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldAverage(\n    value=None,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldMinAndMax(\n    value=1.0,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldToGrid(*args, topology=None, data_type='FLOAT', **kwargs)\nCreate new grids by evaluating new values on an existing volume grid topology\nNew socket items for field evaluation are first created from *args then **kwargs to give specific names to the items.\nData types are inferred automatically from the closest compatible data type.\n\n\ntopology: LINKABLE The grid which contains the topology to evaluate the different fields on. data_type: _GridDataTypes = “FLOAT” The data type of the grid to evaluate on. Possible values are “FLOAT”, “INT”, “VECTOR”, “BOOLEAN”. *args: TYPE_INPUT_VALUE | TYPE_INPUT_VECTOR | TYPE_INPUT_INT | TYPE_INPUT_BOOLEAN The fields to evaluate on the grid. **kwargs: dict[str, TYPE_INPUT_VALUE | TYPE_INPUT_VECTOR | TYPE_INPUT_INT | TYPE_INPUT_GEOMETRY] The key-value pairs of the fields to evaluate on the grid. Keys will be used as the name of the socket.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_topology\nInput socket: Topology\n\n\ninputs\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\ncapture\n\n\n\nfloat\n\n\n\ninteger\n\n\n\nvector\n\n\n\n\n\n\nnodes.manual.FieldToGrid.boolean(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.capture(*args, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.float(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.integer(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.vector(*args, topology=None, **kwargs)\n\n\n\n\n\nnodes.manual.FieldVariance(\n    value=None,\n    group_index=None,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FormatString(*args, format='', **kwargs)\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_format\nInput socket: Format\n\n\ni_input_socket\nInput socket:\n\n\nitems\nInput sockets:\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.GeometryToInstance(*args)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.HandleTypeSelection(handle_type='AUTO', left=True, right=True)\nProvide a selection based on the handle types of Bézier control points\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandle_type\n\n\n\nleft\n\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\nright\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.IndexSwitch(*args, index=0, data_type='FLOAT')\nNode builder for the Index Switch node\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nbundle\n\n\n\nclosure\n\n\n\ncollection\n\n\n\ncolor\n\n\n\ndata_type\nInput socket: Data Type\n\n\nfloat\n\n\n\ngeometry\n\n\n\ni_index\nInput socket: Index\n\n\nimage\n\n\n\ninputs\nInput sockets\n\n\ninteger\n\n\n\nmaterial\n\n\n\nmatrix\n\n\n\nmenu\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\nobject\n\n\n\nrotation\n\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.manual.JoinGeometry(*args)\nMerge separately generated geometries into a single one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.JoinStrings(*args, delimiter='')\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.MenuSwitch(*args, menu=None, data_type='FLOAT', **kwargs)\nNode builder for the Index Switch node\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nbundle\n\n\n\nclosure\n\n\n\ncollection\n\n\n\ncolor\n\n\n\ndata_type\nInput socket: Data Type\n\n\nfloat\n\n\n\ngeometry\n\n\n\ni_menu\nInput socket: Menu\n\n\nimage\n\n\n\ninputs\nInput sockets\n\n\ninteger\n\n\n\nmaterial\n\n\n\nmatrix\n\n\n\nmenu\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\nobject\n\n\n\noutputs\nInput sockets\n\n\nrotation\n\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.manual.SDFGridBoolean(operation='DIFFERENCE')\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\n\n\n\nunion\n\n\n\n\n\n\nnodes.manual.SDFGridBoolean.difference(*args, grid_1)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.manual.SDFGridBoolean.intersect(*args)\n\n\n\nnodes.manual.SDFGridBoolean.union(*args)\n\n\n\n\n\nnodes.manual.SetHandleType(\n    curve=None,\n    selection=True,\n    *,\n    left=False,\n    right=False,\n    handle_type='AUTO',\n)\nSet the handle type for the control points of a Bézier curve\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandle_type\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nleft\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\nright\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.Value(value=0.0)\nInput numerical values to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\nvalue\nInput socket: Value",
    "crumbs": [
      "Some functions",
      "nodes.manual"
    ]
  },
  {
    "objectID": "reference/nodes.manual.html#classes",
    "href": "reference/nodes.manual.html#classes",
    "title": "nodes.manual",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nAttributeStatistic\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nCaptureAttribute\nStore the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation\n\n\nCompare\nPerform a comparison operation on the two given inputs\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinAndMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFormatString\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nHandleTypeSelection\nProvide a selection based on the handle types of Bézier control points\n\n\nIndexSwitch\nNode builder for the Index Switch node\n\n\nJoinGeometry\nMerge separately generated geometries into a single one\n\n\nJoinStrings\nCombine any number of input strings\n\n\nMenuSwitch\nNode builder for the Index Switch node\n\n\nSDFGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSetHandleType\nSet the handle type for the control points of a Bézier curve\n\n\nValue\nInput numerical values to other nodes in the tree\n\n\n\n\n\nnodes.manual.AccumulateField(\n    value=1.0,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.AttributeStatistic(\n    geometry=None,\n    selection=True,\n    attribute=None,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\no_min\nOutput socket: Min\n\n\no_range\nOutput socket: Range\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_sum\nOutput socket: Sum\n\n\no_variance\nOutput socket: Variance\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.Bake(*args, **kwargs)\nCache the incoming data so that it can be used without recomputation\nTODO: properly handle Animation / Still bake opations and ability to bake to a file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ninputs\n\n\n\nname\n\n\n\nnode\n\n\n\no_input_socket\nOutput socket:\n\n\noutputs\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.CaptureAttribute(*args, geometry=None, domain='POINT', **kwargs)\nStore the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ncurve\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ninputs\n\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\noutputs\n\n\n\npoint\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapture\nCapture the value to store in the attribute\n\n\n\n\n\nnodes.manual.CaptureAttribute.capture(value)\nCapture the value to store in the attribute\nReturn the SocketLinker for the output socket\n\n\n\n\n\nnodes.manual.Compare(operation='GREATER_THAN', data_type='FLOAT', **kwargs)\nPerform a comparison operation on the two given inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrighter\n\n\n\ndarker\n\n\n\ndata_type\n\n\n\nequal\n\n\n\ngreater_equal\n\n\n\ngreater_than\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\nless_equal\n\n\n\nless_than\n\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\nnot_equal\n\n\n\no_result\nOutput socket: Result\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Compare with operation ‘Color’.\n\n\nfloat\n\n\n\ninteger\n\n\n\nstring\nCreate Compare with operation ‘String’.\n\n\nvector\n\n\n\n\n\n\nnodes.manual.Compare.color(a=None, b=None, operation='EQUAL', *, epsilon=None)\nCreate Compare with operation ‘Color’.\n\n\n\nnodes.manual.Compare.float(\n    a=0.0,\n    b=0.0,\n    operation='LESS_THAN',\n    *,\n    epsilon=0.0001,\n)\n\n\n\nnodes.manual.Compare.integer(a=0, b=0, operation='LESS_THAN')\n\n\n\nnodes.manual.Compare.string(a, b)\nCreate Compare with operation ‘String’.\n\n\n\nnodes.manual.Compare.vector(\n    a=(0.0, 0.0, 0.0),\n    b=(0.0, 0.0, 0.0),\n    operation='LESS_THAN',\n    *,\n    mode='ELEMENT',\n    c=None,\n    angle=None,\n    epsilon=None,\n)\n\n\n\n\n\nnodes.manual.EvaluateAtIndex(\n    value=None,\n    index=0,\n    *,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.EvaluateOnDomain(value=None, *, domain='POINT', data_type='FLOAT')\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldAverage(\n    value=None,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldMinAndMax(\n    value=1.0,\n    group_index=0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FieldToGrid(*args, topology=None, data_type='FLOAT', **kwargs)\nCreate new grids by evaluating new values on an existing volume grid topology\nNew socket items for field evaluation are first created from *args then **kwargs to give specific names to the items.\nData types are inferred automatically from the closest compatible data type.\n\n\ntopology: LINKABLE The grid which contains the topology to evaluate the different fields on. data_type: _GridDataTypes = “FLOAT” The data type of the grid to evaluate on. Possible values are “FLOAT”, “INT”, “VECTOR”, “BOOLEAN”. *args: TYPE_INPUT_VALUE | TYPE_INPUT_VECTOR | TYPE_INPUT_INT | TYPE_INPUT_BOOLEAN The fields to evaluate on the grid. **kwargs: dict[str, TYPE_INPUT_VALUE | TYPE_INPUT_VECTOR | TYPE_INPUT_INT | TYPE_INPUT_GEOMETRY] The key-value pairs of the fields to evaluate on the grid. Keys will be used as the name of the socket.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_topology\nInput socket: Topology\n\n\ninputs\n\n\n\nname\n\n\n\nnode\n\n\n\noutputs\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\ncapture\n\n\n\nfloat\n\n\n\ninteger\n\n\n\nvector\n\n\n\n\n\n\nnodes.manual.FieldToGrid.boolean(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.capture(*args, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.float(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.integer(*args, topology=None, **kwargs)\n\n\n\nnodes.manual.FieldToGrid.vector(*args, topology=None, **kwargs)\n\n\n\n\n\nnodes.manual.FieldVariance(\n    value=None,\n    group_index=None,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ncorner\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\nedge\n\n\n\nface\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\ninstance\n\n\n\nlayer\n\n\n\nname\n\n\n\nnode\n\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\npoint\n\n\n\nspline\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.FormatString(*args, format='', **kwargs)\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_format\nInput socket: Format\n\n\ni_input_socket\nInput socket:\n\n\nitems\nInput sockets:\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.GeometryToInstance(*args)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_instances\nOutput socket: Instances\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.HandleTypeSelection(handle_type='AUTO', left=True, right=True)\nProvide a selection based on the handle types of Bézier control points\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandle_type\n\n\n\nleft\n\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_selection\nOutput socket: Selection\n\n\nright\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.IndexSwitch(*args, index=0, data_type='FLOAT')\nNode builder for the Index Switch node\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nbundle\n\n\n\nclosure\n\n\n\ncollection\n\n\n\ncolor\n\n\n\ndata_type\nInput socket: Data Type\n\n\nfloat\n\n\n\ngeometry\n\n\n\ni_index\nInput socket: Index\n\n\nimage\n\n\n\ninputs\nInput sockets\n\n\ninteger\n\n\n\nmaterial\n\n\n\nmatrix\n\n\n\nmenu\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\nobject\n\n\n\nrotation\n\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.manual.JoinGeometry(*args)\nMerge separately generated geometries into a single one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.JoinStrings(*args, delimiter='')\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\nname\n\n\n\nnode\n\n\n\no_string\nOutput socket: String\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.MenuSwitch(*args, menu=None, data_type='FLOAT', **kwargs)\nNode builder for the Index Switch node\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\n\n\n\nbundle\n\n\n\nclosure\n\n\n\ncollection\n\n\n\ncolor\n\n\n\ndata_type\nInput socket: Data Type\n\n\nfloat\n\n\n\ngeometry\n\n\n\ni_menu\nInput socket: Menu\n\n\nimage\n\n\n\ninputs\nInput sockets\n\n\ninteger\n\n\n\nmaterial\n\n\n\nmatrix\n\n\n\nmenu\n\n\n\nname\n\n\n\nnode\n\n\n\no_output\nOutput socket: Output\n\n\nobject\n\n\n\noutputs\nInput sockets\n\n\nrotation\n\n\n\nstring\n\n\n\ntree\n\n\n\ntype\n\n\n\nvector\n\n\n\n\n\n\n\n\nnodes.manual.SDFGridBoolean(operation='DIFFERENCE')\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\noperation\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\n\n\n\nunion\n\n\n\n\n\n\nnodes.manual.SDFGridBoolean.difference(*args, grid_1)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.manual.SDFGridBoolean.intersect(*args)\n\n\n\nnodes.manual.SDFGridBoolean.union(*args)\n\n\n\n\n\nnodes.manual.SetHandleType(\n    curve=None,\n    selection=True,\n    *,\n    left=False,\n    right=False,\n    handle_type='AUTO',\n)\nSet the handle type for the control points of a Bézier curve\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandle_type\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\nleft\n\n\n\nname\n\n\n\nnode\n\n\n\no_curve\nOutput socket: Curve\n\n\nright\n\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.manual.Value(value=0.0)\nInput numerical values to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\nvalue\nInput socket: Value",
    "crumbs": [
      "Some functions",
      "nodes.manual"
    ]
  },
  {
    "objectID": "reference/nodes.grid.html",
    "href": "reference/nodes.grid.html",
    "title": "nodes.grid",
    "section": "",
    "text": "nodes.grid\n\n\n\n\n\nName\nDescription\n\n\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGridToMesh\nGenerate a mesh on the “surface” of a volume grid\n\n\nMeshToDensityGrid\nCreate a filled volume grid from a mesh\n\n\nMeshToSDFGrid\nCreate a signed distance volume grid from a mesh\n\n\nMeshToVolume\nCreate a fog volume with the shape of the input mesh’s surface\n\n\nPointsToSDFGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nSDFGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSDFGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSDFGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSDFGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSDFGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSDFGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVolumeToMesh\nGenerate a mesh on the “surface” of a volume\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nnodes.grid.AdvectGrid(\n    grid=0.0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    *,\n    data_type='FLOAT',\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Advect Grid with operation ‘Float’.\n\n\ninteger\nCreate Advect Grid with operation ‘Integer’.\n\n\nvector\nCreate Advect Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.AdvectGrid.float(\n    grid=0.0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Float’.\n\n\n\nnodes.grid.AdvectGrid.integer(\n    grid=0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Integer’.\n\n\n\nnodes.grid.AdvectGrid.vector(\n    grid=None,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    spacing=None,\n    threshold=0.1,\n    *,\n    mode='DENSITY_RANDOM',\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=None,\n    threshold=0.1,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GetNamedGrid(volume=None, name='', remove=True, *, data_type='FLOAT')\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Get Named Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Get Named Grid with operation ‘Float’.\n\n\ninteger\nCreate Get Named Grid with operation ‘Integer’.\n\n\nvector\nCreate Get Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GetNamedGrid.boolean(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.GetNamedGrid.float(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Float’.\n\n\n\nnodes.grid.GetNamedGrid.integer(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Integer’.\n\n\n\nnodes.grid.GetNamedGrid.vector(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridCurl(grid=None)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_curl\nOutput socket: Curl\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridDivergence(grid=None)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_divergence\nOutput socket: Divergence\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridGradient(grid=0.0)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_gradient\nOutput socket: Gradient\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridInfo(grid=0.0, *, data_type='FLOAT')\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Grid Info with operation ‘Boolean’.\n\n\nfloat\nCreate Grid Info with operation ‘Float’.\n\n\ninteger\nCreate Grid Info with operation ‘Integer’.\n\n\nvector\nCreate Grid Info with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridInfo.boolean(grid=False)\nCreate Grid Info with operation ‘Boolean’.\n\n\n\nnodes.grid.GridInfo.float(grid=0.0)\nCreate Grid Info with operation ‘Float’.\n\n\n\nnodes.grid.GridInfo.integer(grid=0)\nCreate Grid Info with operation ‘Integer’.\n\n\n\nnodes.grid.GridInfo.vector(grid=None)\nCreate Grid Info with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridLaplacian(grid=0.0)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_laplacian\nOutput socket: Laplacian\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridToMesh(grid=0.0, threshold=0.1, adaptivity=0.0)\nGenerate a mesh on the “surface” of a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_grid\nInput socket: Grid\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToDensityGrid(\n    mesh=None,\n    density=1.0,\n    voxel_size=0.3,\n    gradient_width=0.2,\n)\nCreate a filled volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_gradient_width\nInput socket: Gradient Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_density_grid\nOutput socket: Density Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToSDFGrid(mesh=None, voxel_size=0.3, band_width=3)\nCreate a signed distance volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_band_width\nInput socket: Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToVolume(\n    mesh=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    interior_band_width=0.2,\n)\nCreate a fog volume with the shape of the input mesh’s surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_interior_band_width\nInput socket: Interior Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PointsToSDFGrid(points=None, radius=0.5, voxel_size=0.3)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    radius=0.5,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.01,\n    *,\n    data_type='FLOAT',\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Prune Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Prune Grid with operation ‘Float’.\n\n\ninteger\nCreate Prune Grid with operation ‘Integer’.\n\n\nvector\nCreate Prune Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.PruneGrid.boolean(grid=False, mode='Threshold')\nCreate Prune Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.PruneGrid.float(grid=0.0, mode='Threshold', threshold=0.01)\nCreate Prune Grid with operation ‘Float’.\n\n\n\nnodes.grid.PruneGrid.integer(grid=0, mode='Threshold', threshold=0)\nCreate Prune Grid with operation ‘Integer’.\n\n\n\nnodes.grid.PruneGrid.vector(grid=None, mode='Threshold', threshold=None)\nCreate Prune Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SDFGridFillet(grid=0.0, iterations=1)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridLaplacian(grid=0.0, iterations=1)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMean(grid=0.0, width=1, iterations=1)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMeanCurvature(grid=0.0, iterations=1)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMedian(grid=0.0, width=1, iterations=1)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridOffset(grid=0.0, distance=0.1)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SampleGrid(\n    grid=0.0,\n    position=None,\n    interpolation='Trilinear',\n    *,\n    data_type='FLOAT',\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Sample Grid with operation ‘Float’.\n\n\ninteger\nCreate Sample Grid with operation ‘Integer’.\n\n\nvector\nCreate Sample Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGrid.boolean(\n    grid=False,\n    position=None,\n    interpolation='Trilinear',\n)\nCreate Sample Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.SampleGrid.float(grid=0.0, position=None, interpolation='Trilinear')\nCreate Sample Grid with operation ‘Float’.\n\n\n\nnodes.grid.SampleGrid.integer(grid=0, position=None, interpolation='Trilinear')\nCreate Sample Grid with operation ‘Integer’.\n\n\n\nnodes.grid.SampleGrid.vector(\n    grid=None,\n    position=None,\n    interpolation='Trilinear',\n)\nCreate Sample Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGridIndex(grid=0.0, x=0, y=0, z=0, *, data_type='FLOAT')\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Grid Index with operation ‘Boolean’.\n\n\nfloat\nCreate Sample Grid Index with operation ‘Float’.\n\n\ninteger\nCreate Sample Grid Index with operation ‘Integer’.\n\n\nvector\nCreate Sample Grid Index with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGridIndex.boolean(grid=False, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Boolean’.\n\n\n\nnodes.grid.SampleGridIndex.float(grid=0.0, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Float’.\n\n\n\nnodes.grid.SampleGridIndex.integer(grid=0, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Integer’.\n\n\n\nnodes.grid.SampleGridIndex.vector(grid=None, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridBackground(grid=0.0, background=0.0, *, data_type='FLOAT')\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Set Grid Background with operation ‘Boolean’.\n\n\nfloat\nCreate Set Grid Background with operation ‘Float’.\n\n\ninteger\nCreate Set Grid Background with operation ‘Integer’.\n\n\nvector\nCreate Set Grid Background with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridBackground.boolean(grid=False, background=False)\nCreate Set Grid Background with operation ‘Boolean’.\n\n\n\nnodes.grid.SetGridBackground.float(grid=0.0, background=0.0)\nCreate Set Grid Background with operation ‘Float’.\n\n\n\nnodes.grid.SetGridBackground.integer(grid=0, background=0)\nCreate Set Grid Background with operation ‘Integer’.\n\n\n\nnodes.grid.SetGridBackground.vector(grid=None, background=None)\nCreate Set Grid Background with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridTransform(grid=0.0, transform=None, *, data_type='FLOAT')\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Set Grid Transform with operation ‘Boolean’.\n\n\nfloat\nCreate Set Grid Transform with operation ‘Float’.\n\n\ninteger\nCreate Set Grid Transform with operation ‘Integer’.\n\n\nvector\nCreate Set Grid Transform with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridTransform.boolean(grid=False, transform=None)\nCreate Set Grid Transform with operation ‘Boolean’.\n\n\n\nnodes.grid.SetGridTransform.float(grid=0.0, transform=None)\nCreate Set Grid Transform with operation ‘Float’.\n\n\n\nnodes.grid.SetGridTransform.integer(grid=0, transform=None)\nCreate Set Grid Transform with operation ‘Integer’.\n\n\n\nnodes.grid.SetGridTransform.vector(grid=None, transform=None)\nCreate Set Grid Transform with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.StoreNamedGrid(volume=None, name='', grid=0.0, *, data_type='FLOAT')\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Store Named Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Store Named Grid with operation ‘Float’.\n\n\ninteger\nCreate Store Named Grid with operation ‘Integer’.\n\n\nvector\nCreate Store Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.StoreNamedGrid.boolean(volume=None, name='', grid=False)\nCreate Store Named Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.StoreNamedGrid.float(volume=None, name='', grid=0.0)\nCreate Store Named Grid with operation ‘Float’.\n\n\n\nnodes.grid.StoreNamedGrid.integer(volume=None, name='', grid=0)\nCreate Store Named Grid with operation ‘Integer’.\n\n\n\nnodes.grid.StoreNamedGrid.vector(volume=None, name='', grid=None)\nCreate Store Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=None,\n    max=None,\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.VolumeToMesh(\n    volume=None,\n    resolution_mode='Grid',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    threshold=0.1,\n    adaptivity=0.0,\n)\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.VoxelizeGrid(grid=0.0, *, data_type='FLOAT')\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Voxelize Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Voxelize Grid with operation ‘Float’.\n\n\ninteger\nCreate Voxelize Grid with operation ‘Integer’.\n\n\nvector\nCreate Voxelize Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.VoxelizeGrid.boolean(grid=False)\nCreate Voxelize Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.VoxelizeGrid.float(grid=0.0)\nCreate Voxelize Grid with operation ‘Float’.\n\n\n\nnodes.grid.VoxelizeGrid.integer(grid=0)\nCreate Voxelize Grid with operation ‘Integer’.\n\n\n\nnodes.grid.VoxelizeGrid.vector(grid=None)\nCreate Voxelize Grid with operation ‘Vector’.",
    "crumbs": [
      "Some functions",
      "nodes.grid"
    ]
  },
  {
    "objectID": "reference/nodes.grid.html#classes",
    "href": "reference/nodes.grid.html#classes",
    "title": "nodes.grid",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGridToMesh\nGenerate a mesh on the “surface” of a volume grid\n\n\nMeshToDensityGrid\nCreate a filled volume grid from a mesh\n\n\nMeshToSDFGrid\nCreate a signed distance volume grid from a mesh\n\n\nMeshToVolume\nCreate a fog volume with the shape of the input mesh’s surface\n\n\nPointsToSDFGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nSDFGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSDFGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSDFGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSDFGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSDFGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSDFGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVolumeToMesh\nGenerate a mesh on the “surface” of a volume\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nnodes.grid.AdvectGrid(\n    grid=0.0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    *,\n    data_type='FLOAT',\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfloat\nCreate Advect Grid with operation ‘Float’.\n\n\ninteger\nCreate Advect Grid with operation ‘Integer’.\n\n\nvector\nCreate Advect Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.AdvectGrid.float(\n    grid=0.0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Float’.\n\n\n\nnodes.grid.AdvectGrid.integer(\n    grid=0,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Integer’.\n\n\n\nnodes.grid.AdvectGrid.vector(\n    grid=None,\n    velocity=None,\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n)\nCreate Advect Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    spacing=None,\n    threshold=0.1,\n    *,\n    mode='DENSITY_RANDOM',\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\nmode\n\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=None,\n    threshold=0.1,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_points\nOutput socket: Points\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GetNamedGrid(volume=None, name='', remove=True, *, data_type='FLOAT')\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Get Named Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Get Named Grid with operation ‘Float’.\n\n\ninteger\nCreate Get Named Grid with operation ‘Integer’.\n\n\nvector\nCreate Get Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GetNamedGrid.boolean(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.GetNamedGrid.float(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Float’.\n\n\n\nnodes.grid.GetNamedGrid.integer(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Integer’.\n\n\n\nnodes.grid.GetNamedGrid.vector(volume=None, name='', remove=True)\nCreate Get Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridCurl(grid=None)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_curl\nOutput socket: Curl\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridDivergence(grid=None)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_divergence\nOutput socket: Divergence\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridGradient(grid=0.0)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_gradient\nOutput socket: Gradient\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridInfo(grid=0.0, *, data_type='FLOAT')\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Grid Info with operation ‘Boolean’.\n\n\nfloat\nCreate Grid Info with operation ‘Float’.\n\n\ninteger\nCreate Grid Info with operation ‘Integer’.\n\n\nvector\nCreate Grid Info with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridInfo.boolean(grid=False)\nCreate Grid Info with operation ‘Boolean’.\n\n\n\nnodes.grid.GridInfo.float(grid=0.0)\nCreate Grid Info with operation ‘Float’.\n\n\n\nnodes.grid.GridInfo.integer(grid=0)\nCreate Grid Info with operation ‘Integer’.\n\n\n\nnodes.grid.GridInfo.vector(grid=None)\nCreate Grid Info with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.GridLaplacian(grid=0.0)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_laplacian\nOutput socket: Laplacian\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.GridToMesh(grid=0.0, threshold=0.1, adaptivity=0.0)\nGenerate a mesh on the “surface” of a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_grid\nInput socket: Grid\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToDensityGrid(\n    mesh=None,\n    density=1.0,\n    voxel_size=0.3,\n    gradient_width=0.2,\n)\nCreate a filled volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_gradient_width\nInput socket: Gradient Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_density_grid\nOutput socket: Density Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToSDFGrid(mesh=None, voxel_size=0.3, band_width=3)\nCreate a signed distance volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_band_width\nInput socket: Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.MeshToVolume(\n    mesh=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    interior_band_width=0.2,\n)\nCreate a fog volume with the shape of the input mesh’s surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_interior_band_width\nInput socket: Interior Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PointsToSDFGrid(points=None, radius=0.5, voxel_size=0.3)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    radius=0.5,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.01,\n    *,\n    data_type='FLOAT',\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Prune Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Prune Grid with operation ‘Float’.\n\n\ninteger\nCreate Prune Grid with operation ‘Integer’.\n\n\nvector\nCreate Prune Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.PruneGrid.boolean(grid=False, mode='Threshold')\nCreate Prune Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.PruneGrid.float(grid=0.0, mode='Threshold', threshold=0.01)\nCreate Prune Grid with operation ‘Float’.\n\n\n\nnodes.grid.PruneGrid.integer(grid=0, mode='Threshold', threshold=0)\nCreate Prune Grid with operation ‘Integer’.\n\n\n\nnodes.grid.PruneGrid.vector(grid=None, mode='Threshold', threshold=None)\nCreate Prune Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SDFGridFillet(grid=0.0, iterations=1)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridLaplacian(grid=0.0, iterations=1)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMean(grid=0.0, width=1, iterations=1)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMeanCurvature(grid=0.0, iterations=1)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridMedian(grid=0.0, width=1, iterations=1)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SDFGridOffset(grid=0.0, distance=0.1)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.SampleGrid(\n    grid=0.0,\n    position=None,\n    interpolation='Trilinear',\n    *,\n    data_type='FLOAT',\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Sample Grid with operation ‘Float’.\n\n\ninteger\nCreate Sample Grid with operation ‘Integer’.\n\n\nvector\nCreate Sample Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGrid.boolean(\n    grid=False,\n    position=None,\n    interpolation='Trilinear',\n)\nCreate Sample Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.SampleGrid.float(grid=0.0, position=None, interpolation='Trilinear')\nCreate Sample Grid with operation ‘Float’.\n\n\n\nnodes.grid.SampleGrid.integer(grid=0, position=None, interpolation='Trilinear')\nCreate Sample Grid with operation ‘Integer’.\n\n\n\nnodes.grid.SampleGrid.vector(\n    grid=None,\n    position=None,\n    interpolation='Trilinear',\n)\nCreate Sample Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGridIndex(grid=0.0, x=0, y=0, z=0, *, data_type='FLOAT')\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Sample Grid Index with operation ‘Boolean’.\n\n\nfloat\nCreate Sample Grid Index with operation ‘Float’.\n\n\ninteger\nCreate Sample Grid Index with operation ‘Integer’.\n\n\nvector\nCreate Sample Grid Index with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SampleGridIndex.boolean(grid=False, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Boolean’.\n\n\n\nnodes.grid.SampleGridIndex.float(grid=0.0, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Float’.\n\n\n\nnodes.grid.SampleGridIndex.integer(grid=0, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Integer’.\n\n\n\nnodes.grid.SampleGridIndex.vector(grid=None, x=0, y=0, z=0)\nCreate Sample Grid Index with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridBackground(grid=0.0, background=0.0, *, data_type='FLOAT')\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Set Grid Background with operation ‘Boolean’.\n\n\nfloat\nCreate Set Grid Background with operation ‘Float’.\n\n\ninteger\nCreate Set Grid Background with operation ‘Integer’.\n\n\nvector\nCreate Set Grid Background with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridBackground.boolean(grid=False, background=False)\nCreate Set Grid Background with operation ‘Boolean’.\n\n\n\nnodes.grid.SetGridBackground.float(grid=0.0, background=0.0)\nCreate Set Grid Background with operation ‘Float’.\n\n\n\nnodes.grid.SetGridBackground.integer(grid=0, background=0)\nCreate Set Grid Background with operation ‘Integer’.\n\n\n\nnodes.grid.SetGridBackground.vector(grid=None, background=None)\nCreate Set Grid Background with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridTransform(grid=0.0, transform=None, *, data_type='FLOAT')\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Set Grid Transform with operation ‘Boolean’.\n\n\nfloat\nCreate Set Grid Transform with operation ‘Float’.\n\n\ninteger\nCreate Set Grid Transform with operation ‘Integer’.\n\n\nvector\nCreate Set Grid Transform with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.SetGridTransform.boolean(grid=False, transform=None)\nCreate Set Grid Transform with operation ‘Boolean’.\n\n\n\nnodes.grid.SetGridTransform.float(grid=0.0, transform=None)\nCreate Set Grid Transform with operation ‘Float’.\n\n\n\nnodes.grid.SetGridTransform.integer(grid=0, transform=None)\nCreate Set Grid Transform with operation ‘Integer’.\n\n\n\nnodes.grid.SetGridTransform.vector(grid=None, transform=None)\nCreate Set Grid Transform with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.StoreNamedGrid(volume=None, name='', grid=0.0, *, data_type='FLOAT')\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Store Named Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Store Named Grid with operation ‘Float’.\n\n\ninteger\nCreate Store Named Grid with operation ‘Integer’.\n\n\nvector\nCreate Store Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.StoreNamedGrid.boolean(volume=None, name='', grid=False)\nCreate Store Named Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.StoreNamedGrid.float(volume=None, name='', grid=0.0)\nCreate Store Named Grid with operation ‘Float’.\n\n\n\nnodes.grid.StoreNamedGrid.integer(volume=None, name='', grid=0)\nCreate Store Named Grid with operation ‘Integer’.\n\n\n\nnodes.grid.StoreNamedGrid.vector(volume=None, name='', grid=None)\nCreate Store Named Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=None,\n    max=None,\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\nname\n\n\n\nnode\n\n\n\no_volume\nOutput socket: Volume\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.VolumeToMesh(\n    volume=None,\n    resolution_mode='Grid',\n    voxel_size=0.3,\n    voxel_amount=64.0,\n    threshold=0.1,\n    adaptivity=0.0,\n)\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\nname\n\n\n\nnode\n\n\n\no_mesh\nOutput socket: Mesh\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.grid.VoxelizeGrid(grid=0.0, *, data_type='FLOAT')\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_grid\nInput socket: Grid\n\n\nname\n\n\n\nnode\n\n\n\no_grid\nOutput socket: Grid\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Voxelize Grid with operation ‘Boolean’.\n\n\nfloat\nCreate Voxelize Grid with operation ‘Float’.\n\n\ninteger\nCreate Voxelize Grid with operation ‘Integer’.\n\n\nvector\nCreate Voxelize Grid with operation ‘Vector’.\n\n\n\n\n\nnodes.grid.VoxelizeGrid.boolean(grid=False)\nCreate Voxelize Grid with operation ‘Boolean’.\n\n\n\nnodes.grid.VoxelizeGrid.float(grid=0.0)\nCreate Voxelize Grid with operation ‘Float’.\n\n\n\nnodes.grid.VoxelizeGrid.integer(grid=0)\nCreate Voxelize Grid with operation ‘Integer’.\n\n\n\nnodes.grid.VoxelizeGrid.vector(grid=None)\nCreate Voxelize Grid with operation ‘Vector’.",
    "crumbs": [
      "Some functions",
      "nodes.grid"
    ]
  },
  {
    "objectID": "reference/nodes.attribute.html",
    "href": "reference/nodes.attribute.html",
    "title": "nodes.attribute",
    "section": "",
    "text": "nodes.attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\nBlurAttribute\nMix attribute values of neighboring elements\n\n\nDomainSize\nRetrieve the number of elements in a geometry for each attribute domain\n\n\nRemoveNamedAttribute\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\nStoreNamedAttribute\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nnodes.attribute.BlurAttribute(\n    value=0.0,\n    iterations=1,\n    weight=1.0,\n    *,\n    data_type='FLOAT',\n)\nMix attribute values of neighboring elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_value\nInput socket: Value\n\n\ni_weight\nInput socket: Weight\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Blur Attribute with operation ‘Color’.\n\n\nfloat\nCreate Blur Attribute with operation ‘Float’.\n\n\ninteger\nCreate Blur Attribute with operation ‘Integer’.\n\n\nvector\nCreate Blur Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.attribute.BlurAttribute.color(value=None, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Color’.\n\n\n\nnodes.attribute.BlurAttribute.float(value=0.0, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Float’.\n\n\n\nnodes.attribute.BlurAttribute.integer(value=0, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Integer’.\n\n\n\nnodes.attribute.BlurAttribute.vector(value=None, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.attribute.DomainSize(geometry=None, *, component='MESH')\nRetrieve the number of elements in a geometry for each attribute domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ncomponent\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_edge_count\nOutput socket: Edge Count\n\n\no_face_corner_count\nOutput socket: Face Corner Count\n\n\no_face_count\nOutput socket: Face Count\n\n\no_instance_count\nOutput socket: Instance Count\n\n\no_layer_count\nOutput socket: Layer Count\n\n\no_point_count\nOutput socket: Point Count\n\n\no_spline_count\nOutput socket: Spline Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.attribute.RemoveNamedAttribute(\n    geometry=None,\n    pattern_mode='Exact',\n    name='',\n)\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_pattern_mode\nInput socket: Pattern Mode\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_selection\nInput socket: Selection\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Store Named Attribute with operation ‘Boolean’.\n\n\nbyte_color\nCreate Store Named Attribute with operation ‘Byte Color’.\n\n\ncolor\nCreate Store Named Attribute with operation ‘Color’.\n\n\nedge\nCreate Store Named Attribute with operation ‘Edge’.\n\n\nface\nCreate Store Named Attribute with operation ‘Face’.\n\n\nface_corner\nCreate Store Named Attribute with operation ‘Face Corner’.\n\n\nfloat\nCreate Store Named Attribute with operation ‘Float’.\n\n\ninstance\nCreate Store Named Attribute with operation ‘Instance’.\n\n\nint8\nCreate Store Named Attribute with operation ‘8-Bit Integer’.\n\n\ninteger\nCreate Store Named Attribute with operation ‘Integer’.\n\n\nlayer\nCreate Store Named Attribute with operation ‘Layer’.\n\n\nmatrix\nCreate Store Named Attribute with operation ‘4x4 Matrix’.\n\n\npoint\nCreate Store Named Attribute with operation ‘Point’.\n\n\nquaternion\nCreate Store Named Attribute with operation ‘Quaternion’.\n\n\nspline\nCreate Store Named Attribute with operation ‘Spline’.\n\n\nvector\nCreate Store Named Attribute with operation ‘Vector’.\n\n\nvector2\nCreate Store Named Attribute with operation ‘2D Vector’.\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute.boolean(\n    geometry=None,\n    selection=True,\n    name='',\n    value=False,\n)\nCreate Store Named Attribute with operation ‘Boolean’.\n\n\n\nnodes.attribute.StoreNamedAttribute.byte_color(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Byte Color’.\n\n\n\nnodes.attribute.StoreNamedAttribute.color(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Color’.\n\n\n\nnodes.attribute.StoreNamedAttribute.edge(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Edge’.\n\n\n\nnodes.attribute.StoreNamedAttribute.face(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Face’.\n\n\n\nnodes.attribute.StoreNamedAttribute.face_corner(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Face Corner’.\n\n\n\nnodes.attribute.StoreNamedAttribute.float(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n)\nCreate Store Named Attribute with operation ‘Float’.\n\n\n\nnodes.attribute.StoreNamedAttribute.instance(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Instance’.\n\n\n\nnodes.attribute.StoreNamedAttribute.int8(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0,\n)\nCreate Store Named Attribute with operation ‘8-Bit Integer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.integer(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0,\n)\nCreate Store Named Attribute with operation ‘Integer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.layer(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Layer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.matrix(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘4x4 Matrix’.\n\n\n\nnodes.attribute.StoreNamedAttribute.point(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Point’.\n\n\n\nnodes.attribute.StoreNamedAttribute.quaternion(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Quaternion’.\n\n\n\nnodes.attribute.StoreNamedAttribute.spline(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Spline’.\n\n\n\nnodes.attribute.StoreNamedAttribute.vector(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Vector’.\n\n\n\nnodes.attribute.StoreNamedAttribute.vector2(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘2D Vector’.",
    "crumbs": [
      "Some functions",
      "nodes.attribute"
    ]
  },
  {
    "objectID": "reference/nodes.attribute.html#classes",
    "href": "reference/nodes.attribute.html#classes",
    "title": "nodes.attribute",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBlurAttribute\nMix attribute values of neighboring elements\n\n\nDomainSize\nRetrieve the number of elements in a geometry for each attribute domain\n\n\nRemoveNamedAttribute\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\nStoreNamedAttribute\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nnodes.attribute.BlurAttribute(\n    value=0.0,\n    iterations=1,\n    weight=1.0,\n    *,\n    data_type='FLOAT',\n)\nMix attribute values of neighboring elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_value\nInput socket: Value\n\n\ni_weight\nInput socket: Weight\n\n\nname\n\n\n\nnode\n\n\n\no_value\nOutput socket: Value\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncolor\nCreate Blur Attribute with operation ‘Color’.\n\n\nfloat\nCreate Blur Attribute with operation ‘Float’.\n\n\ninteger\nCreate Blur Attribute with operation ‘Integer’.\n\n\nvector\nCreate Blur Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.attribute.BlurAttribute.color(value=None, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Color’.\n\n\n\nnodes.attribute.BlurAttribute.float(value=0.0, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Float’.\n\n\n\nnodes.attribute.BlurAttribute.integer(value=0, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Integer’.\n\n\n\nnodes.attribute.BlurAttribute.vector(value=None, iterations=1, weight=1.0)\nCreate Blur Attribute with operation ‘Vector’.\n\n\n\n\n\nnodes.attribute.DomainSize(geometry=None, *, component='MESH')\nRetrieve the number of elements in a geometry for each attribute domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ncomponent\n\n\n\ni_geometry\nInput socket: Geometry\n\n\nname\n\n\n\nnode\n\n\n\no_edge_count\nOutput socket: Edge Count\n\n\no_face_corner_count\nOutput socket: Face Corner Count\n\n\no_face_count\nOutput socket: Face Count\n\n\no_instance_count\nOutput socket: Instance Count\n\n\no_layer_count\nOutput socket: Layer Count\n\n\no_point_count\nOutput socket: Point Count\n\n\no_spline_count\nOutput socket: Spline Count\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.attribute.RemoveNamedAttribute(\n    geometry=None,\n    pattern_mode='Exact',\n    name='',\n)\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_pattern_mode\nInput socket: Pattern Mode\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n    *,\n    data_type='FLOAT',\n    domain='POINT',\n)\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_type\n\n\n\ndomain\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_selection\nInput socket: Selection\n\n\ni_value\nInput socket: Value\n\n\nname\n\n\n\nnode\n\n\n\no_geometry\nOutput socket: Geometry\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nboolean\nCreate Store Named Attribute with operation ‘Boolean’.\n\n\nbyte_color\nCreate Store Named Attribute with operation ‘Byte Color’.\n\n\ncolor\nCreate Store Named Attribute with operation ‘Color’.\n\n\nedge\nCreate Store Named Attribute with operation ‘Edge’.\n\n\nface\nCreate Store Named Attribute with operation ‘Face’.\n\n\nface_corner\nCreate Store Named Attribute with operation ‘Face Corner’.\n\n\nfloat\nCreate Store Named Attribute with operation ‘Float’.\n\n\ninstance\nCreate Store Named Attribute with operation ‘Instance’.\n\n\nint8\nCreate Store Named Attribute with operation ‘8-Bit Integer’.\n\n\ninteger\nCreate Store Named Attribute with operation ‘Integer’.\n\n\nlayer\nCreate Store Named Attribute with operation ‘Layer’.\n\n\nmatrix\nCreate Store Named Attribute with operation ‘4x4 Matrix’.\n\n\npoint\nCreate Store Named Attribute with operation ‘Point’.\n\n\nquaternion\nCreate Store Named Attribute with operation ‘Quaternion’.\n\n\nspline\nCreate Store Named Attribute with operation ‘Spline’.\n\n\nvector\nCreate Store Named Attribute with operation ‘Vector’.\n\n\nvector2\nCreate Store Named Attribute with operation ‘2D Vector’.\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute.boolean(\n    geometry=None,\n    selection=True,\n    name='',\n    value=False,\n)\nCreate Store Named Attribute with operation ‘Boolean’.\n\n\n\nnodes.attribute.StoreNamedAttribute.byte_color(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Byte Color’.\n\n\n\nnodes.attribute.StoreNamedAttribute.color(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Color’.\n\n\n\nnodes.attribute.StoreNamedAttribute.edge(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Edge’.\n\n\n\nnodes.attribute.StoreNamedAttribute.face(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Face’.\n\n\n\nnodes.attribute.StoreNamedAttribute.face_corner(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Face Corner’.\n\n\n\nnodes.attribute.StoreNamedAttribute.float(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n)\nCreate Store Named Attribute with operation ‘Float’.\n\n\n\nnodes.attribute.StoreNamedAttribute.instance(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Instance’.\n\n\n\nnodes.attribute.StoreNamedAttribute.int8(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0,\n)\nCreate Store Named Attribute with operation ‘8-Bit Integer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.integer(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0,\n)\nCreate Store Named Attribute with operation ‘Integer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.layer(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Layer’.\n\n\n\nnodes.attribute.StoreNamedAttribute.matrix(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘4x4 Matrix’.\n\n\n\nnodes.attribute.StoreNamedAttribute.point(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Point’.\n\n\n\nnodes.attribute.StoreNamedAttribute.quaternion(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Quaternion’.\n\n\n\nnodes.attribute.StoreNamedAttribute.spline(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Spline’.\n\n\n\nnodes.attribute.StoreNamedAttribute.vector(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘Vector’.\n\n\n\nnodes.attribute.StoreNamedAttribute.vector2(\n    geometry=None,\n    selection=True,\n    name='',\n    value=None,\n)\nCreate Store Named Attribute with operation ‘2D Vector’.",
    "crumbs": [
      "Some functions",
      "nodes.attribute"
    ]
  },
  {
    "objectID": "reference/nodes.color.html",
    "href": "reference/nodes.color.html",
    "title": "nodes.color",
    "section": "",
    "text": "nodes.color\n\n\n\n\n\nName\nDescription\n\n\n\n\nGamma\nApply a gamma correction\n\n\nRgbCurves\nApply color corrections for each color channel\n\n\n\n\n\nnodes.color.Gamma(color=None, gamma=1.0)\nApply a gamma correction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_gamma\nInput socket: Gamma\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.color.RgbCurves(fac=1.0, color=None)\nApply color corrections for each color channel\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_fac\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.color"
    ]
  },
  {
    "objectID": "reference/nodes.color.html#classes",
    "href": "reference/nodes.color.html#classes",
    "title": "nodes.color",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nGamma\nApply a gamma correction\n\n\nRgbCurves\nApply color corrections for each color channel\n\n\n\n\n\nnodes.color.Gamma(color=None, gamma=1.0)\nApply a gamma correction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_gamma\nInput socket: Gamma\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype\n\n\n\n\n\n\n\n\nnodes.color.RgbCurves(fac=1.0, color=None)\nApply color corrections for each color channel\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_fac\nInput socket: Factor\n\n\nname\n\n\n\nnode\n\n\n\no_color\nOutput socket: Color\n\n\ntree\n\n\n\ntype",
    "crumbs": [
      "Some functions",
      "nodes.color"
    ]
  }
]