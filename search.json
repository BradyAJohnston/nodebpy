[
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.geometry\nAuto-generated Blender Geometry Node classes.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#some-functions",
    "href": "reference/index.html#some-functions",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.geometry\nAuto-generated Blender Geometry Node classes.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html",
    "href": "reference/nodes.geometry.html",
    "title": "nodes.geometry",
    "section": "",
    "text": "nodes.geometry\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nDCursor3\nThe scene’s 3D cursor location and rotation\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDialGizmo\nShow a dial gizmo in the viewport for a value\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nGetListItem\nRetrieve a value from a list\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGroup\nGroup node\n\n\nImageInfo\nRetrieve information about an image\n\n\nImageTexture\nSample values from an image texture\n\n\nImportCsv\nImport geometry from an CSV file\n\n\nImportObj\nImport geometry from an OBJ file\n\n\nImportPly\nImport a point cloud from a PLY file\n\n\nImportStl\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVdb\nImport volume data from a .vdb file\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nJoinGeometry\nMerge separately generated geometries into a single one\n\n\nJoinStrings\nCombine any number of input strings\n\n\nLinearGizmo\nShow a linear gizmo in the viewport for a value\n\n\nList\nCreate a list of values\n\n\nListLength\nCount how many items are in a given list\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nPackUvIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToSdfGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUvSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSdfGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSdfGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSdfGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSdfGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSdfGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSdfGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSdfGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nSetId\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTransformGizmo\nShow a transform gizmo in the viewport\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nUvTangent\nGenerate tangent directions based on a UV map\n\n\nUvUnwrap\nGenerate a UV map based on seam edges\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewer\nDisplay the input data in the Spreadsheet Editor\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\nWarning\nCreate custom warnings in node groups\n\n\n\n\n\nnodes.geometry.AccumulateField(\n    value=1.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\n\n\n\n\n\nnodes.geometry.ActiveElement(domain='POINT', **kwargs)\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.AdvectGrid(\n    grid=0.0,\n    velocity=[0.0, 0.0, 0.0],\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    data_type='FLOAT',\n    **kwargs,\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Bake(extend=None, active_index=0, **kwargs)\nCache the incoming data so that it can be used without recomputation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True, **kwargs)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.CameraInfo(camera=None, **kwargs)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\n\n\n\n\n\nnodes.geometry.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None, **kwargs)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\n\n\n\n\n\nnodes.geometry.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfFace(face_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.DCursor3(**kwargs)\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    mode='ALL',\n    domain='POINT',\n    **kwargs,\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.DialGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    up=[0.0, 0.0, 1.0],\n    screen_space=True,\n    radius=1.0,\n    color_id='PRIMARY',\n    **kwargs,\n)\nShow a dial gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_screen_space\nInput socket: Screen Space\n\n\ni_up\nInput socket: Up\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    mode='DENSITY_RANDOM',\n    **kwargs,\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=[0.30000001192092896, 0.30000001192092896, 0.30000001192092896],\n    threshold=0.10000000149011612,\n    **kwargs,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    density=10.0,\n    seed=0,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n    **kwargs,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    domain='POINT',\n    **kwargs,\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.EdgePathsToSelection(\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfCorner(corner_index=0, **kwargs)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.EdgesToFaceGroups(boundary_edges=True, **kwargs)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\n\n\n\n\n\nnodes.geometry.EvaluateAtIndex(\n    value=0.0,\n    index=0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.EvaluateOnDomain(\n    value=0.0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.FaceOfCorner(corner_index=0, **kwargs)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\n\n\n\n\n\nnodes.geometry.FaceSet(**kwargs)\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\n\n\n\n\n\nnodes.geometry.FieldAverage(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\n\n\n\n\n\nnodes.geometry.FieldMinMax(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.FieldToGrid(\n    topology=0.0,\n    extend=None,\n    active_index=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ni_topology\nInput socket: Topology\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.FieldVariance(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True, **kwargs)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ForEachGeometryElementOutput(\n    extend_main=None,\n    generation_0=None,\n    extend_generation=None,\n    active_input_index=0,\n    active_generation_index=0,\n    active_main_index=0,\n    domain='POINT',\n    inspection_index=0,\n    **kwargs,\n)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_extend_generation\nInput socket:\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\no_extend_generation\nOutput socket:\n\n\no_generation_0\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    target_element='FACES',\n    **kwargs,\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.geometry.GeometryToInstance(geometry=None, **kwargs)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.GetListItem(list=0.0, index=0, data_type='FLOAT', **kwargs)\nRetrieve a value from a list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_list\nInput socket: List\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.GetNamedGrid(\n    volume=None,\n    name='',\n    remove=True,\n    data_type='FLOAT',\n    **kwargs,\n)\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.GridCurl(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_curl\nOutput socket: Curl\n\n\n\n\n\n\n\nnodes.geometry.GridDivergence(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_divergence\nOutput socket: Divergence\n\n\n\n\n\n\n\nnodes.geometry.GridGradient(grid=0.0, **kwargs)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_gradient\nOutput socket: Gradient\n\n\n\n\n\n\n\nnodes.geometry.GridInfo(grid=0.0, data_type='FLOAT', **kwargs)\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.GridLaplacian(grid=0.0, **kwargs)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_laplacian\nOutput socket: Laplacian\n\n\n\n\n\n\n\nnodes.geometry.Group(**kwargs)\nGroup node\n\n\n\nnodes.geometry.ImageInfo(image=None, frame=0, **kwargs)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\n\n\n\n\n\nnodes.geometry.ImageTexture(\n    image=None,\n    vector=[0.0, 0.0, 0.0],\n    frame=0,\n    interpolation='Linear',\n    extension='REPEAT',\n    **kwargs,\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.geometry.ImportCsv(path='', delimiter=',', **kwargs)\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\n\n\n\n\n\nnodes.geometry.ImportObj(path='', **kwargs)\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ImportPly(path='', **kwargs)\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportStl(path='', **kwargs)\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportText(path='', **kwargs)\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.ImportVdb(path='', **kwargs)\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.IndexOfNearest(position=[0.0, 0.0, 0.0], group_id=0, **kwargs)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.InstanceTransform(**kwargs)\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    **kwargs,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.IsViewport(**kwargs)\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\n\n\n\n\n\nnodes.geometry.JoinGeometry(geometry=None, **kwargs)\nMerge separately generated geometries into a single one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.JoinStrings(delimiter='', strings='', **kwargs)\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.LinearGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    direction=[0.0, 0.0, 1.0],\n    color_id='PRIMARY',\n    draw_style='ARROW',\n    **kwargs,\n)\nShow a linear gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_position\nInput socket: Position\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.List(count=1, value=0.0, data_type='FLOAT', **kwargs)\nCreate a list of values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_value\nInput socket: Value\n\n\no_list\nOutput socket: List\n\n\n\n\n\n\n\nnodes.geometry.ListLength(list=0.0, data_type='FLOAT', **kwargs)\nCount how many items are in a given list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_list\nInput socket: List\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None, **kwargs)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.0010000000474974513,\n    **kwargs,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    mode='MERGE_BY_NAME',\n    **kwargs,\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.MousePosition(**kwargs)\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\n\n\n\n\n\nnodes.geometry.ObjectInfo(\n    object=None,\n    as_instance=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.OffsetCornerInFace(corner_index=0, offset=0, **kwargs)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\no_corner_index\nOutput socket: Corner Index\n\n\n\n\n\n\n\nnodes.geometry.PackUvIslands(\n    uv=[0.0, 0.0, 0.0],\n    selection=True,\n    margin=0.0010000000474974513,\n    rotate=True,\n    method='Bounding Box',\n    **kwargs,\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.Points(\n    count=1,\n    position=[0.0, 0.0, 0.0],\n    radius=0.10000000149011612,\n    **kwargs,\n)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.PointsToSdfGrid(\n    points=None,\n    radius=0.5,\n    voxel_size=0.30000001192092896,\n    **kwargs,\n)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True, **kwargs)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    radius=0.5,\n    **kwargs,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.009999999776482582,\n    data_type='FLOAT',\n    **kwargs,\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=[0.0, 0.0, 0.0],\n    ray_direction=[0.0, 0.0, -1.0],\n    ray_length=100.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n    **kwargs,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None, **kwargs)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=[0.0, 0.0, 0.0],\n    pivot_point=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SampleGrid(\n    grid=0.0,\n    position=[0.0, 0.0, 0.0],\n    interpolation='Trilinear',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleGridIndex(\n    grid=0.0,\n    x=0,\n    y=0,\n    z=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n    **kwargs,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=[0.0, 0.0, 0.0],\n    domain='POINT',\n    **kwargs,\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleUvSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=[0.0, 0.0, 0.0],\n    sample_uv=[0.0, 0.0, 0.0],\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=[0.0, 0.0, 0.0],\n    scale_mode='Uniform',\n    axis=[1.0, 0.0, 0.0],\n    domain='FACE',\n    **kwargs,\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=[1.0, 1.0, 1.0],\n    center=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SdfGridBoolean(\n    grid_1=0.0,\n    grid_2=0.0,\n    operation='DIFFERENCE',\n    **kwargs,\n)\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\nunion\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SdfGridBoolean.difference(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.SdfGridBoolean.intersect(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.SdfGridBoolean.union(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SdfGridFillet(grid=0.0, iterations=1, **kwargs)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridLaplacian(grid=0.0, iterations=1, **kwargs)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMean(grid=0.0, width=1, iterations=1, **kwargs)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMeanCurvature(grid=0.0, iterations=1, **kwargs)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMedian(grid=0.0, width=1, iterations=1, **kwargs)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridOffset(grid=0.0, distance=0.10000000149011612, **kwargs)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Selection(**kwargs)\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\no_float\nOutput socket: Float\n\n\n\n\n\n\n\nnodes.geometry.SelfObject(**kwargs)\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\no_self_object\nOutput socket: Self Object\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None, **kwargs)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    **kwargs,\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0, **kwargs)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='', **kwargs)\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=[1.0, 1.0, 1.0, 1.0],\n    opacity=1.0,\n    mode='STROKE',\n    **kwargs,\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(\n    grease_pencil=None,\n    depth_order='2D',\n    **kwargs,\n)\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n    **kwargs,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGridBackground(\n    grid=0.0,\n    background=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SetGridTransform(\n    grid=0.0,\n    transform=None,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\n\n\n\n\n\nnodes.geometry.SetId(geometry=None, selection=True, id=0, **kwargs)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n    **kwargs,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(\n    geometry=None,\n    selection=True,\n    material=None,\n    **kwargs,\n)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(\n    geometry=None,\n    selection=True,\n    material_index=0,\n    **kwargs,\n)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetPointRadius(\n    points=None,\n    selection=True,\n    radius=0.05000000074505806,\n    **kwargs,\n)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    selection_type='BOOLEAN',\n    **kwargs,\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    domain='FACE',\n    **kwargs,\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(\n    geometry=None,\n    selection=True,\n    cyclic=False,\n    **kwargs,\n)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(\n    geometry=None,\n    selection=True,\n    resolution=12,\n    **kwargs,\n)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    domain='POINT',\n    **kwargs,\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SplineLength(**kwargs)\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.geometry.SplineParameter(**kwargs)\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True, **kwargs)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    domain='POINT',\n    **kwargs,\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.StoreNamedGrid(\n    volume=None,\n    name='',\n    grid=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n    **kwargs,\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    input_type='GEOMETRY',\n    **kwargs,\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\no_output\nOutput socket: Output\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    transform=None,\n    **kwargs,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.TransformGizmo(\n    value=None,\n    position=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    use_translation_x=False,\n    use_translation_y=False,\n    use_translation_z=False,\n    use_rotation_x=False,\n    use_rotation_y=False,\n    use_rotation_z=False,\n    use_scale_x=False,\n    use_scale_y=False,\n    use_scale_z=False,\n    **kwargs,\n)\nShow a transform gizmo in the viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n    **kwargs,\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.UvTangent(method='Exact', uv=[0.0, 0.0], **kwargs)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.geometry.UvUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.0010000000474974513,\n    fill_holes=True,\n    method='Angle Based',\n    **kwargs,\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.VertexOfCorner(corner_index=0, **kwargs)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\n\n\n\n\n\nnodes.geometry.Viewer(\n    extend=None,\n    ui_shortcut=0,\n    active_index=0,\n    domain='AUTO',\n    **kwargs,\n)\nDisplay the input data in the Spreadsheet Editor\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\n\n\n\n\n\nnodes.geometry.ViewportTransform(**kwargs)\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\n\n\n\n\n\nnodes.geometry.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=[-1.0, -1.0, -1.0],\n    max=[1.0, 1.0, 1.0],\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n    **kwargs,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.VoxelizeGrid(grid=0.0, data_type='FLOAT', **kwargs)\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Warning(show=True, message='', warning_type='ERROR', **kwargs)\nCreate custom warnings in node groups\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_message\nInput socket: Message\n\n\ni_show\nInput socket: Show\n\n\no_show\nOutput socket: Show",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html#classes",
    "href": "reference/nodes.geometry.html#classes",
    "title": "nodes.geometry",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nDCursor3\nThe scene’s 3D cursor location and rotation\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDialGizmo\nShow a dial gizmo in the viewport for a value\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nGetListItem\nRetrieve a value from a list\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGroup\nGroup node\n\n\nImageInfo\nRetrieve information about an image\n\n\nImageTexture\nSample values from an image texture\n\n\nImportCsv\nImport geometry from an CSV file\n\n\nImportObj\nImport geometry from an OBJ file\n\n\nImportPly\nImport a point cloud from a PLY file\n\n\nImportStl\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVdb\nImport volume data from a .vdb file\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nJoinGeometry\nMerge separately generated geometries into a single one\n\n\nJoinStrings\nCombine any number of input strings\n\n\nLinearGizmo\nShow a linear gizmo in the viewport for a value\n\n\nList\nCreate a list of values\n\n\nListLength\nCount how many items are in a given list\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nPackUvIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToSdfGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUvSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSdfGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSdfGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSdfGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSdfGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSdfGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSdfGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSdfGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nSetId\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTransformGizmo\nShow a transform gizmo in the viewport\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nUvTangent\nGenerate tangent directions based on a UV map\n\n\nUvUnwrap\nGenerate a UV map based on seam edges\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewer\nDisplay the input data in the Spreadsheet Editor\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\nWarning\nCreate custom warnings in node groups\n\n\n\n\n\nnodes.geometry.AccumulateField(\n    value=1.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\n\n\n\n\n\nnodes.geometry.ActiveElement(domain='POINT', **kwargs)\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.AdvectGrid(\n    grid=0.0,\n    velocity=[0.0, 0.0, 0.0],\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    data_type='FLOAT',\n    **kwargs,\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Bake(extend=None, active_index=0, **kwargs)\nCache the incoming data so that it can be used without recomputation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True, **kwargs)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.CameraInfo(camera=None, **kwargs)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\n\n\n\n\n\nnodes.geometry.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None, **kwargs)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\n\n\n\n\n\nnodes.geometry.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfFace(face_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.DCursor3(**kwargs)\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    mode='ALL',\n    domain='POINT',\n    **kwargs,\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.DialGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    up=[0.0, 0.0, 1.0],\n    screen_space=True,\n    radius=1.0,\n    color_id='PRIMARY',\n    **kwargs,\n)\nShow a dial gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_screen_space\nInput socket: Screen Space\n\n\ni_up\nInput socket: Up\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    mode='DENSITY_RANDOM',\n    **kwargs,\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=[0.30000001192092896, 0.30000001192092896, 0.30000001192092896],\n    threshold=0.10000000149011612,\n    **kwargs,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    density=10.0,\n    seed=0,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n    **kwargs,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    domain='POINT',\n    **kwargs,\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.EdgePathsToSelection(\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfCorner(corner_index=0, **kwargs)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.EdgesToFaceGroups(boundary_edges=True, **kwargs)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\n\n\n\n\n\nnodes.geometry.EvaluateAtIndex(\n    value=0.0,\n    index=0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.EvaluateOnDomain(\n    value=0.0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.FaceOfCorner(corner_index=0, **kwargs)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\n\n\n\n\n\nnodes.geometry.FaceSet(**kwargs)\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\n\n\n\n\n\nnodes.geometry.FieldAverage(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\n\n\n\n\n\nnodes.geometry.FieldMinMax(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.FieldToGrid(\n    topology=0.0,\n    extend=None,\n    active_index=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ni_topology\nInput socket: Topology\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.FieldVariance(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True, **kwargs)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ForEachGeometryElementOutput(\n    extend_main=None,\n    generation_0=None,\n    extend_generation=None,\n    active_input_index=0,\n    active_generation_index=0,\n    active_main_index=0,\n    domain='POINT',\n    inspection_index=0,\n    **kwargs,\n)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_extend_generation\nInput socket:\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\no_extend_generation\nOutput socket:\n\n\no_generation_0\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    target_element='FACES',\n    **kwargs,\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.geometry.GeometryToInstance(geometry=None, **kwargs)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.GetListItem(list=0.0, index=0, data_type='FLOAT', **kwargs)\nRetrieve a value from a list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_list\nInput socket: List\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.GetNamedGrid(\n    volume=None,\n    name='',\n    remove=True,\n    data_type='FLOAT',\n    **kwargs,\n)\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.GridCurl(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_curl\nOutput socket: Curl\n\n\n\n\n\n\n\nnodes.geometry.GridDivergence(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_divergence\nOutput socket: Divergence\n\n\n\n\n\n\n\nnodes.geometry.GridGradient(grid=0.0, **kwargs)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_gradient\nOutput socket: Gradient\n\n\n\n\n\n\n\nnodes.geometry.GridInfo(grid=0.0, data_type='FLOAT', **kwargs)\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.GridLaplacian(grid=0.0, **kwargs)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_laplacian\nOutput socket: Laplacian\n\n\n\n\n\n\n\nnodes.geometry.Group(**kwargs)\nGroup node\n\n\n\nnodes.geometry.ImageInfo(image=None, frame=0, **kwargs)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\n\n\n\n\n\nnodes.geometry.ImageTexture(\n    image=None,\n    vector=[0.0, 0.0, 0.0],\n    frame=0,\n    interpolation='Linear',\n    extension='REPEAT',\n    **kwargs,\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.geometry.ImportCsv(path='', delimiter=',', **kwargs)\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\n\n\n\n\n\nnodes.geometry.ImportObj(path='', **kwargs)\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ImportPly(path='', **kwargs)\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportStl(path='', **kwargs)\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportText(path='', **kwargs)\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.ImportVdb(path='', **kwargs)\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.IndexOfNearest(position=[0.0, 0.0, 0.0], group_id=0, **kwargs)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.InstanceTransform(**kwargs)\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    **kwargs,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.IsViewport(**kwargs)\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\n\n\n\n\n\nnodes.geometry.JoinGeometry(geometry=None, **kwargs)\nMerge separately generated geometries into a single one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.JoinStrings(delimiter='', strings='', **kwargs)\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.LinearGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    direction=[0.0, 0.0, 1.0],\n    color_id='PRIMARY',\n    draw_style='ARROW',\n    **kwargs,\n)\nShow a linear gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_position\nInput socket: Position\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.List(count=1, value=0.0, data_type='FLOAT', **kwargs)\nCreate a list of values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_value\nInput socket: Value\n\n\no_list\nOutput socket: List\n\n\n\n\n\n\n\nnodes.geometry.ListLength(list=0.0, data_type='FLOAT', **kwargs)\nCount how many items are in a given list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_list\nInput socket: List\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None, **kwargs)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.0010000000474974513,\n    **kwargs,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    mode='MERGE_BY_NAME',\n    **kwargs,\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.MousePosition(**kwargs)\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\n\n\n\n\n\nnodes.geometry.ObjectInfo(\n    object=None,\n    as_instance=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.OffsetCornerInFace(corner_index=0, offset=0, **kwargs)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\no_corner_index\nOutput socket: Corner Index\n\n\n\n\n\n\n\nnodes.geometry.PackUvIslands(\n    uv=[0.0, 0.0, 0.0],\n    selection=True,\n    margin=0.0010000000474974513,\n    rotate=True,\n    method='Bounding Box',\n    **kwargs,\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.Points(\n    count=1,\n    position=[0.0, 0.0, 0.0],\n    radius=0.10000000149011612,\n    **kwargs,\n)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.PointsToSdfGrid(\n    points=None,\n    radius=0.5,\n    voxel_size=0.30000001192092896,\n    **kwargs,\n)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True, **kwargs)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    radius=0.5,\n    **kwargs,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.009999999776482582,\n    data_type='FLOAT',\n    **kwargs,\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=[0.0, 0.0, 0.0],\n    ray_direction=[0.0, 0.0, -1.0],\n    ray_length=100.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n    **kwargs,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None, **kwargs)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=[0.0, 0.0, 0.0],\n    pivot_point=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SampleGrid(\n    grid=0.0,\n    position=[0.0, 0.0, 0.0],\n    interpolation='Trilinear',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleGridIndex(\n    grid=0.0,\n    x=0,\n    y=0,\n    z=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n    **kwargs,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=[0.0, 0.0, 0.0],\n    domain='POINT',\n    **kwargs,\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleUvSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=[0.0, 0.0, 0.0],\n    sample_uv=[0.0, 0.0, 0.0],\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=[0.0, 0.0, 0.0],\n    scale_mode='Uniform',\n    axis=[1.0, 0.0, 0.0],\n    domain='FACE',\n    **kwargs,\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=[1.0, 1.0, 1.0],\n    center=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SdfGridBoolean(\n    grid_1=0.0,\n    grid_2=0.0,\n    operation='DIFFERENCE',\n    **kwargs,\n)\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\nunion\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SdfGridBoolean.difference(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.SdfGridBoolean.intersect(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.SdfGridBoolean.union(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SdfGridFillet(grid=0.0, iterations=1, **kwargs)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridLaplacian(grid=0.0, iterations=1, **kwargs)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMean(grid=0.0, width=1, iterations=1, **kwargs)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMeanCurvature(grid=0.0, iterations=1, **kwargs)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridMedian(grid=0.0, width=1, iterations=1, **kwargs)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SdfGridOffset(grid=0.0, distance=0.10000000149011612, **kwargs)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Selection(**kwargs)\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\no_float\nOutput socket: Float\n\n\n\n\n\n\n\nnodes.geometry.SelfObject(**kwargs)\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\no_self_object\nOutput socket: Self Object\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None, **kwargs)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    **kwargs,\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0, **kwargs)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='', **kwargs)\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=[1.0, 1.0, 1.0, 1.0],\n    opacity=1.0,\n    mode='STROKE',\n    **kwargs,\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(\n    grease_pencil=None,\n    depth_order='2D',\n    **kwargs,\n)\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n    **kwargs,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGridBackground(\n    grid=0.0,\n    background=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SetGridTransform(\n    grid=0.0,\n    transform=None,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\n\n\n\n\n\nnodes.geometry.SetId(geometry=None, selection=True, id=0, **kwargs)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n    **kwargs,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(\n    geometry=None,\n    selection=True,\n    material=None,\n    **kwargs,\n)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(\n    geometry=None,\n    selection=True,\n    material_index=0,\n    **kwargs,\n)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetPointRadius(\n    points=None,\n    selection=True,\n    radius=0.05000000074505806,\n    **kwargs,\n)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    selection_type='BOOLEAN',\n    **kwargs,\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    domain='FACE',\n    **kwargs,\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(\n    geometry=None,\n    selection=True,\n    cyclic=False,\n    **kwargs,\n)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(\n    geometry=None,\n    selection=True,\n    resolution=12,\n    **kwargs,\n)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    domain='POINT',\n    **kwargs,\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SplineLength(**kwargs)\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.geometry.SplineParameter(**kwargs)\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True, **kwargs)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    domain='POINT',\n    **kwargs,\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.StoreNamedGrid(\n    volume=None,\n    name='',\n    grid=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n    **kwargs,\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    input_type='GEOMETRY',\n    **kwargs,\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\no_output\nOutput socket: Output\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    transform=None,\n    **kwargs,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.TransformGizmo(\n    value=None,\n    position=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    use_translation_x=False,\n    use_translation_y=False,\n    use_translation_z=False,\n    use_rotation_x=False,\n    use_rotation_y=False,\n    use_rotation_z=False,\n    use_scale_x=False,\n    use_scale_y=False,\n    use_scale_z=False,\n    **kwargs,\n)\nShow a transform gizmo in the viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n    **kwargs,\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.UvTangent(method='Exact', uv=[0.0, 0.0], **kwargs)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.geometry.UvUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.0010000000474974513,\n    fill_holes=True,\n    method='Angle Based',\n    **kwargs,\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.VertexOfCorner(corner_index=0, **kwargs)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\n\n\n\n\n\nnodes.geometry.Viewer(\n    extend=None,\n    ui_shortcut=0,\n    active_index=0,\n    domain='AUTO',\n    **kwargs,\n)\nDisplay the input data in the Spreadsheet Editor\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\n\n\n\n\n\nnodes.geometry.ViewportTransform(**kwargs)\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\n\n\n\n\n\nnodes.geometry.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=[-1.0, -1.0, -1.0],\n    max=[1.0, 1.0, 1.0],\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n    **kwargs,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.VoxelizeGrid(grid=0.0, data_type='FLOAT', **kwargs)\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Warning(show=True, message='', warning_type='ERROR', **kwargs)\nCreate custom warnings in node groups\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_message\nInput socket: Message\n\n\ni_show\nInput socket: Show\n\n\no_show\nOutput socket: Show",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  }
]