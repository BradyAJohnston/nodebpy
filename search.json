[
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "What happens when we add nodes?",
    "section": "",
    "text": "from nodebpy import TreeBuilder, nodes as n, sockets as s"
  },
  {
    "objectID": "introduction.html#adding-nodes",
    "href": "introduction.html#adding-nodes",
    "title": "What happens when we add nodes?",
    "section": "Adding Nodes",
    "text": "Adding Nodes\nAdding nodes must be done inside of a context. We enter a context using the with keyword. While inside of this context, whenever you call a node class (n.SetPosition()) a node of that type will be added to the current tree.\nThis first example creates a new tree and adds two new nodes, linking the Set Position node into the Transform Geometry node. The output and input sockets for each are inferred based on simple heuristics around socket type and order.\n\nwith TreeBuilder(\"NewTree\") as tree:\n    n.SetPosition() &gt;&gt; n.TransformGeometry()\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"SetPosition\"):::geometry-node\n    N1(\"Transform\"):::geometry-node\n    N0 --&gt;|\"Geometry&gt;&gt;Geometry\"| N1\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\nThese nodes can be saved as variables for re-use later in the node tree as well. After instantiating a class you can specify the input and output sockets using the i_* and o_* properties on the class.\nThese two approaches are equivalent:\n\nIndividual Socket AccessUsing Arguments to Class\n\n\n\nwith TreeBuilder(\"AnotherTree\") as tree:\n    pos = n.SetPosition()\n\n    n.Position() * 0.5 &gt;&gt; pos.i_position\n    n.Vector() &gt;&gt; pos.i_offset\n\n\n\n\nwith TreeBuilder(\"AnotherAnotherTree\") as tree:\n    n.SetPosition(\n        offset = n.Vector(),\n        position = n.Position() * 0.5\n    )\n\n\n\n\n\n\n\n\n\n\n\ngraph LR\n    N0(\"InputPosition\"):::input-node\n    N1(\"VectorMath&lt;br/&gt;&lt;small&gt;×0.5&lt;/small&gt;\"):::vector-node\n    N2(\"InputVector\"):::input-node\n    N3(\"SetPosition\"):::geometry-node\n    N0 --&gt;|\"Position&gt;&gt;Vector\"| N1\n    N1 --&gt;|\"Vector&gt;&gt;Position\"| N3\n    N2 --&gt;|\"Vector&gt;&gt;Offset\"| N3\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px"
  },
  {
    "objectID": "introduction.html#node-input-sockets",
    "href": "introduction.html#node-input-sockets",
    "title": "What happens when we add nodes?",
    "section": "Node Input Sockets",
    "text": "Node Input Sockets\nThe socket interface nodes define what values / sockets are available as inputs for the node tree.\nWe define them in a similar way to the socekts themselves, using context with the tree.inputs and tree.outputs and adding sockets with the s.SocketGeometry().\n\nwith TreeBuilder(\"NewTree\") as tree:\n    with tree.inputs:\n        geom_inputs = [s.SocketGeometry(f\"Geometry_{i}\") for i in range(5)]\n\n    with tree.outputs:\n        n.JoinGeometry(geom_inputs) &gt;&gt; s.SocketGeometry(\"The Output Socket\")\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"JoinGeometry\"):::geometry-node\n    N2(\"NodeGroupOutput\"):::default-node\n    N0 --&gt;|\"Geometry_4&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_3&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_2&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_1&gt;&gt;Geometry\"| N1\n    N0 --&gt;|\"Geometry_0&gt;&gt;Geometry\"| N1\n    N1 --&gt;|\"Geometry&gt;&gt;The Output Socket\"| N2\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\n\nwith TreeBuilder() as tree:\n    with tree.inputs:\n        count = s.SocketInt(\"Count\", 10)\n\n    with tree.outputs:\n        output = s.SocketGeometry()\n\n    (\n        count\n        &gt;&gt; n.Points(position=n.RandomValue.vector(min=(-0.1,-0.1,-0.2)))\n        &gt;&gt; output\n    )\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"RandomValue&lt;br/&gt;&lt;small&gt;(-0.1,-0.1,-0.2) seed:1&lt;/small&gt;\"):::converter-node\n    N2(\"Points\"):::geometry-node\n    N3(\"NodeGroupOutput\"):::default-node\n    N1 --&gt;|\"Value&gt;&gt;Position\"| N2\n    N0 --&gt;|\"Count&gt;&gt;Count\"| N2\n    N2 --&gt;|\"Points&gt;&gt;Geometry\"| N3\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px\n\n\n\n\n\n\n\n\n\nwith TreeBuilder() as tree:\n    with tree.inputs:\n        count = s.SocketInt(\"Count\", 10)\n\n    with tree.outputs:\n        output = s.SocketGeometry()\n\n    (\n        count\n        &gt;&gt; n.Points(position=n.RandomValue.vector() * 0.5 * n.Position())\n        &gt;&gt; output\n    )\n\ntree\n\n\n\n\n\n\ngraph LR\n    N0(\"NodeGroupInput\"):::default-node\n    N1(\"RandomValue&lt;br/&gt;&lt;small&gt;seed:1&lt;/small&gt;\"):::converter-node\n    N2(\"VectorMath&lt;br/&gt;&lt;small&gt;×0.5&lt;/small&gt;\"):::vector-node\n    N3(\"InputPosition\"):::input-node\n    N4(\"VectorMath\"):::vector-node\n    N5(\"Points\"):::geometry-node\n    N6(\"NodeGroupOutput\"):::default-node\n    N1 --&gt;|\"Value&gt;&gt;Vector\"| N2\n    N2 --&gt;|\"Vector&gt;&gt;Vector\"| N4\n    N3 --&gt;|\"Position&gt;&gt;Vector\"| N4\n    N4 --&gt;|\"Vector&gt;&gt;Position\"| N5\n    N0 --&gt;|\"Count&gt;&gt;Count\"| N5\n    N5 --&gt;|\"Points&gt;&gt;Geometry\"| N6\n\n    classDef geometry-node fill:#e8f5f1,stroke:#3a7c49,stroke-width:2px\n    classDef converter-node fill:#e6f1f7,stroke:#246283,stroke-width:2px\n    classDef vector-node fill:#e9e9f5,stroke:#3C3C83,stroke-width:2px\n    classDef texture-node fill:#fef3e6,stroke:#E66800,stroke-width:2px\n    classDef shader-node fill:#fef0eb,stroke:#e67c52,stroke-width:2px\n    classDef input-node fill:#f1f8ed,stroke:#7fb069,stroke-width:2px\n    classDef output-node fill:#faf0ed,stroke:#c97659,stroke-width:2px\n    classDef default-node fill:#f0f0f0,stroke:#5a5a5a,stroke-width:2px"
  },
  {
    "objectID": "reference/nodes.attribute.html",
    "href": "reference/nodes.attribute.html",
    "title": "nodes.attribute",
    "section": "",
    "text": "nodes.attribute\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nAttributeStatistic\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\nBlurAttribute\nMix attribute values of neighboring elements\n\n\nDomainSize\nRetrieve the number of elements in a geometry for each attribute domain\n\n\nNamedAttribute\nRetrieve the data of a specified attribute\n\n\nRemoveNamedAttribute\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\nStoreNamedAttribute\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nnodes.attribute.AttributeStatistic(\n    geometry=None,\n    selection=True,\n    attribute=0.0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_max\nOutput socket: Max\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\no_min\nOutput socket: Min\n\n\no_range\nOutput socket: Range\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_sum\nOutput socket: Sum\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.attribute.BlurAttribute(\n    value=0.0,\n    iterations=1,\n    weight=1.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nMix attribute values of neighboring elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_value\nInput socket: Value\n\n\ni_weight\nInput socket: Weight\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.attribute.DomainSize(geometry=None, component='MESH', **kwargs)\nRetrieve the number of elements in a geometry for each attribute domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_edge_count\nOutput socket: Edge Count\n\n\no_face_corner_count\nOutput socket: Face Corner Count\n\n\no_face_count\nOutput socket: Face Count\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.attribute.NamedAttribute(name='', data_type='FLOAT', **kwargs)\nRetrieve the data of a specified attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\no_attribute\nOutput socket: Attribute\n\n\no_exists\nOutput socket: Exists\n\n\n\n\n\n\n\nnodes.attribute.RemoveNamedAttribute(\n    geometry=None,\n    pattern_mode='Exact',\n    name='',\n    **kwargs,\n)\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_pattern_mode\nInput socket: Pattern Mode\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_selection\nInput socket: Selection\n\n\ni_value\nInput socket: Value\n\n\no_geometry\nOutput socket: Geometry",
    "crumbs": [
      "Some functions",
      "nodes.attribute"
    ]
  },
  {
    "objectID": "reference/nodes.attribute.html#classes",
    "href": "reference/nodes.attribute.html#classes",
    "title": "nodes.attribute",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAttributeStatistic\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\nBlurAttribute\nMix attribute values of neighboring elements\n\n\nDomainSize\nRetrieve the number of elements in a geometry for each attribute domain\n\n\nNamedAttribute\nRetrieve the data of a specified attribute\n\n\nRemoveNamedAttribute\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\nStoreNamedAttribute\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nnodes.attribute.AttributeStatistic(\n    geometry=None,\n    selection=True,\n    attribute=0.0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate statistics about a data set from a field evaluated on a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_max\nOutput socket: Max\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\no_min\nOutput socket: Min\n\n\no_range\nOutput socket: Range\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_sum\nOutput socket: Sum\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.attribute.BlurAttribute(\n    value=0.0,\n    iterations=1,\n    weight=1.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nMix attribute values of neighboring elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_value\nInput socket: Value\n\n\ni_weight\nInput socket: Weight\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.attribute.DomainSize(geometry=None, component='MESH', **kwargs)\nRetrieve the number of elements in a geometry for each attribute domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_edge_count\nOutput socket: Edge Count\n\n\no_face_corner_count\nOutput socket: Face Corner Count\n\n\no_face_count\nOutput socket: Face Count\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.attribute.NamedAttribute(name='', data_type='FLOAT', **kwargs)\nRetrieve the data of a specified attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\no_attribute\nOutput socket: Attribute\n\n\no_exists\nOutput socket: Exists\n\n\n\n\n\n\n\nnodes.attribute.RemoveNamedAttribute(\n    geometry=None,\n    pattern_mode='Exact',\n    name='',\n    **kwargs,\n)\nDelete an attribute with a specified name from a geometry. Typically used to optimize performance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_pattern_mode\nInput socket: Pattern Mode\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.attribute.StoreNamedAttribute(\n    geometry=None,\n    selection=True,\n    name='',\n    value=0.0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nStore the result of a field on a geometry as an attribute with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\ni_selection\nInput socket: Selection\n\n\ni_value\nInput socket: Value\n\n\no_geometry\nOutput socket: Geometry",
    "crumbs": [
      "Some functions",
      "nodes.attribute"
    ]
  },
  {
    "objectID": "reference/nodes.html",
    "href": "reference/nodes.html",
    "title": "nodes",
    "section": "",
    "text": "nodes\nnodes\nAuto-generated geometry node classes."
  },
  {
    "objectID": "reference/nodes.utilities.html",
    "href": "reference/nodes.utilities.html",
    "title": "nodes.utilities",
    "section": "",
    "text": "nodes.utilities\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nAlignEulerToVector\nOrient an Euler rotation along the given direction\n\n\nAlignRotationToVector\nOrient a rotation along the given direction\n\n\nAxesToRotation\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\nAxisAngleToRotation\nBuild a rotation from an axis and a rotation around that axis\n\n\nBitMath\nPerform bitwise operations on 32-bit integers\n\n\nClamp\nClamp a value between a minimum and a maximum\n\n\nCombineColor\nCombine four channels into a single color, based on a particular color model\n\n\nCombineMatrix\nConstruct a 4x4 matrix from its individual values\n\n\nCombineTransform\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\nCompare\nPerform a comparison operation on the two given inputs\n\n\nEulerToRotation\nBuild a rotation from separate angles around each axis\n\n\nFindInString\nFind the number of times a given string occurs in another string and the position of the first match\n\n\nFloatToInteger\nConvert the given floating-point number to an integer, with a choice of methods\n\n\nFormatString\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\nGamma\nApply a gamma correction\n\n\nHashValue\nGenerate a randomized integer using the given input value as a seed\n\n\nIntegerMath\nPerform various math operations on the given integer inputs\n\n\nInvertMatrix\nCompute the inverse of the given matrix, if one exists\n\n\nInvertRotation\nCompute the inverse of the given rotation\n\n\nMapRange\nRemap a value from a range to a target range\n\n\nMatchString\nCheck if a given string exists within another string\n\n\nMatrixDeterminant\nCompute the determinant of the given matrix\n\n\nMultiplyMatrices\nPerform a matrix multiplication on two input matrices\n\n\nProjectPoint\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\nQuaternionToRotation\nBuild a rotation from quaternion components\n\n\nReplaceString\nReplace a given string segment with another\n\n\nRotateEuler\nApply a secondary Euler rotation to a given Euler rotation\n\n\nRotateRotation\nApply a secondary rotation to a given rotation value\n\n\nRotateVector\nApply a rotation to a given vector\n\n\nRotationToAxisAngle\nConvert a rotation to axis angle components\n\n\nRotationToEuler\nConvert a standard rotation value to an Euler rotation\n\n\nRotationToQuaternion\nRetrieve the quaternion components representing a rotation\n\n\nSeparateColor\nSplit a color into separate channels, based on a particular color model\n\n\nSeparateMatrix\nSplit a 4x4 matrix into its individual values\n\n\nSeparateTransform\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\nSliceString\nExtract a string segment from a larger string\n\n\nStringLength\nOutput the number of characters in the given string\n\n\nStringToValue\nDerive a numeric value from a given string representation\n\n\nTransformDirection\nApply a transformation matrix (excluding translation) to the given vector\n\n\nTransformPoint\nApply a transformation matrix to the given vector\n\n\nTransposeMatrix\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\nValueToString\nGenerate a string representation of the given input value\n\n\n\n\n\nnodes.utilities.AlignEulerToVector(\n    rotation=[0.0, 0.0, 0.0],\n    factor=1.0,\n    vector=[0.0, 0.0, 1.0],\n    axis='X',\n    pivot_axis='AUTO',\n    **kwargs,\n)\nOrient an Euler rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AlignRotationToVector(\n    rotation=[0.0, 0.0, 0.0],\n    factor=1.0,\n    vector=[0.0, 0.0, 1.0],\n    axis='Z',\n    pivot_axis='AUTO',\n    **kwargs,\n)\nOrient a rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AxesToRotation(\n    primary_axis=[0.0, 0.0, 1.0],\n    secondary_axis=[1.0, 0.0, 0.0],\n    primary_axis_axis='Z',\n    secondary_axis_axis='X',\n    **kwargs,\n)\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_primary_axis\nInput socket: Primary Axis\n\n\ni_secondary_axis\nInput socket: Secondary Axis\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AxisAngleToRotation(axis=[0.0, 0.0, 1.0], angle=0.0, **kwargs)\nBuild a rotation from an axis and a rotation around that axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.BitMath(a=0, b=0, operation='AND', **kwargs)\nPerform bitwise operations on 32-bit integers\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nl_and\nCreate Bit Math with operation ‘And’.\n\n\nl_not\nCreate Bit Math with operation ‘Not’.\n\n\nl_or\nCreate Bit Math with operation ‘Or’.\n\n\nrotate\nCreate Bit Math with operation ‘Rotate’.\n\n\nshift\nCreate Bit Math with operation ‘Shift’.\n\n\nxor\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\n\n\nnodes.utilities.BitMath.l_and(a=0, b=0)\nCreate Bit Math with operation ‘And’.\n\n\n\nnodes.utilities.BitMath.l_not(a=0, b=0)\nCreate Bit Math with operation ‘Not’.\n\n\n\nnodes.utilities.BitMath.l_or(a=0, b=0)\nCreate Bit Math with operation ‘Or’.\n\n\n\nnodes.utilities.BitMath.rotate(a=0, b=0)\nCreate Bit Math with operation ‘Rotate’.\n\n\n\nnodes.utilities.BitMath.shift(a=0, b=0)\nCreate Bit Math with operation ‘Shift’.\n\n\n\nnodes.utilities.BitMath.xor(a=0, b=0)\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\n\n\nnodes.utilities.Clamp(\n    value=1.0,\n    min=0.0,\n    max=1.0,\n    clamp_type='MINMAX',\n    **kwargs,\n)\nClamp a value between a minimum and a maximum\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_value\nInput socket: Value\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.CombineColor(\n    red=0.0,\n    green=0.0,\n    blue=0.0,\n    alpha=1.0,\n    mode='RGB',\n    **kwargs,\n)\nCombine four channels into a single color, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_alpha\nInput socket: Alpha\n\n\ni_blue\nInput socket: Blue\n\n\ni_green\nInput socket: Green\n\n\ni_red\nInput socket: Red\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.utilities.CombineMatrix(\n    column_1_row_1=1.0,\n    column_1_row_2=0.0,\n    column_1_row_3=0.0,\n    column_1_row_4=0.0,\n    column_2_row_1=0.0,\n    column_2_row_2=1.0,\n    column_2_row_3=0.0,\n    column_2_row_4=0.0,\n    column_3_row_1=0.0,\n    column_3_row_2=0.0,\n    column_3_row_3=1.0,\n    column_3_row_4=0.0,\n    column_4_row_1=0.0,\n    column_4_row_2=0.0,\n    column_4_row_3=0.0,\n    column_4_row_4=1.0,\n    **kwargs,\n)\nConstruct a 4x4 matrix from its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_column_1_row_1\nInput socket: Column 1 Row 1\n\n\ni_column_1_row_2\nInput socket: Column 1 Row 2\n\n\ni_column_1_row_3\nInput socket: Column 1 Row 3\n\n\ni_column_1_row_4\nInput socket: Column 1 Row 4\n\n\ni_column_2_row_1\nInput socket: Column 2 Row 1\n\n\ni_column_2_row_2\nInput socket: Column 2 Row 2\n\n\ni_column_2_row_3\nInput socket: Column 2 Row 3\n\n\ni_column_2_row_4\nInput socket: Column 2 Row 4\n\n\ni_column_3_row_1\nInput socket: Column 3 Row 1\n\n\ni_column_3_row_2\nInput socket: Column 3 Row 2\n\n\ni_column_3_row_3\nInput socket: Column 3 Row 3\n\n\ni_column_3_row_4\nInput socket: Column 3 Row 4\n\n\ni_column_4_row_1\nInput socket: Column 4 Row 1\n\n\ni_column_4_row_2\nInput socket: Column 4 Row 2\n\n\ni_column_4_row_3\nInput socket: Column 4 Row 3\n\n\ni_column_4_row_4\nInput socket: Column 4 Row 4\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.CombineTransform(\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_translation\nInput socket: Translation\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.utilities.Compare(\n    a=0.0,\n    b=0.0,\n    operation='GREATER_THAN',\n    data_type='FLOAT',\n    mode='ELEMENT',\n    **kwargs,\n)\nPerform a comparison operation on the two given inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrighter\nCreate Compare with operation ‘Brighter’.\n\n\ndarker\nCreate Compare with operation ‘Darker’.\n\n\nequal\nCreate Compare with operation ‘Equal’.\n\n\ngreaterequal\nCreate Compare with operation ‘Greater Than or Equal’.\n\n\ngreaterthan\nCreate Compare with operation ‘Greater Than’.\n\n\nlessequal\nCreate Compare with operation ‘Less Than or Equal’.\n\n\nlessthan\nCreate Compare with operation ‘Less Than’.\n\n\nnotequal\nCreate Compare with operation ‘Not Equal’.\n\n\n\n\n\nnodes.utilities.Compare.brighter(a=0.0, b=0.0)\nCreate Compare with operation ‘Brighter’.\n\n\n\nnodes.utilities.Compare.darker(a=0.0, b=0.0)\nCreate Compare with operation ‘Darker’.\n\n\n\nnodes.utilities.Compare.equal(a=0.0, b=0.0)\nCreate Compare with operation ‘Equal’.\n\n\n\nnodes.utilities.Compare.greaterequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Greater Than or Equal’.\n\n\n\nnodes.utilities.Compare.greaterthan(a=0.0, b=0.0)\nCreate Compare with operation ‘Greater Than’.\n\n\n\nnodes.utilities.Compare.lessequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Less Than or Equal’.\n\n\n\nnodes.utilities.Compare.lessthan(a=0.0, b=0.0)\nCreate Compare with operation ‘Less Than’.\n\n\n\nnodes.utilities.Compare.notequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Not Equal’.\n\n\n\n\n\nnodes.utilities.EulerToRotation(euler=[0.0, 0.0, 0.0], **kwargs)\nBuild a rotation from separate angles around each axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_euler\nInput socket: Euler\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.FindInString(string='', search='', **kwargs)\nFind the number of times a given string occurs in another string and the position of the first match\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_search\nInput socket: Search\n\n\ni_string\nInput socket: String\n\n\no_count\nOutput socket: Count\n\n\no_first_found\nOutput socket: First Found\n\n\n\n\n\n\n\nnodes.utilities.FloatToInteger(float=0.0, rounding_mode='ROUND', **kwargs)\nConvert the given floating-point number to an integer, with a choice of methods\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_float\nInput socket: Float\n\n\no_integer\nOutput socket: Integer\n\n\n\n\n\n\n\nnodes.utilities.FormatString(format='', extend=None, active_index=0, **kwargs)\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_format\nInput socket: Format\n\n\ni_input_socket\nInput socket:\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.Gamma(color=[1.0, 1.0, 1.0, 1.0], gamma=1.0, **kwargs)\nApply a gamma correction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_gamma\nInput socket: Gamma\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.utilities.HashValue(value=0, seed=0, data_type='INT', **kwargs)\nGenerate a randomized integer using the given input value as a seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_seed\nInput socket: Seed\n\n\ni_value\nInput socket: Value\n\n\no_hash\nOutput socket: Hash\n\n\n\n\n\n\n\nnodes.utilities.IntegerMath(value=0, value_001=0, operation='ADD', **kwargs)\nPerform various math operations on the given integer inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Integer Math with operation ‘Absolute’.\n\n\nadd\nCreate Integer Math with operation ‘Add’.\n\n\ndivide\nCreate Integer Math with operation ‘Divide’.\n\n\ndivideceil\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\ndividefloor\nCreate Integer Math with operation ‘Divide Floor’.\n\n\ndivideround\nCreate Integer Math with operation ‘Divide Round’.\n\n\nflooredmodulo\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\ngcd\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\nlcm\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\nmaximum\nCreate Integer Math with operation ‘Maximum’.\n\n\nminimum\nCreate Integer Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Integer Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Integer Math with operation ‘Multiply’.\n\n\nmultiplyadd\nCreate Integer Math with operation ‘Multiply Add’.\n\n\nnegate\nCreate Integer Math with operation ‘Negate’.\n\n\npower\nCreate Integer Math with operation ‘Power’.\n\n\nsign\nCreate Integer Math with operation ‘Sign’.\n\n\nsubtract\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.utilities.IntegerMath.absolute(value=0, value_001=0)\nCreate Integer Math with operation ‘Absolute’.\n\n\n\nnodes.utilities.IntegerMath.add(value=0, value_001=0)\nCreate Integer Math with operation ‘Add’.\n\n\n\nnodes.utilities.IntegerMath.divide(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide’.\n\n\n\nnodes.utilities.IntegerMath.divideceil(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\n\nnodes.utilities.IntegerMath.dividefloor(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Floor’.\n\n\n\nnodes.utilities.IntegerMath.divideround(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Round’.\n\n\n\nnodes.utilities.IntegerMath.flooredmodulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\n\nnodes.utilities.IntegerMath.gcd(value=0, value_001=0)\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\n\nnodes.utilities.IntegerMath.lcm(value=0, value_001=0)\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\n\nnodes.utilities.IntegerMath.maximum(value=0, value_001=0)\nCreate Integer Math with operation ‘Maximum’.\n\n\n\nnodes.utilities.IntegerMath.minimum(value=0, value_001=0)\nCreate Integer Math with operation ‘Minimum’.\n\n\n\nnodes.utilities.IntegerMath.modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Modulo’.\n\n\n\nnodes.utilities.IntegerMath.multiply(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply’.\n\n\n\nnodes.utilities.IntegerMath.multiplyadd(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply Add’.\n\n\n\nnodes.utilities.IntegerMath.negate(value=0, value_001=0)\nCreate Integer Math with operation ‘Negate’.\n\n\n\nnodes.utilities.IntegerMath.power(value=0, value_001=0)\nCreate Integer Math with operation ‘Power’.\n\n\n\nnodes.utilities.IntegerMath.sign(value=0, value_001=0)\nCreate Integer Math with operation ‘Sign’.\n\n\n\nnodes.utilities.IntegerMath.subtract(value=0, value_001=0)\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.utilities.InvertMatrix(matrix=None, **kwargs)\nCompute the inverse of the given matrix, if one exists\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_invertible\nOutput socket: Invertible\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.InvertRotation(rotation=[0.0, 0.0, 0.0], **kwargs)\nCompute the inverse of the given rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.MapRange(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n    clamp=False,\n    interpolation_type='LINEAR',\n    data_type='FLOAT',\n    **kwargs,\n)\nRemap a value from a range to a target range\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_from_max\nInput socket: From Max\n\n\ni_from_min\nInput socket: From Min\n\n\ni_to_max\nInput socket: To Max\n\n\ni_to_min\nInput socket: To Min\n\n\ni_value\nInput socket: Value\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.MatchString(\n    string='',\n    operation='Starts With',\n    key='',\n    **kwargs,\n)\nCheck if a given string exists within another string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_key\nInput socket: Key\n\n\ni_operation\nInput socket: Operation\n\n\ni_string\nInput socket: String\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.MatrixDeterminant(matrix=None, **kwargs)\nCompute the determinant of the given matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_determinant\nOutput socket: Determinant\n\n\n\n\n\n\n\nnodes.utilities.MultiplyMatrices(matrix=None, matrix_001=None, **kwargs)\nPerform a matrix multiplication on two input matrices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\ni_matrix_001\nInput socket: Matrix\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.ProjectPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0, **kwargs)\nBuild a rotation from quaternion components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_w\nInput socket: W\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.ReplaceString(string='', find='', replace='', **kwargs)\nReplace a given string segment with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_find\nInput socket: Find\n\n\ni_replace\nInput socket: Replace\n\n\ni_string\nInput socket: String\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.RotateEuler(\n    rotation=[0.0, 0.0, 0.0],\n    rotate_by=[0.0, 0.0, 0.0],\n    rotation_type='EULER',\n    space='OBJECT',\n    **kwargs,\n)\nApply a secondary Euler rotation to a given Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.RotateRotation(\n    rotation=[0.0, 0.0, 0.0],\n    rotate_by=[0.0, 0.0, 0.0],\n    rotation_space='GLOBAL',\n    **kwargs,\n)\nApply a secondary rotation to a given rotation value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.RotateVector(\n    vector=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nApply a rotation to a given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.RotationToAxisAngle(rotation=[0.0, 0.0, 0.0], **kwargs)\nConvert a rotation to axis angle components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_angle\nOutput socket: Angle\n\n\no_axis\nOutput socket: Axis\n\n\n\n\n\n\n\nnodes.utilities.RotationToEuler(rotation=[0.0, 0.0, 0.0], **kwargs)\nConvert a standard rotation value to an Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_euler\nOutput socket: Euler\n\n\n\n\n\n\n\nnodes.utilities.RotationToQuaternion(rotation=[0.0, 0.0, 0.0], **kwargs)\nRetrieve the quaternion components representing a rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_w\nOutput socket: W\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\n\n\n\n\n\nnodes.utilities.SeparateColor(color=[1.0, 1.0, 1.0, 1.0], mode='RGB', **kwargs)\nSplit a color into separate channels, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\no_alpha\nOutput socket: Alpha\n\n\no_blue\nOutput socket: Blue\n\n\no_green\nOutput socket: Green\n\n\no_red\nOutput socket: Red\n\n\n\n\n\n\n\nnodes.utilities.SeparateMatrix(matrix=None, **kwargs)\nSplit a 4x4 matrix into its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_column_1_row_1\nOutput socket: Column 1 Row 1\n\n\no_column_1_row_2\nOutput socket: Column 1 Row 2\n\n\no_column_1_row_3\nOutput socket: Column 1 Row 3\n\n\no_column_1_row_4\nOutput socket: Column 1 Row 4\n\n\no_column_2_row_1\nOutput socket: Column 2 Row 1\n\n\no_column_2_row_2\nOutput socket: Column 2 Row 2\n\n\no_column_2_row_3\nOutput socket: Column 2 Row 3\n\n\no_column_2_row_4\nOutput socket: Column 2 Row 4\n\n\no_column_3_row_1\nOutput socket: Column 3 Row 1\n\n\no_column_3_row_2\nOutput socket: Column 3 Row 2\n\n\no_column_3_row_3\nOutput socket: Column 3 Row 3\n\n\no_column_3_row_4\nOutput socket: Column 3 Row 4\n\n\no_column_4_row_1\nOutput socket: Column 4 Row 1\n\n\no_column_4_row_2\nOutput socket: Column 4 Row 2\n\n\no_column_4_row_3\nOutput socket: Column 4 Row 3\n\n\no_column_4_row_4\nOutput socket: Column 4 Row 4\n\n\n\n\n\n\n\nnodes.utilities.SeparateTransform(transform=None, **kwargs)\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_translation\nOutput socket: Translation\n\n\n\n\n\n\n\nnodes.utilities.SliceString(string='', position=0, length=10, **kwargs)\nExtract a string segment from a larger string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_length\nInput socket: Length\n\n\ni_position\nInput socket: Position\n\n\ni_string\nInput socket: String\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.StringLength(string='', **kwargs)\nOutput the number of characters in the given string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.utilities.StringToValue(string='', data_type='FLOAT', **kwargs)\nDerive a numeric value from a given string representation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\no_length\nOutput socket: Length\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.utilities.TransformDirection(\n    direction=[0.0, 0.0, 0.0],\n    transform=None,\n    **kwargs,\n)\nApply a transformation matrix (excluding translation) to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_transform\nInput socket: Transform\n\n\no_direction\nOutput socket: Direction\n\n\n\n\n\n\n\nnodes.utilities.TransformPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)\nApply a transformation matrix to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.TransposeMatrix(matrix=None, **kwargs)\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.ValueToString(\n    value=0.0,\n    decimals=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nGenerate a string representation of the given input value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_decimals\nInput socket: Decimals\n\n\ni_value\nInput socket: Value\n\n\no_string\nOutput socket: String",
    "crumbs": [
      "Some functions",
      "nodes.utilities"
    ]
  },
  {
    "objectID": "reference/nodes.utilities.html#classes",
    "href": "reference/nodes.utilities.html#classes",
    "title": "nodes.utilities",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAlignEulerToVector\nOrient an Euler rotation along the given direction\n\n\nAlignRotationToVector\nOrient a rotation along the given direction\n\n\nAxesToRotation\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\nAxisAngleToRotation\nBuild a rotation from an axis and a rotation around that axis\n\n\nBitMath\nPerform bitwise operations on 32-bit integers\n\n\nClamp\nClamp a value between a minimum and a maximum\n\n\nCombineColor\nCombine four channels into a single color, based on a particular color model\n\n\nCombineMatrix\nConstruct a 4x4 matrix from its individual values\n\n\nCombineTransform\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\nCompare\nPerform a comparison operation on the two given inputs\n\n\nEulerToRotation\nBuild a rotation from separate angles around each axis\n\n\nFindInString\nFind the number of times a given string occurs in another string and the position of the first match\n\n\nFloatToInteger\nConvert the given floating-point number to an integer, with a choice of methods\n\n\nFormatString\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\nGamma\nApply a gamma correction\n\n\nHashValue\nGenerate a randomized integer using the given input value as a seed\n\n\nIntegerMath\nPerform various math operations on the given integer inputs\n\n\nInvertMatrix\nCompute the inverse of the given matrix, if one exists\n\n\nInvertRotation\nCompute the inverse of the given rotation\n\n\nMapRange\nRemap a value from a range to a target range\n\n\nMatchString\nCheck if a given string exists within another string\n\n\nMatrixDeterminant\nCompute the determinant of the given matrix\n\n\nMultiplyMatrices\nPerform a matrix multiplication on two input matrices\n\n\nProjectPoint\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\nQuaternionToRotation\nBuild a rotation from quaternion components\n\n\nReplaceString\nReplace a given string segment with another\n\n\nRotateEuler\nApply a secondary Euler rotation to a given Euler rotation\n\n\nRotateRotation\nApply a secondary rotation to a given rotation value\n\n\nRotateVector\nApply a rotation to a given vector\n\n\nRotationToAxisAngle\nConvert a rotation to axis angle components\n\n\nRotationToEuler\nConvert a standard rotation value to an Euler rotation\n\n\nRotationToQuaternion\nRetrieve the quaternion components representing a rotation\n\n\nSeparateColor\nSplit a color into separate channels, based on a particular color model\n\n\nSeparateMatrix\nSplit a 4x4 matrix into its individual values\n\n\nSeparateTransform\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\nSliceString\nExtract a string segment from a larger string\n\n\nStringLength\nOutput the number of characters in the given string\n\n\nStringToValue\nDerive a numeric value from a given string representation\n\n\nTransformDirection\nApply a transformation matrix (excluding translation) to the given vector\n\n\nTransformPoint\nApply a transformation matrix to the given vector\n\n\nTransposeMatrix\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\nValueToString\nGenerate a string representation of the given input value\n\n\n\n\n\nnodes.utilities.AlignEulerToVector(\n    rotation=[0.0, 0.0, 0.0],\n    factor=1.0,\n    vector=[0.0, 0.0, 1.0],\n    axis='X',\n    pivot_axis='AUTO',\n    **kwargs,\n)\nOrient an Euler rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AlignRotationToVector(\n    rotation=[0.0, 0.0, 0.0],\n    factor=1.0,\n    vector=[0.0, 0.0, 1.0],\n    axis='Z',\n    pivot_axis='AUTO',\n    **kwargs,\n)\nOrient a rotation along the given direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AxesToRotation(\n    primary_axis=[0.0, 0.0, 1.0],\n    secondary_axis=[1.0, 0.0, 0.0],\n    primary_axis_axis='Z',\n    secondary_axis_axis='X',\n    **kwargs,\n)\nCreate a rotation from a primary and (ideally orthogonal) secondary axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_primary_axis\nInput socket: Primary Axis\n\n\ni_secondary_axis\nInput socket: Secondary Axis\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.AxisAngleToRotation(axis=[0.0, 0.0, 1.0], angle=0.0, **kwargs)\nBuild a rotation from an axis and a rotation around that axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_angle\nInput socket: Angle\n\n\ni_axis\nInput socket: Axis\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.BitMath(a=0, b=0, operation='AND', **kwargs)\nPerform bitwise operations on 32-bit integers\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nl_and\nCreate Bit Math with operation ‘And’.\n\n\nl_not\nCreate Bit Math with operation ‘Not’.\n\n\nl_or\nCreate Bit Math with operation ‘Or’.\n\n\nrotate\nCreate Bit Math with operation ‘Rotate’.\n\n\nshift\nCreate Bit Math with operation ‘Shift’.\n\n\nxor\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\n\n\nnodes.utilities.BitMath.l_and(a=0, b=0)\nCreate Bit Math with operation ‘And’.\n\n\n\nnodes.utilities.BitMath.l_not(a=0, b=0)\nCreate Bit Math with operation ‘Not’.\n\n\n\nnodes.utilities.BitMath.l_or(a=0, b=0)\nCreate Bit Math with operation ‘Or’.\n\n\n\nnodes.utilities.BitMath.rotate(a=0, b=0)\nCreate Bit Math with operation ‘Rotate’.\n\n\n\nnodes.utilities.BitMath.shift(a=0, b=0)\nCreate Bit Math with operation ‘Shift’.\n\n\n\nnodes.utilities.BitMath.xor(a=0, b=0)\nCreate Bit Math with operation ‘Exclusive Or’.\n\n\n\n\n\nnodes.utilities.Clamp(\n    value=1.0,\n    min=0.0,\n    max=1.0,\n    clamp_type='MINMAX',\n    **kwargs,\n)\nClamp a value between a minimum and a maximum\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_value\nInput socket: Value\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.CombineColor(\n    red=0.0,\n    green=0.0,\n    blue=0.0,\n    alpha=1.0,\n    mode='RGB',\n    **kwargs,\n)\nCombine four channels into a single color, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_alpha\nInput socket: Alpha\n\n\ni_blue\nInput socket: Blue\n\n\ni_green\nInput socket: Green\n\n\ni_red\nInput socket: Red\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.utilities.CombineMatrix(\n    column_1_row_1=1.0,\n    column_1_row_2=0.0,\n    column_1_row_3=0.0,\n    column_1_row_4=0.0,\n    column_2_row_1=0.0,\n    column_2_row_2=1.0,\n    column_2_row_3=0.0,\n    column_2_row_4=0.0,\n    column_3_row_1=0.0,\n    column_3_row_2=0.0,\n    column_3_row_3=1.0,\n    column_3_row_4=0.0,\n    column_4_row_1=0.0,\n    column_4_row_2=0.0,\n    column_4_row_3=0.0,\n    column_4_row_4=1.0,\n    **kwargs,\n)\nConstruct a 4x4 matrix from its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_column_1_row_1\nInput socket: Column 1 Row 1\n\n\ni_column_1_row_2\nInput socket: Column 1 Row 2\n\n\ni_column_1_row_3\nInput socket: Column 1 Row 3\n\n\ni_column_1_row_4\nInput socket: Column 1 Row 4\n\n\ni_column_2_row_1\nInput socket: Column 2 Row 1\n\n\ni_column_2_row_2\nInput socket: Column 2 Row 2\n\n\ni_column_2_row_3\nInput socket: Column 2 Row 3\n\n\ni_column_2_row_4\nInput socket: Column 2 Row 4\n\n\ni_column_3_row_1\nInput socket: Column 3 Row 1\n\n\ni_column_3_row_2\nInput socket: Column 3 Row 2\n\n\ni_column_3_row_3\nInput socket: Column 3 Row 3\n\n\ni_column_3_row_4\nInput socket: Column 3 Row 4\n\n\ni_column_4_row_1\nInput socket: Column 4 Row 1\n\n\ni_column_4_row_2\nInput socket: Column 4 Row 2\n\n\ni_column_4_row_3\nInput socket: Column 4 Row 3\n\n\ni_column_4_row_4\nInput socket: Column 4 Row 4\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.CombineTransform(\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nCombine a translation vector, a rotation, and a scale vector into a transformation matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_translation\nInput socket: Translation\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.utilities.Compare(\n    a=0.0,\n    b=0.0,\n    operation='GREATER_THAN',\n    data_type='FLOAT',\n    mode='ELEMENT',\n    **kwargs,\n)\nPerform a comparison operation on the two given inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_a\nInput socket: A\n\n\ni_b\nInput socket: B\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbrighter\nCreate Compare with operation ‘Brighter’.\n\n\ndarker\nCreate Compare with operation ‘Darker’.\n\n\nequal\nCreate Compare with operation ‘Equal’.\n\n\ngreaterequal\nCreate Compare with operation ‘Greater Than or Equal’.\n\n\ngreaterthan\nCreate Compare with operation ‘Greater Than’.\n\n\nlessequal\nCreate Compare with operation ‘Less Than or Equal’.\n\n\nlessthan\nCreate Compare with operation ‘Less Than’.\n\n\nnotequal\nCreate Compare with operation ‘Not Equal’.\n\n\n\n\n\nnodes.utilities.Compare.brighter(a=0.0, b=0.0)\nCreate Compare with operation ‘Brighter’.\n\n\n\nnodes.utilities.Compare.darker(a=0.0, b=0.0)\nCreate Compare with operation ‘Darker’.\n\n\n\nnodes.utilities.Compare.equal(a=0.0, b=0.0)\nCreate Compare with operation ‘Equal’.\n\n\n\nnodes.utilities.Compare.greaterequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Greater Than or Equal’.\n\n\n\nnodes.utilities.Compare.greaterthan(a=0.0, b=0.0)\nCreate Compare with operation ‘Greater Than’.\n\n\n\nnodes.utilities.Compare.lessequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Less Than or Equal’.\n\n\n\nnodes.utilities.Compare.lessthan(a=0.0, b=0.0)\nCreate Compare with operation ‘Less Than’.\n\n\n\nnodes.utilities.Compare.notequal(a=0.0, b=0.0)\nCreate Compare with operation ‘Not Equal’.\n\n\n\n\n\nnodes.utilities.EulerToRotation(euler=[0.0, 0.0, 0.0], **kwargs)\nBuild a rotation from separate angles around each axis\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_euler\nInput socket: Euler\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.FindInString(string='', search='', **kwargs)\nFind the number of times a given string occurs in another string and the position of the first match\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_search\nInput socket: Search\n\n\ni_string\nInput socket: String\n\n\no_count\nOutput socket: Count\n\n\no_first_found\nOutput socket: First Found\n\n\n\n\n\n\n\nnodes.utilities.FloatToInteger(float=0.0, rounding_mode='ROUND', **kwargs)\nConvert the given floating-point number to an integer, with a choice of methods\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_float\nInput socket: Float\n\n\no_integer\nOutput socket: Integer\n\n\n\n\n\n\n\nnodes.utilities.FormatString(format='', extend=None, active_index=0, **kwargs)\nInsert values into a string using a Python and path template compatible formatting syntax\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_format\nInput socket: Format\n\n\ni_input_socket\nInput socket:\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.Gamma(color=[1.0, 1.0, 1.0, 1.0], gamma=1.0, **kwargs)\nApply a gamma correction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_gamma\nInput socket: Gamma\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.utilities.HashValue(value=0, seed=0, data_type='INT', **kwargs)\nGenerate a randomized integer using the given input value as a seed\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_seed\nInput socket: Seed\n\n\ni_value\nInput socket: Value\n\n\no_hash\nOutput socket: Hash\n\n\n\n\n\n\n\nnodes.utilities.IntegerMath(value=0, value_001=0, operation='ADD', **kwargs)\nPerform various math operations on the given integer inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\ni_value_001\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nabsolute\nCreate Integer Math with operation ‘Absolute’.\n\n\nadd\nCreate Integer Math with operation ‘Add’.\n\n\ndivide\nCreate Integer Math with operation ‘Divide’.\n\n\ndivideceil\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\ndividefloor\nCreate Integer Math with operation ‘Divide Floor’.\n\n\ndivideround\nCreate Integer Math with operation ‘Divide Round’.\n\n\nflooredmodulo\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\ngcd\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\nlcm\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\nmaximum\nCreate Integer Math with operation ‘Maximum’.\n\n\nminimum\nCreate Integer Math with operation ‘Minimum’.\n\n\nmodulo\nCreate Integer Math with operation ‘Modulo’.\n\n\nmultiply\nCreate Integer Math with operation ‘Multiply’.\n\n\nmultiplyadd\nCreate Integer Math with operation ‘Multiply Add’.\n\n\nnegate\nCreate Integer Math with operation ‘Negate’.\n\n\npower\nCreate Integer Math with operation ‘Power’.\n\n\nsign\nCreate Integer Math with operation ‘Sign’.\n\n\nsubtract\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.utilities.IntegerMath.absolute(value=0, value_001=0)\nCreate Integer Math with operation ‘Absolute’.\n\n\n\nnodes.utilities.IntegerMath.add(value=0, value_001=0)\nCreate Integer Math with operation ‘Add’.\n\n\n\nnodes.utilities.IntegerMath.divide(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide’.\n\n\n\nnodes.utilities.IntegerMath.divideceil(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Ceiling’.\n\n\n\nnodes.utilities.IntegerMath.dividefloor(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Floor’.\n\n\n\nnodes.utilities.IntegerMath.divideround(value=0, value_001=0)\nCreate Integer Math with operation ‘Divide Round’.\n\n\n\nnodes.utilities.IntegerMath.flooredmodulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Floored Modulo’.\n\n\n\nnodes.utilities.IntegerMath.gcd(value=0, value_001=0)\nCreate Integer Math with operation ‘Greatest Common Divisor’.\n\n\n\nnodes.utilities.IntegerMath.lcm(value=0, value_001=0)\nCreate Integer Math with operation ‘Least Common Multiple’.\n\n\n\nnodes.utilities.IntegerMath.maximum(value=0, value_001=0)\nCreate Integer Math with operation ‘Maximum’.\n\n\n\nnodes.utilities.IntegerMath.minimum(value=0, value_001=0)\nCreate Integer Math with operation ‘Minimum’.\n\n\n\nnodes.utilities.IntegerMath.modulo(value=0, value_001=0)\nCreate Integer Math with operation ‘Modulo’.\n\n\n\nnodes.utilities.IntegerMath.multiply(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply’.\n\n\n\nnodes.utilities.IntegerMath.multiplyadd(value=0, value_001=0)\nCreate Integer Math with operation ‘Multiply Add’.\n\n\n\nnodes.utilities.IntegerMath.negate(value=0, value_001=0)\nCreate Integer Math with operation ‘Negate’.\n\n\n\nnodes.utilities.IntegerMath.power(value=0, value_001=0)\nCreate Integer Math with operation ‘Power’.\n\n\n\nnodes.utilities.IntegerMath.sign(value=0, value_001=0)\nCreate Integer Math with operation ‘Sign’.\n\n\n\nnodes.utilities.IntegerMath.subtract(value=0, value_001=0)\nCreate Integer Math with operation ‘Subtract’.\n\n\n\n\n\nnodes.utilities.InvertMatrix(matrix=None, **kwargs)\nCompute the inverse of the given matrix, if one exists\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_invertible\nOutput socket: Invertible\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.InvertRotation(rotation=[0.0, 0.0, 0.0], **kwargs)\nCompute the inverse of the given rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.MapRange(\n    value=1.0,\n    from_min=0.0,\n    from_max=1.0,\n    to_min=0.0,\n    to_max=1.0,\n    clamp=False,\n    interpolation_type='LINEAR',\n    data_type='FLOAT',\n    **kwargs,\n)\nRemap a value from a range to a target range\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_from_max\nInput socket: From Max\n\n\ni_from_min\nInput socket: From Min\n\n\ni_to_max\nInput socket: To Max\n\n\ni_to_min\nInput socket: To Min\n\n\ni_value\nInput socket: Value\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.MatchString(\n    string='',\n    operation='Starts With',\n    key='',\n    **kwargs,\n)\nCheck if a given string exists within another string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_key\nInput socket: Key\n\n\ni_operation\nInput socket: Operation\n\n\ni_string\nInput socket: String\n\n\no_result\nOutput socket: Result\n\n\n\n\n\n\n\nnodes.utilities.MatrixDeterminant(matrix=None, **kwargs)\nCompute the determinant of the given matrix\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_determinant\nOutput socket: Determinant\n\n\n\n\n\n\n\nnodes.utilities.MultiplyMatrices(matrix=None, matrix_001=None, **kwargs)\nPerform a matrix multiplication on two input matrices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\ni_matrix_001\nInput socket: Matrix\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.ProjectPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)\nProject a point using a matrix, using location, rotation, scale, and perspective divide\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.QuaternionToRotation(w=1.0, x=0.0, y=0.0, z=0.0, **kwargs)\nBuild a rotation from quaternion components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_w\nInput socket: W\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.ReplaceString(string='', find='', replace='', **kwargs)\nReplace a given string segment with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_find\nInput socket: Find\n\n\ni_replace\nInput socket: Replace\n\n\ni_string\nInput socket: String\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.RotateEuler(\n    rotation=[0.0, 0.0, 0.0],\n    rotate_by=[0.0, 0.0, 0.0],\n    rotation_type='EULER',\n    space='OBJECT',\n    **kwargs,\n)\nApply a secondary Euler rotation to a given Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.RotateRotation(\n    rotation=[0.0, 0.0, 0.0],\n    rotate_by=[0.0, 0.0, 0.0],\n    rotation_space='GLOBAL',\n    **kwargs,\n)\nApply a secondary rotation to a given rotation value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotate_by\nInput socket: Rotate By\n\n\ni_rotation\nInput socket: Rotation\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.utilities.RotateVector(\n    vector=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nApply a rotation to a given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.RotationToAxisAngle(rotation=[0.0, 0.0, 0.0], **kwargs)\nConvert a rotation to axis angle components\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_angle\nOutput socket: Angle\n\n\no_axis\nOutput socket: Axis\n\n\n\n\n\n\n\nnodes.utilities.RotationToEuler(rotation=[0.0, 0.0, 0.0], **kwargs)\nConvert a standard rotation value to an Euler rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_euler\nOutput socket: Euler\n\n\n\n\n\n\n\nnodes.utilities.RotationToQuaternion(rotation=[0.0, 0.0, 0.0], **kwargs)\nRetrieve the quaternion components representing a rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_rotation\nInput socket: Rotation\n\n\no_w\nOutput socket: W\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z\n\n\n\n\n\n\n\nnodes.utilities.SeparateColor(color=[1.0, 1.0, 1.0, 1.0], mode='RGB', **kwargs)\nSplit a color into separate channels, based on a particular color model\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\no_alpha\nOutput socket: Alpha\n\n\no_blue\nOutput socket: Blue\n\n\no_green\nOutput socket: Green\n\n\no_red\nOutput socket: Red\n\n\n\n\n\n\n\nnodes.utilities.SeparateMatrix(matrix=None, **kwargs)\nSplit a 4x4 matrix into its individual values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_column_1_row_1\nOutput socket: Column 1 Row 1\n\n\no_column_1_row_2\nOutput socket: Column 1 Row 2\n\n\no_column_1_row_3\nOutput socket: Column 1 Row 3\n\n\no_column_1_row_4\nOutput socket: Column 1 Row 4\n\n\no_column_2_row_1\nOutput socket: Column 2 Row 1\n\n\no_column_2_row_2\nOutput socket: Column 2 Row 2\n\n\no_column_2_row_3\nOutput socket: Column 2 Row 3\n\n\no_column_2_row_4\nOutput socket: Column 2 Row 4\n\n\no_column_3_row_1\nOutput socket: Column 3 Row 1\n\n\no_column_3_row_2\nOutput socket: Column 3 Row 2\n\n\no_column_3_row_3\nOutput socket: Column 3 Row 3\n\n\no_column_3_row_4\nOutput socket: Column 3 Row 4\n\n\no_column_4_row_1\nOutput socket: Column 4 Row 1\n\n\no_column_4_row_2\nOutput socket: Column 4 Row 2\n\n\no_column_4_row_3\nOutput socket: Column 4 Row 3\n\n\no_column_4_row_4\nOutput socket: Column 4 Row 4\n\n\n\n\n\n\n\nnodes.utilities.SeparateTransform(transform=None, **kwargs)\nSplit a transformation matrix into a translation vector, a rotation, and a scale vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_translation\nOutput socket: Translation\n\n\n\n\n\n\n\nnodes.utilities.SliceString(string='', position=0, length=10, **kwargs)\nExtract a string segment from a larger string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_length\nInput socket: Length\n\n\ni_position\nInput socket: Position\n\n\ni_string\nInput socket: String\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.utilities.StringLength(string='', **kwargs)\nOutput the number of characters in the given string\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.utilities.StringToValue(string='', data_type='FLOAT', **kwargs)\nDerive a numeric value from a given string representation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_string\nInput socket: String\n\n\no_length\nOutput socket: Length\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.utilities.TransformDirection(\n    direction=[0.0, 0.0, 0.0],\n    transform=None,\n    **kwargs,\n)\nApply a transformation matrix (excluding translation) to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_transform\nInput socket: Transform\n\n\no_direction\nOutput socket: Direction\n\n\n\n\n\n\n\nnodes.utilities.TransformPoint(vector=[0.0, 0.0, 0.0], transform=None, **kwargs)\nApply a transformation matrix to the given vector\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_transform\nInput socket: Transform\n\n\ni_vector\nInput socket: Vector\n\n\no_vector\nOutput socket: Vector\n\n\n\n\n\n\n\nnodes.utilities.TransposeMatrix(matrix=None, **kwargs)\nFlip a matrix over its diagonal, turning columns into rows and vice-versa\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_matrix\nInput socket: Matrix\n\n\no_matrix\nOutput socket: Matrix\n\n\n\n\n\n\n\nnodes.utilities.ValueToString(\n    value=0.0,\n    decimals=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nGenerate a string representation of the given input value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_decimals\nInput socket: Decimals\n\n\ni_value\nInput socket: Value\n\n\no_string\nOutput socket: String",
    "crumbs": [
      "Some functions",
      "nodes.utilities"
    ]
  },
  {
    "objectID": "reference/nodes.curve.html",
    "href": "reference/nodes.curve.html",
    "title": "nodes.curve",
    "section": "",
    "text": "nodes.curve\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nArc\nGenerate a poly spline arc\n\n\nBezierSegment\nGenerate a 2D Bézier spline from the given control points and handles\n\n\nCurveCircle\nGenerate a poly spline circle\n\n\nCurveHandlePositions\nRetrieve the position of each Bézier control point’s handles\n\n\nCurveLength\nRetrieve the length of all splines added together\n\n\nCurveLine\nGenerate a poly spline line with two points\n\n\nCurveOfPoint\nRetrieve the curve a control point is part of\n\n\nCurveTilt\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\nCurveToPoints\nGenerate a point cloud by sampling positions along curves\n\n\nCurvesToGreasePencil\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\nDeformCurvesOnSurface\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\nEdgePathsToCurves\nOutput curves following paths across mesh edges\n\n\nEndpointSelection\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\nFillCurve\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\nFilletCurve\nRound corners by generating circular arcs on each control point\n\n\nFloatCurve\nMap an input float to a curve and outputs a float value\n\n\nGreasePencilToCurves\nConvert Grease Pencil layers into curve instances\n\n\nHandleTypeSelection\nProvide a selection based on the handle types of Bézier control points\n\n\nInterpolateCurves\nGenerate new curves on points by interpolating between existing curves\n\n\nOffsetPointInCurve\nOffset a control point index within its curve\n\n\nPointsOfCurve\nRetrieve a point index within a curve\n\n\nPointsToCurves\nSplit all points to curve by its group ID and reorder by weight\n\n\nQuadraticBezier\nGenerate a poly spline in a parabola shape with control points positions\n\n\nQuadrilateral\nGenerate a polygon with four points\n\n\nResampleCurve\nGenerate a poly spline for each input spline\n\n\nReverseCurve\nChange the direction of curves by swapping their start and end data\n\n\nRgbCurves\nApply color corrections for each color channel\n\n\nSampleCurve\nRetrieve data from a point on a curve at a certain distance from its start\n\n\nSetCurveNormal\nSet the evaluation mode for curve normals\n\n\nSetCurveRadius\nSet the radius of the curve at each control point\n\n\nSetCurveTilt\nSet the tilt angle at each curve control point\n\n\nSetHandlePositions\nSet the positions for the handles of Bézier curves\n\n\nSetHandleType\nSet the handle type for the control points of a Bézier curve\n\n\nSetSplineType\nChange the type of curves\n\n\nSpiral\nGenerate a poly spline in a spiral shape\n\n\nStar\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\nStringToCurves\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\nSubdivideCurve\nDividing each curve segment into a specified number of pieces\n\n\nTrimCurve\nShorten curves by removing portions at the start or end\n\n\n\n\n\nnodes.curve.Arc(\n    resolution=16,\n    radius=1.0,\n    start_angle=0.0,\n    sweep_angle=5.497786998748779,\n    connect_center=False,\n    invert_arc=False,\n    mode='RADIUS',\n    **kwargs,\n)\nGenerate a poly spline arc\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_connect_center\nInput socket: Connect Center\n\n\ni_invert_arc\nInput socket: Invert Arc\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start_angle\nInput socket: Start Angle\n\n\ni_sweep_angle\nInput socket: Sweep Angle\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.BezierSegment(\n    resolution=16,\n    start=[-1.0, 0.0, 0.0],\n    start_handle=[-0.5, 0.5, 0.0],\n    end_handle=[0.0, 0.0, 0.0],\n    end=[1.0, 0.0, 0.0],\n    mode='POSITION',\n    **kwargs,\n)\nGenerate a 2D Bézier spline from the given control points and handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_end_handle\nInput socket: End Handle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_handle\nInput socket: Start Handle\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveCircle(resolution=32, radius=1.0, mode='RADIUS', **kwargs)\nGenerate a poly spline circle\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveHandlePositions(relative=False, **kwargs)\nRetrieve the position of each Bézier control point’s handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_relative\nInput socket: Relative\n\n\no_left\nOutput socket: Left\n\n\no_right\nOutput socket: Right\n\n\n\n\n\n\n\nnodes.curve.CurveLength(curve=None, **kwargs)\nRetrieve the length of all splines added together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.curve.CurveLine(\n    start=[0.0, 0.0, 0.0],\n    end=[0.0, 0.0, 1.0],\n    mode='POINTS',\n    **kwargs,\n)\nGenerate a poly spline line with two points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveOfPoint(point_index=0, **kwargs)\nRetrieve the curve a control point is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_index\nInput socket: Point Index\n\n\no_curve_index\nOutput socket: Curve Index\n\n\no_index_in_curve\nOutput socket: Index in Curve\n\n\n\n\n\n\n\nnodes.curve.CurveTilt(**kwargs)\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\n\n\n\nName\nDescription\n\n\n\n\no_tilt\nOutput socket: Tilt\n\n\n\n\n\n\n\nnodes.curve.CurveToPoints(curve=None, count=10, mode='COUNT', **kwargs)\nGenerate a point cloud by sampling positions along curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.curve.CurvesToGreasePencil(\n    curves=None,\n    selection=True,\n    instances_as_layers=True,\n    **kwargs,\n)\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\ni_instances_as_layers\nInput socket: Instances as Layers\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.curve.DeformCurvesOnSurface(curves=None, **kwargs)\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.EdgePathsToCurves(\n    mesh=None,\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput curves following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.EndpointSelection(start_size=1, end_size=1, **kwargs)\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_size\nInput socket: End Size\n\n\ni_start_size\nInput socket: Start Size\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.curve.FillCurve(curve=None, group_id=0, mode='Triangles', **kwargs)\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mode\nInput socket: Mode\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.curve.FilletCurve(\n    curve=None,\n    radius=0.25,\n    limit_radius=False,\n    mode='Bézier',\n    count=1,\n    **kwargs,\n)\nRound corners by generating circular arcs on each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_limit_radius\nInput socket: Limit Radius\n\n\ni_mode\nInput socket: Mode\n\n\ni_radius\nInput socket: Radius\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.FloatCurve(factor=1.0, value=1.0, **kwargs)\nMap an input float to a curve and outputs a float value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.curve.GreasePencilToCurves(\n    grease_pencil=None,\n    selection=True,\n    layers_as_instances=True,\n    **kwargs,\n)\nConvert Grease Pencil layers into curve instances\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_layers_as_instances\nInput socket: Layers as Instances\n\n\ni_selection\nInput socket: Selection\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.HandleTypeSelection(\n    handle_type='AUTO',\n    mode=\"{'LEFT', 'RIGHT'}\",\n    **kwargs,\n)\nProvide a selection based on the handle types of Bézier control points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.curve.InterpolateCurves(\n    guide_curves=None,\n    guide_up=[0.0, 0.0, 0.0],\n    guide_group_id=0,\n    points=None,\n    point_up=[0.0, 0.0, 0.0],\n    point_group_id=0,\n    max_neighbors=4,\n    **kwargs,\n)\nGenerate new curves on points by interpolating between existing curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_guide_curves\nInput socket: Guide Curves\n\n\ni_guide_group_id\nInput socket: Guide Group ID\n\n\ni_guide_up\nInput socket: Guide Up\n\n\ni_max_neighbors\nInput socket: Max Neighbors\n\n\ni_point_group_id\nInput socket: Point Group ID\n\n\ni_point_up\nInput socket: Point Up\n\n\ni_points\nInput socket: Points\n\n\no_closest_index\nOutput socket: Closest Index\n\n\no_closest_weight\nOutput socket: Closest Weight\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.OffsetPointInCurve(point_index=0, offset=0, **kwargs)\nOffset a control point index within its curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_index\nInput socket: Point Index\n\n\no_is_valid_offset\nOutput socket: Is Valid Offset\n\n\no_point_index\nOutput socket: Point Index\n\n\n\n\n\n\n\nnodes.curve.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve a point index within a curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_point_index\nOutput socket: Point Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.curve.PointsToCurves(points=None, curve_group_id=0, weight=0.0, **kwargs)\nSplit all points to curve by its group ID and reorder by weight\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_group_id\nInput socket: Curve Group ID\n\n\ni_points\nInput socket: Points\n\n\ni_weight\nInput socket: Weight\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.QuadraticBezier(\n    resolution=16,\n    start=[-1.0, 0.0, 0.0],\n    middle=[0.0, 2.0, 0.0],\n    end=[1.0, 0.0, 0.0],\n    **kwargs,\n)\nGenerate a poly spline in a parabola shape with control points positions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_middle\nInput socket: Middle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Quadrilateral(width=2.0, height=2.0, mode='RECTANGLE', **kwargs)\nGenerate a polygon with four points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_height\nInput socket: Height\n\n\ni_width\nInput socket: Width\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.ResampleCurve(\n    curve=None,\n    selection=True,\n    mode='Count',\n    count=10,\n    length=0.10000000149011612,\n    keep_last_segment=False,\n    **kwargs,\n)\nGenerate a poly spline for each input spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.ReverseCurve(curve=None, selection=True, **kwargs)\nChange the direction of curves by swapping their start and end data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.RgbCurves(fac=1.0, color=[1.0, 1.0, 1.0, 1.0], **kwargs)\nApply color corrections for each color channel\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_factor\nInput socket: Factor\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.curve.SampleCurve(\n    curves=None,\n    value=0.0,\n    factor=0.0,\n    curve_index=0,\n    mode='FACTOR',\n    use_all_curves=False,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data from a point on a curve at a certain distance from its start\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_curves\nInput socket: Curves\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\no_normal\nOutput socket: Normal\n\n\no_position\nOutput socket: Position\n\n\no_tangent\nOutput socket: Tangent\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.curve.SetCurveNormal(\n    curve=None,\n    selection=True,\n    mode='Minimum Twist',\n    normal=[0.0, 0.0, 1.0],\n    **kwargs,\n)\nSet the evaluation mode for curve normals\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_mode\nInput socket: Mode\n\n\ni_normal\nInput socket: Normal\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetCurveRadius(\n    curve=None,\n    selection=True,\n    radius=0.004999999888241291,\n    **kwargs,\n)\nSet the radius of the curve at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetCurveTilt(curve=None, selection=True, tilt=0.0, **kwargs)\nSet the tilt angle at each curve control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\ni_tilt\nInput socket: Tilt\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetHandlePositions(\n    curve=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    mode='LEFT',\n    **kwargs,\n)\nSet the positions for the handles of Bézier curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetHandleType(\n    curve=None,\n    selection=True,\n    handle_type='AUTO',\n    mode=\"{'LEFT', 'RIGHT'}\",\n    **kwargs,\n)\nSet the handle type for the control points of a Bézier curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetSplineType(\n    curve=None,\n    selection=True,\n    spline_type='POLY',\n    **kwargs,\n)\nChange the type of curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Spiral(\n    resolution=32,\n    rotations=2.0,\n    start_radius=1.0,\n    end_radius=2.0,\n    height=2.0,\n    reverse=False,\n    **kwargs,\n)\nGenerate a poly spline in a spiral shape\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_radius\nInput socket: End Radius\n\n\ni_height\nInput socket: Height\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_reverse\nInput socket: Reverse\n\n\ni_rotations\nInput socket: Rotations\n\n\ni_start_radius\nInput socket: Start Radius\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Star(\n    points=8,\n    inner_radius=1.0,\n    outer_radius=2.0,\n    twist=0.0,\n    **kwargs,\n)\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_inner_radius\nInput socket: Inner Radius\n\n\ni_outer_radius\nInput socket: Outer Radius\n\n\ni_points\nInput socket: Points\n\n\ni_twist\nInput socket: Twist\n\n\no_curve\nOutput socket: Curve\n\n\no_outer_points\nOutput socket: Outer Points\n\n\n\n\n\n\n\nnodes.curve.StringToCurves(\n    string='',\n    size=1.0,\n    character_spacing=1.0,\n    word_spacing=1.0,\n    line_spacing=1.0,\n    text_box_width=0.0,\n    overflow='OVERFLOW',\n    align_x='LEFT',\n    align_y='TOP_BASELINE',\n    pivot_mode='BOTTOM_LEFT',\n    **kwargs,\n)\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_character_spacing\nInput socket: Character Spacing\n\n\ni_line_spacing\nInput socket: Line Spacing\n\n\ni_size\nInput socket: Size\n\n\ni_string\nInput socket: String\n\n\ni_text_box_width\nInput socket: Text Box Width\n\n\ni_word_spacing\nInput socket: Word Spacing\n\n\no_curve_instances\nOutput socket: Curve Instances\n\n\no_line\nOutput socket: Line\n\n\no_pivot_point\nOutput socket: Pivot Point\n\n\n\n\n\n\n\nnodes.curve.SubdivideCurve(curve=None, cuts=1, **kwargs)\nDividing each curve segment into a specified number of pieces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cuts\nInput socket: Cuts\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.TrimCurve(\n    curve=None,\n    selection=True,\n    start=0.0,\n    end=1.0,\n    mode='FACTOR',\n    **kwargs,\n)\nShorten curves by removing portions at the start or end\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_end\nInput socket: End\n\n\ni_selection\nInput socket: Selection\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve",
    "crumbs": [
      "Some functions",
      "nodes.curve"
    ]
  },
  {
    "objectID": "reference/nodes.curve.html#classes",
    "href": "reference/nodes.curve.html#classes",
    "title": "nodes.curve",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArc\nGenerate a poly spline arc\n\n\nBezierSegment\nGenerate a 2D Bézier spline from the given control points and handles\n\n\nCurveCircle\nGenerate a poly spline circle\n\n\nCurveHandlePositions\nRetrieve the position of each Bézier control point’s handles\n\n\nCurveLength\nRetrieve the length of all splines added together\n\n\nCurveLine\nGenerate a poly spline line with two points\n\n\nCurveOfPoint\nRetrieve the curve a control point is part of\n\n\nCurveTilt\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\nCurveToPoints\nGenerate a point cloud by sampling positions along curves\n\n\nCurvesToGreasePencil\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\nDeformCurvesOnSurface\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\nEdgePathsToCurves\nOutput curves following paths across mesh edges\n\n\nEndpointSelection\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\nFillCurve\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\nFilletCurve\nRound corners by generating circular arcs on each control point\n\n\nFloatCurve\nMap an input float to a curve and outputs a float value\n\n\nGreasePencilToCurves\nConvert Grease Pencil layers into curve instances\n\n\nHandleTypeSelection\nProvide a selection based on the handle types of Bézier control points\n\n\nInterpolateCurves\nGenerate new curves on points by interpolating between existing curves\n\n\nOffsetPointInCurve\nOffset a control point index within its curve\n\n\nPointsOfCurve\nRetrieve a point index within a curve\n\n\nPointsToCurves\nSplit all points to curve by its group ID and reorder by weight\n\n\nQuadraticBezier\nGenerate a poly spline in a parabola shape with control points positions\n\n\nQuadrilateral\nGenerate a polygon with four points\n\n\nResampleCurve\nGenerate a poly spline for each input spline\n\n\nReverseCurve\nChange the direction of curves by swapping their start and end data\n\n\nRgbCurves\nApply color corrections for each color channel\n\n\nSampleCurve\nRetrieve data from a point on a curve at a certain distance from its start\n\n\nSetCurveNormal\nSet the evaluation mode for curve normals\n\n\nSetCurveRadius\nSet the radius of the curve at each control point\n\n\nSetCurveTilt\nSet the tilt angle at each curve control point\n\n\nSetHandlePositions\nSet the positions for the handles of Bézier curves\n\n\nSetHandleType\nSet the handle type for the control points of a Bézier curve\n\n\nSetSplineType\nChange the type of curves\n\n\nSpiral\nGenerate a poly spline in a spiral shape\n\n\nStar\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\nStringToCurves\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\nSubdivideCurve\nDividing each curve segment into a specified number of pieces\n\n\nTrimCurve\nShorten curves by removing portions at the start or end\n\n\n\n\n\nnodes.curve.Arc(\n    resolution=16,\n    radius=1.0,\n    start_angle=0.0,\n    sweep_angle=5.497786998748779,\n    connect_center=False,\n    invert_arc=False,\n    mode='RADIUS',\n    **kwargs,\n)\nGenerate a poly spline arc\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_connect_center\nInput socket: Connect Center\n\n\ni_invert_arc\nInput socket: Invert Arc\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start_angle\nInput socket: Start Angle\n\n\ni_sweep_angle\nInput socket: Sweep Angle\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.BezierSegment(\n    resolution=16,\n    start=[-1.0, 0.0, 0.0],\n    start_handle=[-0.5, 0.5, 0.0],\n    end_handle=[0.0, 0.0, 0.0],\n    end=[1.0, 0.0, 0.0],\n    mode='POSITION',\n    **kwargs,\n)\nGenerate a 2D Bézier spline from the given control points and handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_end_handle\nInput socket: End Handle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\ni_start_handle\nInput socket: Start Handle\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveCircle(resolution=32, radius=1.0, mode='RADIUS', **kwargs)\nGenerate a poly spline circle\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution\nInput socket: Resolution\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveHandlePositions(relative=False, **kwargs)\nRetrieve the position of each Bézier control point’s handles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_relative\nInput socket: Relative\n\n\no_left\nOutput socket: Left\n\n\no_right\nOutput socket: Right\n\n\n\n\n\n\n\nnodes.curve.CurveLength(curve=None, **kwargs)\nRetrieve the length of all splines added together\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.curve.CurveLine(\n    start=[0.0, 0.0, 0.0],\n    end=[0.0, 0.0, 1.0],\n    mode='POINTS',\n    **kwargs,\n)\nGenerate a poly spline line with two points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.CurveOfPoint(point_index=0, **kwargs)\nRetrieve the curve a control point is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_point_index\nInput socket: Point Index\n\n\no_curve_index\nOutput socket: Curve Index\n\n\no_index_in_curve\nOutput socket: Index in Curve\n\n\n\n\n\n\n\nnodes.curve.CurveTilt(**kwargs)\nRetrieve the angle at each control point used to twist the curve’s normal around its tangent\n\n\n\n\n\nName\nDescription\n\n\n\n\no_tilt\nOutput socket: Tilt\n\n\n\n\n\n\n\nnodes.curve.CurveToPoints(curve=None, count=10, mode='COUNT', **kwargs)\nGenerate a point cloud by sampling positions along curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.curve.CurvesToGreasePencil(\n    curves=None,\n    selection=True,\n    instances_as_layers=True,\n    **kwargs,\n)\nConvert the curves in each top-level instance into Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\ni_instances_as_layers\nInput socket: Instances as Layers\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.curve.DeformCurvesOnSurface(curves=None, **kwargs)\nTranslate and rotate curves based on changes between the object’s original and evaluated surface mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curves\nInput socket: Curves\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.EdgePathsToCurves(\n    mesh=None,\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput curves following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.EndpointSelection(start_size=1, end_size=1, **kwargs)\nProvide a selection for an arbitrary number of endpoints in each spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_size\nInput socket: End Size\n\n\ni_start_size\nInput socket: Start Size\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.curve.FillCurve(curve=None, group_id=0, mode='Triangles', **kwargs)\nGenerate a mesh on the XY plane with faces on the inside of input curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mode\nInput socket: Mode\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.curve.FilletCurve(\n    curve=None,\n    radius=0.25,\n    limit_radius=False,\n    mode='Bézier',\n    count=1,\n    **kwargs,\n)\nRound corners by generating circular arcs on each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_limit_radius\nInput socket: Limit Radius\n\n\ni_mode\nInput socket: Mode\n\n\ni_radius\nInput socket: Radius\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.FloatCurve(factor=1.0, value=1.0, **kwargs)\nMap an input float to a curve and outputs a float value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.curve.GreasePencilToCurves(\n    grease_pencil=None,\n    selection=True,\n    layers_as_instances=True,\n    **kwargs,\n)\nConvert Grease Pencil layers into curve instances\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_layers_as_instances\nInput socket: Layers as Instances\n\n\ni_selection\nInput socket: Selection\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.HandleTypeSelection(\n    handle_type='AUTO',\n    mode=\"{'LEFT', 'RIGHT'}\",\n    **kwargs,\n)\nProvide a selection based on the handle types of Bézier control points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.curve.InterpolateCurves(\n    guide_curves=None,\n    guide_up=[0.0, 0.0, 0.0],\n    guide_group_id=0,\n    points=None,\n    point_up=[0.0, 0.0, 0.0],\n    point_group_id=0,\n    max_neighbors=4,\n    **kwargs,\n)\nGenerate new curves on points by interpolating between existing curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_guide_curves\nInput socket: Guide Curves\n\n\ni_guide_group_id\nInput socket: Guide Group ID\n\n\ni_guide_up\nInput socket: Guide Up\n\n\ni_max_neighbors\nInput socket: Max Neighbors\n\n\ni_point_group_id\nInput socket: Point Group ID\n\n\ni_point_up\nInput socket: Point Up\n\n\ni_points\nInput socket: Points\n\n\no_closest_index\nOutput socket: Closest Index\n\n\no_closest_weight\nOutput socket: Closest Weight\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.OffsetPointInCurve(point_index=0, offset=0, **kwargs)\nOffset a control point index within its curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_offset\nInput socket: Offset\n\n\ni_point_index\nInput socket: Point Index\n\n\no_is_valid_offset\nOutput socket: Is Valid Offset\n\n\no_point_index\nOutput socket: Point Index\n\n\n\n\n\n\n\nnodes.curve.PointsOfCurve(curve_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve a point index within a curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_point_index\nOutput socket: Point Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.curve.PointsToCurves(points=None, curve_group_id=0, weight=0.0, **kwargs)\nSplit all points to curve by its group ID and reorder by weight\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_group_id\nInput socket: Curve Group ID\n\n\ni_points\nInput socket: Points\n\n\ni_weight\nInput socket: Weight\n\n\no_curves\nOutput socket: Curves\n\n\n\n\n\n\n\nnodes.curve.QuadraticBezier(\n    resolution=16,\n    start=[-1.0, 0.0, 0.0],\n    middle=[0.0, 2.0, 0.0],\n    end=[1.0, 0.0, 0.0],\n    **kwargs,\n)\nGenerate a poly spline in a parabola shape with control points positions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end\nInput socket: End\n\n\ni_middle\nInput socket: Middle\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Quadrilateral(width=2.0, height=2.0, mode='RECTANGLE', **kwargs)\nGenerate a polygon with four points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_height\nInput socket: Height\n\n\ni_width\nInput socket: Width\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.ResampleCurve(\n    curve=None,\n    selection=True,\n    mode='Count',\n    count=10,\n    length=0.10000000149011612,\n    keep_last_segment=False,\n    **kwargs,\n)\nGenerate a poly spline for each input spline\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_curve\nInput socket: Curve\n\n\ni_length\nInput socket: Length\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.ReverseCurve(curve=None, selection=True, **kwargs)\nChange the direction of curves by swapping their start and end data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.RgbCurves(fac=1.0, color=[1.0, 1.0, 1.0, 1.0], **kwargs)\nApply color corrections for each color channel\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_factor\nInput socket: Factor\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.curve.SampleCurve(\n    curves=None,\n    value=0.0,\n    factor=0.0,\n    curve_index=0,\n    mode='FACTOR',\n    use_all_curves=False,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data from a point on a curve at a certain distance from its start\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve_index\nInput socket: Curve Index\n\n\ni_curves\nInput socket: Curves\n\n\ni_factor\nInput socket: Factor\n\n\ni_value\nInput socket: Value\n\n\no_normal\nOutput socket: Normal\n\n\no_position\nOutput socket: Position\n\n\no_tangent\nOutput socket: Tangent\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.curve.SetCurveNormal(\n    curve=None,\n    selection=True,\n    mode='Minimum Twist',\n    normal=[0.0, 0.0, 1.0],\n    **kwargs,\n)\nSet the evaluation mode for curve normals\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_mode\nInput socket: Mode\n\n\ni_normal\nInput socket: Normal\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetCurveRadius(\n    curve=None,\n    selection=True,\n    radius=0.004999999888241291,\n    **kwargs,\n)\nSet the radius of the curve at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetCurveTilt(curve=None, selection=True, tilt=0.0, **kwargs)\nSet the tilt angle at each curve control point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\ni_tilt\nInput socket: Tilt\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetHandlePositions(\n    curve=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    mode='LEFT',\n    **kwargs,\n)\nSet the positions for the handles of Bézier curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetHandleType(\n    curve=None,\n    selection=True,\n    handle_type='AUTO',\n    mode=\"{'LEFT', 'RIGHT'}\",\n    **kwargs,\n)\nSet the handle type for the control points of a Bézier curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.SetSplineType(\n    curve=None,\n    selection=True,\n    spline_type='POLY',\n    **kwargs,\n)\nChange the type of curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Spiral(\n    resolution=32,\n    rotations=2.0,\n    start_radius=1.0,\n    end_radius=2.0,\n    height=2.0,\n    reverse=False,\n    **kwargs,\n)\nGenerate a poly spline in a spiral shape\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_end_radius\nInput socket: End Radius\n\n\ni_height\nInput socket: Height\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_reverse\nInput socket: Reverse\n\n\ni_rotations\nInput socket: Rotations\n\n\ni_start_radius\nInput socket: Start Radius\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.Star(\n    points=8,\n    inner_radius=1.0,\n    outer_radius=2.0,\n    twist=0.0,\n    **kwargs,\n)\nGenerate a poly spline in a star pattern by connecting alternating points of two circles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_inner_radius\nInput socket: Inner Radius\n\n\ni_outer_radius\nInput socket: Outer Radius\n\n\ni_points\nInput socket: Points\n\n\ni_twist\nInput socket: Twist\n\n\no_curve\nOutput socket: Curve\n\n\no_outer_points\nOutput socket: Outer Points\n\n\n\n\n\n\n\nnodes.curve.StringToCurves(\n    string='',\n    size=1.0,\n    character_spacing=1.0,\n    word_spacing=1.0,\n    line_spacing=1.0,\n    text_box_width=0.0,\n    overflow='OVERFLOW',\n    align_x='LEFT',\n    align_y='TOP_BASELINE',\n    pivot_mode='BOTTOM_LEFT',\n    **kwargs,\n)\nGenerate a paragraph of text with a specific font, using a curve instance to store each character\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_character_spacing\nInput socket: Character Spacing\n\n\ni_line_spacing\nInput socket: Line Spacing\n\n\ni_size\nInput socket: Size\n\n\ni_string\nInput socket: String\n\n\ni_text_box_width\nInput socket: Text Box Width\n\n\ni_word_spacing\nInput socket: Word Spacing\n\n\no_curve_instances\nOutput socket: Curve Instances\n\n\no_line\nOutput socket: Line\n\n\no_pivot_point\nOutput socket: Pivot Point\n\n\n\n\n\n\n\nnodes.curve.SubdivideCurve(curve=None, cuts=1, **kwargs)\nDividing each curve segment into a specified number of pieces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cuts\nInput socket: Cuts\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.curve.TrimCurve(\n    curve=None,\n    selection=True,\n    start=0.0,\n    end=1.0,\n    mode='FACTOR',\n    **kwargs,\n)\nShorten curves by removing portions at the start or end\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_end\nInput socket: End\n\n\ni_selection\nInput socket: Selection\n\n\ni_start\nInput socket: Start\n\n\no_curve\nOutput socket: Curve",
    "crumbs": [
      "Some functions",
      "nodes.curve"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nodebpy",
    "section": "",
    "text": "A package to help build node trees in blender more elegantly with python code."
  },
  {
    "objectID": "index.html#the-design-idea",
    "href": "index.html#the-design-idea",
    "title": "nodebpy",
    "section": "The Design Idea",
    "text": "The Design Idea\nOther projects have attempted similar but none quite handled the API how I felt it should be done. Notable existing projects are geometry-script, geonodes, NodeToPython.\nOther projects implement chaining of nodes mostly as dot methos of nodes to chain them (InstanceOnPoints().set_position()). This has the potential to crowd the API for individual nodes and easy chaining is instead approached via overriding the &gt;&gt; operator.\n\nChain Nodes with &gt;&gt;\nBy default the operator attempts to link the first output of the previous node with the first input of the next. You can override this behaviour by being explicit with the socket you are passing out (AccumulateField().o_total) or using the ... for the inputs into the next node. The dots can appear at multiple locations and each input will be linked to the previous node via the inferred or specified socket."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.geometry\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.attribute\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.curve\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.input\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.mesh\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.utilities\nAuto-generated Blender Geometry Node classes.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#some-functions",
    "href": "reference/index.html#some-functions",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nnodes.geometry\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.attribute\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.curve\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.input\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.mesh\nAuto-generated Blender Geometry Node classes.\n\n\nnodes.utilities\nAuto-generated Blender Geometry Node classes.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html",
    "href": "reference/nodes.geometry.html",
    "title": "nodes.geometry",
    "section": "",
    "text": "nodes.geometry\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nDCursor3\nThe scene’s 3D cursor location and rotation\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDialGizmo\nShow a dial gizmo in the viewport for a value\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nGetListItem\nRetrieve a value from a list\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGroup\nGroup node\n\n\nImageInfo\nRetrieve information about an image\n\n\nImageTexture\nSample values from an image texture\n\n\nImportCSV\nImport geometry from an CSV file\n\n\nImportOBJ\nImport geometry from an OBJ file\n\n\nImportPLY\nImport a point cloud from a PLY file\n\n\nImportSTL\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVDB\nImport volume data from a .vdb file\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nJoinStrings\nCombine any number of input strings\n\n\nLinearGizmo\nShow a linear gizmo in the viewport for a value\n\n\nList\nCreate a list of values\n\n\nListLength\nCount how many items are in a given list\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nPackUVIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToSDFGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSDFGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSDFGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSDFGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSDFGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSDFGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSDFGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSDFGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUVSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nSetID\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTransformGizmo\nShow a transform gizmo in the viewport\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nUVTangent\nGenerate tangent directions based on a UV map\n\n\nUVUnwrap\nGenerate a UV map based on seam edges\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewer\nDisplay the input data in the Spreadsheet Editor\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\nWarning\nCreate custom warnings in node groups\n\n\n\n\n\nnodes.geometry.AccumulateField(\n    value=1.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\n\n\n\n\n\nnodes.geometry.ActiveElement(domain='POINT', **kwargs)\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.AdvectGrid(\n    grid=0.0,\n    velocity=[0.0, 0.0, 0.0],\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    data_type='FLOAT',\n    **kwargs,\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Bake(extend=None, active_index=0, **kwargs)\nCache the incoming data so that it can be used without recomputation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True, **kwargs)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.CameraInfo(camera=None, **kwargs)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\n\n\n\n\n\nnodes.geometry.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None, **kwargs)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\n\n\n\n\n\nnodes.geometry.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfFace(face_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.DCursor3(**kwargs)\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    mode='ALL',\n    domain='POINT',\n    **kwargs,\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.DialGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    up=[0.0, 0.0, 1.0],\n    screen_space=True,\n    radius=1.0,\n    color_id='PRIMARY',\n    **kwargs,\n)\nShow a dial gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_screen_space\nInput socket: Screen Space\n\n\ni_up\nInput socket: Up\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    mode='DENSITY_RANDOM',\n    **kwargs,\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=[0.30000001192092896, 0.30000001192092896, 0.30000001192092896],\n    threshold=0.10000000149011612,\n    **kwargs,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    density=10.0,\n    seed=0,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n    **kwargs,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    domain='POINT',\n    **kwargs,\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.EdgePathsToSelection(\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfCorner(corner_index=0, **kwargs)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.EdgesToFaceGroups(boundary_edges=True, **kwargs)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\n\n\n\n\n\nnodes.geometry.EvaluateAtIndex(\n    value=0.0,\n    index=0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.EvaluateOnDomain(\n    value=0.0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.FaceOfCorner(corner_index=0, **kwargs)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\n\n\n\n\n\nnodes.geometry.FaceSet(**kwargs)\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\n\n\n\n\n\nnodes.geometry.FieldAverage(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\n\n\n\n\n\nnodes.geometry.FieldMinMax(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.FieldToGrid(\n    topology=0.0,\n    extend=None,\n    active_index=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ni_topology\nInput socket: Topology\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.FieldVariance(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True, **kwargs)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ForEachGeometryElementOutput(\n    extend_main=None,\n    generation_0=None,\n    extend_generation=None,\n    active_input_index=0,\n    active_generation_index=0,\n    active_main_index=0,\n    domain='POINT',\n    inspection_index=0,\n    **kwargs,\n)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_extend_generation\nInput socket:\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\no_extend_generation\nOutput socket:\n\n\no_generation_0\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    target_element='FACES',\n    **kwargs,\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.geometry.GeometryToInstance(geometry=None, **kwargs)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.GetListItem(list=0.0, index=0, data_type='FLOAT', **kwargs)\nRetrieve a value from a list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_list\nInput socket: List\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.GetNamedGrid(\n    volume=None,\n    name='',\n    remove=True,\n    data_type='FLOAT',\n    **kwargs,\n)\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.GridCurl(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_curl\nOutput socket: Curl\n\n\n\n\n\n\n\nnodes.geometry.GridDivergence(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_divergence\nOutput socket: Divergence\n\n\n\n\n\n\n\nnodes.geometry.GridGradient(grid=0.0, **kwargs)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_gradient\nOutput socket: Gradient\n\n\n\n\n\n\n\nnodes.geometry.GridInfo(grid=0.0, data_type='FLOAT', **kwargs)\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.GridLaplacian(grid=0.0, **kwargs)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_laplacian\nOutput socket: Laplacian\n\n\n\n\n\n\n\nnodes.geometry.Group(**kwargs)\nGroup node\n\n\n\nnodes.geometry.ImageInfo(image=None, frame=0, **kwargs)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\n\n\n\n\n\nnodes.geometry.ImageTexture(\n    image=None,\n    vector=[0.0, 0.0, 0.0],\n    frame=0,\n    interpolation='Linear',\n    extension='REPEAT',\n    **kwargs,\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.geometry.ImportCSV(path='', delimiter=',', **kwargs)\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\n\n\n\n\n\nnodes.geometry.ImportOBJ(path='', **kwargs)\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ImportPLY(path='', **kwargs)\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportSTL(path='', **kwargs)\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportText(path='', **kwargs)\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.ImportVDB(path='', **kwargs)\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.IndexOfNearest(position=[0.0, 0.0, 0.0], group_id=0, **kwargs)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.InstanceTransform(**kwargs)\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    **kwargs,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.IsViewport(**kwargs)\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\n\n\n\n\n\nnodes.geometry.JoinStrings(delimiter='', strings='', **kwargs)\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.LinearGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    direction=[0.0, 0.0, 1.0],\n    color_id='PRIMARY',\n    draw_style='ARROW',\n    **kwargs,\n)\nShow a linear gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_position\nInput socket: Position\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.List(count=1, value=0.0, data_type='FLOAT', **kwargs)\nCreate a list of values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_value\nInput socket: Value\n\n\no_list\nOutput socket: List\n\n\n\n\n\n\n\nnodes.geometry.ListLength(list=0.0, data_type='FLOAT', **kwargs)\nCount how many items are in a given list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_list\nInput socket: List\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None, **kwargs)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.0010000000474974513,\n    **kwargs,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    mode='MERGE_BY_NAME',\n    **kwargs,\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.MousePosition(**kwargs)\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\n\n\n\n\n\nnodes.geometry.ObjectInfo(\n    object=None,\n    as_instance=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.OffsetCornerInFace(corner_index=0, offset=0, **kwargs)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\no_corner_index\nOutput socket: Corner Index\n\n\n\n\n\n\n\nnodes.geometry.PackUVIslands(\n    uv=[0.0, 0.0, 0.0],\n    selection=True,\n    margin=0.0010000000474974513,\n    rotate=True,\n    method='Bounding Box',\n    **kwargs,\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.Points(\n    count=1,\n    position=[0.0, 0.0, 0.0],\n    radius=0.10000000149011612,\n    **kwargs,\n)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.PointsToSDFGrid(\n    points=None,\n    radius=0.5,\n    voxel_size=0.30000001192092896,\n    **kwargs,\n)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True, **kwargs)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    radius=0.5,\n    **kwargs,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.009999999776482582,\n    data_type='FLOAT',\n    **kwargs,\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=[0.0, 0.0, 0.0],\n    ray_direction=[0.0, 0.0, -1.0],\n    ray_length=100.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n    **kwargs,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None, **kwargs)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=[0.0, 0.0, 0.0],\n    pivot_point=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SDFGridBoolean(\n    grid_1=0.0,\n    grid_2=0.0,\n    operation='DIFFERENCE',\n    **kwargs,\n)\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\nunion\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SDFGridBoolean.difference(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.SDFGridBoolean.intersect(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.SDFGridBoolean.union(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SDFGridFillet(grid=0.0, iterations=1, **kwargs)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridLaplacian(grid=0.0, iterations=1, **kwargs)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMean(grid=0.0, width=1, iterations=1, **kwargs)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMeanCurvature(grid=0.0, iterations=1, **kwargs)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMedian(grid=0.0, width=1, iterations=1, **kwargs)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridOffset(grid=0.0, distance=0.10000000149011612, **kwargs)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SampleGrid(\n    grid=0.0,\n    position=[0.0, 0.0, 0.0],\n    interpolation='Trilinear',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleGridIndex(\n    grid=0.0,\n    x=0,\n    y=0,\n    z=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n    **kwargs,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=[0.0, 0.0, 0.0],\n    domain='POINT',\n    **kwargs,\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleUVSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=[0.0, 0.0, 0.0],\n    sample_uv=[0.0, 0.0, 0.0],\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=[0.0, 0.0, 0.0],\n    scale_mode='Uniform',\n    axis=[1.0, 0.0, 0.0],\n    domain='FACE',\n    **kwargs,\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=[1.0, 1.0, 1.0],\n    center=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Selection(**kwargs)\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\no_float\nOutput socket: Float\n\n\n\n\n\n\n\nnodes.geometry.SelfObject(**kwargs)\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\no_self_object\nOutput socket: Self Object\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None, **kwargs)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    **kwargs,\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0, **kwargs)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='', **kwargs)\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=[1.0, 1.0, 1.0, 1.0],\n    opacity=1.0,\n    mode='STROKE',\n    **kwargs,\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(\n    grease_pencil=None,\n    depth_order='2D',\n    **kwargs,\n)\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n    **kwargs,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGridBackground(\n    grid=0.0,\n    background=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SetGridTransform(\n    grid=0.0,\n    transform=None,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\n\n\n\n\n\nnodes.geometry.SetID(geometry=None, selection=True, id=0, **kwargs)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n    **kwargs,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(\n    geometry=None,\n    selection=True,\n    material=None,\n    **kwargs,\n)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(\n    geometry=None,\n    selection=True,\n    material_index=0,\n    **kwargs,\n)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetPointRadius(\n    points=None,\n    selection=True,\n    radius=0.05000000074505806,\n    **kwargs,\n)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    selection_type='BOOLEAN',\n    **kwargs,\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    domain='FACE',\n    **kwargs,\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(\n    geometry=None,\n    selection=True,\n    cyclic=False,\n    **kwargs,\n)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(\n    geometry=None,\n    selection=True,\n    resolution=12,\n    **kwargs,\n)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    domain='POINT',\n    **kwargs,\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SplineLength(**kwargs)\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.geometry.SplineParameter(**kwargs)\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True, **kwargs)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    domain='POINT',\n    **kwargs,\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.StoreNamedGrid(\n    volume=None,\n    name='',\n    grid=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n    **kwargs,\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    input_type='GEOMETRY',\n    **kwargs,\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\no_output\nOutput socket: Output\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    transform=None,\n    **kwargs,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.TransformGizmo(\n    value=None,\n    position=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    use_translation_x=False,\n    use_translation_y=False,\n    use_translation_z=False,\n    use_rotation_x=False,\n    use_rotation_y=False,\n    use_rotation_z=False,\n    use_scale_x=False,\n    use_scale_y=False,\n    use_scale_z=False,\n    **kwargs,\n)\nShow a transform gizmo in the viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n    **kwargs,\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.UVTangent(method='Exact', uv=[0.0, 0.0], **kwargs)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.geometry.UVUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.0010000000474974513,\n    fill_holes=True,\n    method='Angle Based',\n    **kwargs,\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.VertexOfCorner(corner_index=0, **kwargs)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\n\n\n\n\n\nnodes.geometry.Viewer(\n    extend=None,\n    ui_shortcut=0,\n    active_index=0,\n    domain='AUTO',\n    **kwargs,\n)\nDisplay the input data in the Spreadsheet Editor\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\n\n\n\n\n\nnodes.geometry.ViewportTransform(**kwargs)\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\n\n\n\n\n\nnodes.geometry.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=[-1.0, -1.0, -1.0],\n    max=[1.0, 1.0, 1.0],\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n    **kwargs,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.VoxelizeGrid(grid=0.0, data_type='FLOAT', **kwargs)\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Warning(show=True, message='', warning_type='ERROR', **kwargs)\nCreate custom warnings in node groups\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_message\nInput socket: Message\n\n\ni_show\nInput socket: Show\n\n\no_show\nOutput socket: Show",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  },
  {
    "objectID": "reference/nodes.geometry.html#classes",
    "href": "reference/nodes.geometry.html#classes",
    "title": "nodes.geometry",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAccumulateField\nAdd the values of an evaluated field together and output the running total for each element\n\n\nActiveElement\nActive element indices of the edited geometry, for tool execution\n\n\nAdvectGrid\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\nBake\nCache the incoming data so that it can be used without recomputation\n\n\nBoundingBox\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\nCameraInfo\nRetrieve information from a camera object\n\n\nCollectionInfo\nRetrieve geometry instances from a collection\n\n\nConvexHull\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\nCornersOfEdge\nRetrieve face corners connected to edges\n\n\nCornersOfFace\nRetrieve corners that make up a face\n\n\nCornersOfVertex\nRetrieve face corners connected to vertices\n\n\nDCursor3\nThe scene’s 3D cursor location and rotation\n\n\nDeleteGeometry\nRemove selected elements of a geometry\n\n\nDialGizmo\nShow a dial gizmo in the viewport for a value\n\n\nDistributePointsInGrid\nGenerate points inside a volume grid\n\n\nDistributePointsInVolume\nGenerate points inside a volume\n\n\nDistributePointsOnFaces\nGenerate points spread out on the surface of a mesh\n\n\nDuplicateElements\nGenerate an arbitrary number copies of each selected input element\n\n\nEdgePathsToSelection\nOutput a selection of edges by following paths across mesh edges\n\n\nEdgesOfCorner\nRetrieve the edges on both sides of a face corner\n\n\nEdgesOfVertex\nRetrieve the edges connected to each vertex\n\n\nEdgesToFaceGroups\nGroup faces into regions surrounded by the selected boundary edges\n\n\nEvaluateAtIndex\nRetrieve data of other elements in the context’s geometry\n\n\nEvaluateOnDomain\nRetrieve values from a field on a different domain besides the domain from the context\n\n\nFaceOfCorner\nRetrieve the face each face corner is part of\n\n\nFaceSet\nEach face’s sculpt face set value\n\n\nFieldAverage\nCalculate the mean and median of a given field\n\n\nFieldMinMax\nCalculate the minimum and maximum of a given field\n\n\nFieldToGrid\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\nFieldVariance\nCalculate the standard deviation and variance of a given field\n\n\nFlipFaces\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\nForEachGeometryElementOutput\nFor Each Geometry Element Output node\n\n\nGeometryProximity\nCompute the closest location on the target geometry\n\n\nGeometryToInstance\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\nGetListItem\nRetrieve a value from a list\n\n\nGetNamedGrid\nGet volume grid from a volume geometry with the specified name\n\n\nGridCurl\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\nGridDivergence\nCalculate the flow into and out of each point of a directional vector grid\n\n\nGridGradient\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\nGridInfo\nRetrieve information about a volume grid\n\n\nGridLaplacian\nCompute the divergence of the gradient of the input grid\n\n\nGroup\nGroup node\n\n\nImageInfo\nRetrieve information about an image\n\n\nImageTexture\nSample values from an image texture\n\n\nImportCSV\nImport geometry from an CSV file\n\n\nImportOBJ\nImport geometry from an OBJ file\n\n\nImportPLY\nImport a point cloud from a PLY file\n\n\nImportSTL\nImport a mesh from an STL file\n\n\nImportText\nImport a string from a text file\n\n\nImportVDB\nImport volume data from a .vdb file\n\n\nIndexOfNearest\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\nInstanceOnPoints\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\nInstanceTransform\nRetrieve the full transformation of each instance in the geometry\n\n\nInstancesToPoints\nGenerate points at the origins of instances.\n\n\nIsViewport\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\nJoinStrings\nCombine any number of input strings\n\n\nLinearGizmo\nShow a linear gizmo in the viewport for a value\n\n\nList\nCreate a list of values\n\n\nListLength\nCount how many items are in a given list\n\n\nMaterialSelection\nProvide a selection of faces that use the specified material\n\n\nMergeByDistance\nMerge vertices or points within a given distance\n\n\nMergeLayers\nJoin groups of Grease Pencil layers into one\n\n\nMousePosition\nRetrieve the position of the mouse cursor\n\n\nObjectInfo\nRetrieve information from an object\n\n\nOffsetCornerInFace\nRetrieve corners in the same face as another\n\n\nPackUVIslands\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\nPoints\nGenerate a point cloud with positions and radii defined by fields\n\n\nPointsToSDFGrid\nCreate a signed distance volume grid from points\n\n\nPointsToVertices\nGenerate a mesh vertex for each point cloud point\n\n\nPointsToVolume\nGenerate a fog volume sphere around every point\n\n\nPruneGrid\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\nRaycast\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\nRealizeInstances\nConvert instances into real geometry data\n\n\nReplaceMaterial\nSwap one material with another\n\n\nRotateInstances\nRotate geometry instances in local or global space\n\n\nSDFGridBoolean\nCut, subtract, or join multiple SDF volume grid inputs\n\n\nSDFGridFillet\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\nSDFGridLaplacian\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\nSDFGridMean\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\nSDFGridMeanCurvature\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\nSDFGridMedian\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\nSDFGridOffset\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\nSampleGrid\nRetrieve values from the specified volume grid\n\n\nSampleGridIndex\nRetrieve volume grid values at specific voxels\n\n\nSampleIndex\nRetrieve values from specific geometry elements\n\n\nSampleNearest\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\nSampleNearestSurface\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\nSampleUVSurface\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\nScaleElements\nScale groups of connected edges and faces\n\n\nScaleInstances\nScale geometry instances in local or global space\n\n\nSelection\nUser selection of the edited geometry, for tool execution\n\n\nSelfObject\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\nSeparateComponents\nSplit a geometry into a separate output for each type of data in the geometry\n\n\nSeparateGeometry\nSplit a geometry into two geometry outputs based on a selection\n\n\nSetFaceSet\nSet sculpt face set values for faces\n\n\nSetGeometryName\nSet the name of a geometry for easier debugging\n\n\nSetGreasePencilColor\nSet color and opacity attributes on Grease Pencil geometry\n\n\nSetGreasePencilDepth\nSet the Grease Pencil depth order to use\n\n\nSetGreasePencilSoftness\nSet softness attribute on Grease Pencil geometry\n\n\nSetGridBackground\nSet the background value used for inactive voxels and tiles\n\n\nSetGridTransform\nSet the transform for the grid from index space into object space.\n\n\nSetID\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\nSetInstanceTransform\nSet the transformation matrix of every instance\n\n\nSetMaterial\nAssign a material to geometry elements\n\n\nSetMaterialIndex\nSet the material index for each selected geometry element\n\n\nSetPointRadius\nSet the display size of point cloud points\n\n\nSetPosition\nSet the location of each point\n\n\nSetSelection\nSet selection of the edited geometry, for tool execution\n\n\nSetShadeSmooth\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\nSetSplineCyclic\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\nSetSplineResolution\nControl how many evaluated points should be generated on every curve segment\n\n\nSortElements\nRearrange geometry elements, changing their indices\n\n\nSplineLength\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\nSplineParameter\nRetrieve how far along each spline a control point is\n\n\nSplitEdges\nDuplicate mesh edges and break connections with the surrounding faces\n\n\nSplitToInstances\nCreate separate geometries containing the elements from the same group\n\n\nStoreNamedGrid\nStore grid data in a volume geometry with the specified name\n\n\nSubdivisionSurface\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\nSwitch\nSwitch between two inputs\n\n\nTransformGeometry\nTranslate, rotate or scale the geometry\n\n\nTransformGizmo\nShow a transform gizmo in the viewport\n\n\nTranslateInstances\nMove top-level geometry instances in local or global space\n\n\nTriangulate\nConvert all faces in a mesh to triangular faces\n\n\nUVTangent\nGenerate tangent directions based on a UV map\n\n\nUVUnwrap\nGenerate a UV map based on seam edges\n\n\nVertexOfCorner\nRetrieve the vertex each face corner is attached to\n\n\nViewer\nDisplay the input data in the Spreadsheet Editor\n\n\nViewportTransform\nRetrieve the view direction and location of the 3D viewport\n\n\nVolumeCube\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\nVoxelizeGrid\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\nWarning\nCreate custom warnings in node groups\n\n\n\n\n\nnodes.geometry.AccumulateField(\n    value=1.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nAdd the values of an evaluated field together and output the running total for each element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_leading\nOutput socket: Leading\n\n\no_total\nOutput socket: Total\n\n\no_trailing\nOutput socket: Trailing\n\n\n\n\n\n\n\nnodes.geometry.ActiveElement(domain='POINT', **kwargs)\nActive element indices of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.AdvectGrid(\n    grid=0.0,\n    velocity=[0.0, 0.0, 0.0],\n    time_step=1.0,\n    integration_scheme='Runge-Kutta 3',\n    limiter='Clamp',\n    data_type='FLOAT',\n    **kwargs,\n)\nMove grid values through a velocity field using numerical integration. Supports multiple integration schemes for different accuracy and performance trade-offs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_integration_scheme\nInput socket: Integration Scheme\n\n\ni_limiter\nInput socket: Limiter\n\n\ni_time_step\nInput socket: Time Step\n\n\ni_velocity\nInput socket: Velocity\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Bake(extend=None, active_index=0, **kwargs)\nCache the incoming data so that it can be used without recomputation\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.BoundingBox(geometry=None, use_radius=True, **kwargs)\nCalculate the limits of a geometry’s positions and generate a box mesh with those dimensions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_bounding_box\nOutput socket: Bounding Box\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.CameraInfo(camera=None, **kwargs)\nRetrieve information from a camera object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_camera\nInput socket: Camera\n\n\no_clip_end\nOutput socket: Clip End\n\n\no_clip_start\nOutput socket: Clip Start\n\n\no_focal_length\nOutput socket: Focal Length\n\n\no_focus_distance\nOutput socket: Focus Distance\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_orthographic_scale\nOutput socket: Orthographic Scale\n\n\no_projection_matrix\nOutput socket: Projection Matrix\n\n\no_sensor\nOutput socket: Sensor\n\n\no_shift\nOutput socket: Shift\n\n\n\n\n\n\n\nnodes.geometry.CollectionInfo(\n    collection=None,\n    separate_children=False,\n    reset_children=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve geometry instances from a collection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_collection\nInput socket: Collection\n\n\ni_reset_children\nInput socket: Reset Children\n\n\ni_separate_children\nInput socket: Separate Children\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ConvexHull(geometry=None, **kwargs)\nCreate a mesh that encloses all points in the input geometry with the smallest number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_convex_hull\nOutput socket: Convex Hull\n\n\n\n\n\n\n\nnodes.geometry.CornersOfEdge(edge_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve face corners connected to edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_index\nInput socket: Edge Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfFace(face_index=0, weights=0.0, sort_index=0, **kwargs)\nRetrieve corners that make up a face\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_index\nInput socket: Face Index\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.CornersOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve face corners connected to vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_corner_index\nOutput socket: Corner Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.DCursor3(**kwargs)\nThe scene’s 3D cursor location and rotation\n\n\n\n\n\nName\nDescription\n\n\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DeleteGeometry(\n    geometry=None,\n    selection=True,\n    mode='ALL',\n    domain='POINT',\n    **kwargs,\n)\nRemove selected elements of a geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.DialGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    up=[0.0, 0.0, 1.0],\n    screen_space=True,\n    radius=1.0,\n    color_id='PRIMARY',\n    **kwargs,\n)\nShow a dial gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_screen_space\nInput socket: Screen Space\n\n\ni_up\nInput socket: Up\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInGrid(\n    grid=0.0,\n    density=1.0,\n    seed=0,\n    mode='DENSITY_RANDOM',\n    **kwargs,\n)\nGenerate points inside a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_grid\nInput socket: Grid\n\n\ni_seed\nInput socket: Seed\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsInVolume(\n    volume=None,\n    mode='Random',\n    density=1.0,\n    seed=0,\n    spacing=[0.30000001192092896, 0.30000001192092896, 0.30000001192092896],\n    threshold=0.10000000149011612,\n    **kwargs,\n)\nGenerate points inside a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mode\nInput socket: Mode\n\n\ni_seed\nInput socket: Seed\n\n\ni_spacing\nInput socket: Spacing\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.DistributePointsOnFaces(\n    mesh=None,\n    selection=True,\n    density=10.0,\n    seed=0,\n    distribute_method='RANDOM',\n    use_legacy_normal=False,\n    **kwargs,\n)\nGenerate points spread out on the surface of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_seed\nInput socket: Seed\n\n\ni_selection\nInput socket: Selection\n\n\no_normal\nOutput socket: Normal\n\n\no_points\nOutput socket: Points\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.geometry.DuplicateElements(\n    geometry=None,\n    selection=True,\n    amount=1,\n    domain='POINT',\n    **kwargs,\n)\nGenerate an arbitrary number copies of each selected input element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_amount\nInput socket: Amount\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_duplicate_index\nOutput socket: Duplicate Index\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.EdgePathsToSelection(\n    start_vertices=True,\n    next_vertex_index=-1,\n    **kwargs,\n)\nOutput a selection of edges by following paths across mesh edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_next_vertex_index\nInput socket: Next Vertex Index\n\n\ni_start_vertices\nInput socket: Start Vertices\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfCorner(corner_index=0, **kwargs)\nRetrieve the edges on both sides of a face corner\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_next_edge_index\nOutput socket: Next Edge Index\n\n\no_previous_edge_index\nOutput socket: Previous Edge Index\n\n\n\n\n\n\n\nnodes.geometry.EdgesOfVertex(\n    vertex_index=0,\n    weights=0.0,\n    sort_index=0,\n    **kwargs,\n)\nRetrieve the edges connected to each vertex\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_sort_index\nInput socket: Sort Index\n\n\ni_vertex_index\nInput socket: Vertex Index\n\n\ni_weights\nInput socket: Weights\n\n\no_edge_index\nOutput socket: Edge Index\n\n\no_total\nOutput socket: Total\n\n\n\n\n\n\n\nnodes.geometry.EdgesToFaceGroups(boundary_edges=True, **kwargs)\nGroup faces into regions surrounded by the selected boundary edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_edges\nInput socket: Boundary Edges\n\n\no_face_group_id\nOutput socket: Face Group ID\n\n\n\n\n\n\n\nnodes.geometry.EvaluateAtIndex(\n    value=0.0,\n    index=0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve data of other elements in the context’s geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.EvaluateOnDomain(\n    value=0.0,\n    domain='POINT',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from a field on a different domain besides the domain from the context\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.FaceOfCorner(corner_index=0, **kwargs)\nRetrieve the face each face corner is part of\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_face_index\nOutput socket: Face Index\n\n\no_index_in_face\nOutput socket: Index in Face\n\n\n\n\n\n\n\nnodes.geometry.FaceSet(**kwargs)\nEach face’s sculpt face set value\n\n\n\n\n\nName\nDescription\n\n\n\n\no_exists\nOutput socket: Exists\n\n\no_face_set\nOutput socket: Face Set\n\n\n\n\n\n\n\nnodes.geometry.FieldAverage(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the mean and median of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_mean\nOutput socket: Mean\n\n\no_median\nOutput socket: Median\n\n\n\n\n\n\n\nnodes.geometry.FieldMinMax(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the minimum and maximum of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.geometry.FieldToGrid(\n    topology=0.0,\n    extend=None,\n    active_index=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCreate new grids by evaluating new values on an existing volume grid topology\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\ni_topology\nInput socket: Topology\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.FieldVariance(\n    value=0.0,\n    group_index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    **kwargs,\n)\nCalculate the standard deviation and variance of a given field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_value\nInput socket: Value\n\n\no_standard_deviation\nOutput socket: Standard Deviation\n\n\no_variance\nOutput socket: Variance\n\n\n\n\n\n\n\nnodes.geometry.FlipFaces(mesh=None, selection=True, **kwargs)\nReverse the order of the vertices and edges of selected faces, flipping their normal direction\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ForEachGeometryElementOutput(\n    extend_main=None,\n    generation_0=None,\n    extend_generation=None,\n    active_input_index=0,\n    active_generation_index=0,\n    active_main_index=0,\n    domain='POINT',\n    inspection_index=0,\n    **kwargs,\n)\nFor Each Geometry Element Output node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_extend_generation\nInput socket:\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\no_extend_generation\nOutput socket:\n\n\no_generation_0\nOutput socket: Geometry\n\n\no_geometry\nOutput socket: Geometry\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.geometry.GeometryProximity(\n    target=None,\n    group_id=0,\n    source_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    target_element='FACES',\n    **kwargs,\n)\nCompute the closest location on the target geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_distance\nOutput socket: Distance\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.geometry.GeometryToInstance(geometry=None, **kwargs)\nConvert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.GetListItem(list=0.0, index=0, data_type='FLOAT', **kwargs)\nRetrieve a value from a list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_index\nInput socket: Index\n\n\ni_list\nInput socket: List\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.GetNamedGrid(\n    volume=None,\n    name='',\n    remove=True,\n    data_type='FLOAT',\n    **kwargs,\n)\nGet volume grid from a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\ni_remove\nInput socket: Remove\n\n\ni_volume\nInput socket: Volume\n\n\no_grid\nOutput socket: Grid\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.GridCurl(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the magnitude and direction of circulation of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_curl\nOutput socket: Curl\n\n\n\n\n\n\n\nnodes.geometry.GridDivergence(grid=[0.0, 0.0, 0.0], **kwargs)\nCalculate the flow into and out of each point of a directional vector grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_divergence\nOutput socket: Divergence\n\n\n\n\n\n\n\nnodes.geometry.GridGradient(grid=0.0, **kwargs)\nCalculate the direction and magnitude of the change in values of a scalar grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_gradient\nOutput socket: Gradient\n\n\n\n\n\n\n\nnodes.geometry.GridInfo(grid=0.0, data_type='FLOAT', **kwargs)\nRetrieve information about a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_background_value\nOutput socket: Background Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.GridLaplacian(grid=0.0, **kwargs)\nCompute the divergence of the gradient of the input grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_laplacian\nOutput socket: Laplacian\n\n\n\n\n\n\n\nnodes.geometry.Group(**kwargs)\nGroup node\n\n\n\nnodes.geometry.ImageInfo(image=None, frame=0, **kwargs)\nRetrieve information about an image\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\no_fps\nOutput socket: FPS\n\n\no_frame_count\nOutput socket: Frame Count\n\n\no_has_alpha\nOutput socket: Has Alpha\n\n\no_height\nOutput socket: Height\n\n\no_width\nOutput socket: Width\n\n\n\n\n\n\n\nnodes.geometry.ImageTexture(\n    image=None,\n    vector=[0.0, 0.0, 0.0],\n    frame=0,\n    interpolation='Linear',\n    extension='REPEAT',\n    **kwargs,\n)\nSample values from an image texture\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_frame\nInput socket: Frame\n\n\ni_image\nInput socket: Image\n\n\ni_vector\nInput socket: Vector\n\n\no_alpha\nOutput socket: Alpha\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.geometry.ImportCSV(path='', delimiter=',', **kwargs)\nImport geometry from an CSV file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_path\nInput socket: Path\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\n\n\n\n\n\nnodes.geometry.ImportOBJ(path='', **kwargs)\nImport geometry from an OBJ file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.ImportPLY(path='', **kwargs)\nImport a point cloud from a PLY file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportSTL(path='', **kwargs)\nImport a mesh from an STL file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.ImportText(path='', **kwargs)\nImport a string from a text file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.ImportVDB(path='', **kwargs)\nImport volume data from a .vdb file\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_path\nInput socket: Path\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.IndexOfNearest(position=[0.0, 0.0, 0.0], group_id=0, **kwargs)\nFind the nearest element in a group. Similar to the “Sample Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_position\nInput socket: Position\n\n\no_has_neighbor\nOutput socket: Has Neighbor\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.InstanceOnPoints(\n    points=None,\n    selection=True,\n    instance=None,\n    pick_instance=False,\n    instance_index=0,\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    **kwargs,\n)\nGenerate a reference to geometry at each of the input points, without duplicating its underlying data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instance\nInput socket: Instance\n\n\ni_instance_index\nInput socket: Instance Index\n\n\ni_pick_instance\nInput socket: Pick Instance\n\n\ni_points\nInput socket: Points\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.InstanceTransform(**kwargs)\nRetrieve the full transformation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.InstancesToPoints(\n    instances=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    **kwargs,\n)\nGenerate points at the origins of instances. Note: Nested instances are not affected by this node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.IsViewport(**kwargs)\nRetrieve whether the nodes are being evaluated for the viewport rather than the final render\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_viewport\nOutput socket: Is Viewport\n\n\n\n\n\n\n\nnodes.geometry.JoinStrings(delimiter='', strings='', **kwargs)\nCombine any number of input strings\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_delimiter\nInput socket: Delimiter\n\n\ni_strings\nInput socket: Strings\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.geometry.LinearGizmo(\n    value=0.0,\n    position=[0.0, 0.0, 0.0],\n    direction=[0.0, 0.0, 1.0],\n    color_id='PRIMARY',\n    draw_style='ARROW',\n    **kwargs,\n)\nShow a linear gizmo in the viewport for a value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_direction\nInput socket: Direction\n\n\ni_position\nInput socket: Position\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.List(count=1, value=0.0, data_type='FLOAT', **kwargs)\nCreate a list of values\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_value\nInput socket: Value\n\n\no_list\nOutput socket: List\n\n\n\n\n\n\n\nnodes.geometry.ListLength(list=0.0, data_type='FLOAT', **kwargs)\nCount how many items are in a given list\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_list\nInput socket: List\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.MaterialSelection(material=None, **kwargs)\nProvide a selection of faces that use the specified material\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_material\nInput socket: Material\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.MergeByDistance(\n    geometry=None,\n    selection=True,\n    mode='All',\n    distance=0.0010000000474974513,\n    **kwargs,\n)\nMerge vertices or points within a given distance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.MergeLayers(\n    grease_pencil=None,\n    selection=True,\n    mode='MERGE_BY_NAME',\n    **kwargs,\n)\nJoin groups of Grease Pencil layers into one\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.MousePosition(**kwargs)\nRetrieve the position of the mouse cursor\n\n\n\n\n\nName\nDescription\n\n\n\n\no_mouse_x\nOutput socket: Mouse X\n\n\no_mouse_y\nOutput socket: Mouse Y\n\n\no_region_height\nOutput socket: Region Height\n\n\no_region_width\nOutput socket: Region Width\n\n\n\n\n\n\n\nnodes.geometry.ObjectInfo(\n    object=None,\n    as_instance=False,\n    transform_space='ORIGINAL',\n    **kwargs,\n)\nRetrieve information from an object\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_as_instance\nInput socket: As Instance\n\n\ni_object\nInput socket: Object\n\n\no_geometry\nOutput socket: Geometry\n\n\no_location\nOutput socket: Location\n\n\no_rotation\nOutput socket: Rotation\n\n\no_scale\nOutput socket: Scale\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.OffsetCornerInFace(corner_index=0, offset=0, **kwargs)\nRetrieve corners in the same face as another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\ni_offset\nInput socket: Offset\n\n\no_corner_index\nOutput socket: Corner Index\n\n\n\n\n\n\n\nnodes.geometry.PackUVIslands(\n    uv=[0.0, 0.0, 0.0],\n    selection=True,\n    margin=0.0010000000474974513,\n    rotate=True,\n    method='Bounding Box',\n    **kwargs,\n)\nScale islands of a UV map and move them so they fill the UV space as much as possible\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_rotate\nInput socket: Rotate\n\n\ni_selection\nInput socket: Selection\n\n\ni_uv\nInput socket: UV\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.Points(\n    count=1,\n    position=[0.0, 0.0, 0.0],\n    radius=0.10000000149011612,\n    **kwargs,\n)\nGenerate a point cloud with positions and radii defined by fields\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.PointsToSDFGrid(\n    points=None,\n    radius=0.5,\n    voxel_size=0.30000001192092896,\n    **kwargs,\n)\nCreate a signed distance volume grid from points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.geometry.PointsToVertices(points=None, selection=True, **kwargs)\nGenerate a mesh vertex for each point cloud point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.PointsToVolume(\n    points=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    radius=0.5,\n    **kwargs,\n)\nGenerate a fog volume sphere around every point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.PruneGrid(\n    grid=0.0,\n    mode='Threshold',\n    threshold=0.009999999776482582,\n    data_type='FLOAT',\n    **kwargs,\n)\nMake the storage of a volume grid more efficient by collapsing data into tiles or inner nodes\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_mode\nInput socket: Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Raycast(\n    target_geometry=None,\n    attribute=0.0,\n    interpolation='Interpolated',\n    source_position=[0.0, 0.0, 0.0],\n    ray_direction=[0.0, 0.0, -1.0],\n    ray_length=100.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCast rays from the context geometry onto a target geometry, and retrieve information from each hit point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_attribute\nInput socket: Attribute\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_ray_direction\nInput socket: Ray Direction\n\n\ni_ray_length\nInput socket: Ray Length\n\n\ni_source_position\nInput socket: Source Position\n\n\ni_target_geometry\nInput socket: Target Geometry\n\n\no_attribute\nOutput socket: Attribute\n\n\no_hit_distance\nOutput socket: Hit Distance\n\n\no_hit_normal\nOutput socket: Hit Normal\n\n\no_hit_position\nOutput socket: Hit Position\n\n\no_is_hit\nOutput socket: Is Hit\n\n\n\n\n\n\n\nnodes.geometry.RealizeInstances(\n    geometry=None,\n    selection=True,\n    realize_all=True,\n    depth=0,\n    **kwargs,\n)\nConvert instances into real geometry data\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_realize_all\nInput socket: Realize All\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ReplaceMaterial(geometry=None, old=None, new=None, **kwargs)\nSwap one material with another\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_new\nInput socket: New\n\n\ni_old\nInput socket: Old\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.RotateInstances(\n    instances=None,\n    selection=True,\n    rotation=[0.0, 0.0, 0.0],\n    pivot_point=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nRotate geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_pivot_point\nInput socket: Pivot Point\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SDFGridBoolean(\n    grid_1=0.0,\n    grid_2=0.0,\n    operation='DIFFERENCE',\n    **kwargs,\n)\nCut, subtract, or join multiple SDF volume grid inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid_1\nInput socket: Grid 1\n\n\ni_grid_2\nInput socket: Grid 2\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\nintersect\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\nunion\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SDFGridBoolean.difference(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Difference’.\n\n\n\nnodes.geometry.SDFGridBoolean.intersect(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Intersect’.\n\n\n\nnodes.geometry.SDFGridBoolean.union(grid_1=0.0, grid_2=0.0)\nCreate SDF Grid Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.geometry.SDFGridFillet(grid=0.0, iterations=1, **kwargs)\nRound off concave internal corners in a signed distance field. Only affects areas with negative principal curvature, creating smoother transitions between surfaces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridLaplacian(grid=0.0, iterations=1, **kwargs)\nApply Laplacian flow smoothing to a signed distance field. Computationally efficient alternative to mean curvature flow, ideal when combined with SDF normalization\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMean(grid=0.0, width=1, iterations=1, **kwargs)\nApply mean (box) filter smoothing to a signed distance field. Fast separable averaging filter for general smoothing of the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMeanCurvature(grid=0.0, iterations=1, **kwargs)\nApply mean curvature flow smoothing to a signed distance field. Evolves the surface based on its mean curvature, naturally smoothing high-curvature regions more than flat areas\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridMedian(grid=0.0, width=1, iterations=1, **kwargs)\nApply median filter to a signed distance field. Reduces noise while preserving sharp features and edges in the distance field\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_iterations\nInput socket: Iterations\n\n\ni_width\nInput socket: Width\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SDFGridOffset(grid=0.0, distance=0.10000000149011612, **kwargs)\nOffset a signed distance field surface by a world-space distance. Dilates (positive) or erodes (negative) while maintaining the signed distance property\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_distance\nInput socket: Distance\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SampleGrid(\n    grid=0.0,\n    position=[0.0, 0.0, 0.0],\n    interpolation='Trilinear',\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve values from the specified volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_interpolation\nInput socket: Interpolation\n\n\ni_position\nInput socket: Position\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleGridIndex(\n    grid=0.0,\n    x=0,\n    y=0,\n    z=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nRetrieve volume grid values at specific voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_x\nInput socket: X\n\n\ni_y\nInput socket: Y\n\n\ni_z\nInput socket: Z\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleIndex(\n    geometry=None,\n    value=0.0,\n    index=0,\n    data_type='FLOAT',\n    domain='POINT',\n    clamp=False,\n    **kwargs,\n)\nRetrieve values from specific geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_index\nInput socket: Index\n\n\ni_value\nInput socket: Value\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleNearest(\n    geometry=None,\n    sample_position=[0.0, 0.0, 0.0],\n    domain='POINT',\n    **kwargs,\n)\nFind the element of a geometry closest to a position. Similar to the “Index of Nearest” node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_sample_position\nInput socket: Sample Position\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.geometry.SampleNearestSurface(\n    mesh=None,\n    value=0.0,\n    group_id=0,\n    sample_position=[0.0, 0.0, 0.0],\n    sample_group_id=0,\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated value of a mesh attribute on the closest point of its surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_group_id\nInput socket: Sample Group ID\n\n\ni_sample_position\nInput socket: Sample Position\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.SampleUVSurface(\n    mesh=None,\n    value=0.0,\n    source_uv_map=[0.0, 0.0, 0.0],\n    sample_uv=[0.0, 0.0, 0.0],\n    data_type='FLOAT',\n    **kwargs,\n)\nCalculate the interpolated values of a mesh attribute at a UV coordinate\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_sample_uv\nInput socket: Sample UV\n\n\ni_uv_map\nInput socket: UV Map\n\n\ni_value\nInput socket: Value\n\n\no_is_valid\nOutput socket: Is Valid\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.geometry.ScaleElements(\n    geometry=None,\n    selection=True,\n    scale=1.0,\n    center=[0.0, 0.0, 0.0],\n    scale_mode='Uniform',\n    axis=[1.0, 0.0, 0.0],\n    domain='FACE',\n    **kwargs,\n)\nScale groups of connected edges and faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_axis\nInput socket: Axis\n\n\ni_center\nInput socket: Center\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_scale\nInput socket: Scale\n\n\ni_scale_mode\nInput socket: Scale Mode\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.ScaleInstances(\n    instances=None,\n    selection=True,\n    scale=[1.0, 1.0, 1.0],\n    center=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nScale geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_center\nInput socket: Center\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_scale\nInput socket: Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Selection(**kwargs)\nUser selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\no_float\nOutput socket: Float\n\n\n\n\n\n\n\nnodes.geometry.SelfObject(**kwargs)\nRetrieve the object that contains the geometry nodes modifier currently being executed\n\n\n\n\n\nName\nDescription\n\n\n\n\no_self_object\nOutput socket: Self Object\n\n\n\n\n\n\n\nnodes.geometry.SeparateComponents(geometry=None, **kwargs)\nSplit a geometry into a separate output for each type of data in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\no_curve\nOutput socket: Curve\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\no_instances\nOutput socket: Instances\n\n\no_mesh\nOutput socket: Mesh\n\n\no_point_cloud\nOutput socket: Point Cloud\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SeparateGeometry(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    **kwargs,\n)\nSplit a geometry into two geometry outputs based on a selection\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_inverted\nOutput socket: Inverted\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.geometry.SetFaceSet(mesh=None, selection=True, face_set=0, **kwargs)\nSet sculpt face set values for faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_set\nInput socket: Face Set\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetGeometryName(geometry=None, name='', **kwargs)\nSet the name of a geometry for easier debugging\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_name\nInput socket: Name\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilColor(\n    grease_pencil=None,\n    selection=True,\n    color=[1.0, 1.0, 1.0, 1.0],\n    opacity=1.0,\n    mode='STROKE',\n    **kwargs,\n)\nSet color and opacity attributes on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_color\nInput socket: Color\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_opacity\nInput socket: Opacity\n\n\ni_selection\nInput socket: Selection\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilDepth(\n    grease_pencil=None,\n    depth_order='2D',\n    **kwargs,\n)\nSet the Grease Pencil depth order to use\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGreasePencilSoftness(\n    grease_pencil=None,\n    selection=True,\n    softness=0.0,\n    **kwargs,\n)\nSet softness attribute on Grease Pencil geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grease_pencil\nInput socket: Grease Pencil\n\n\ni_selection\nInput socket: Selection\n\n\ni_softness\nInput socket: Softness\n\n\no_grease_pencil\nOutput socket: Grease Pencil\n\n\n\n\n\n\n\nnodes.geometry.SetGridBackground(\n    grid=0.0,\n    background=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the background value used for inactive voxels and tiles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.SetGridTransform(\n    grid=0.0,\n    transform=None,\n    data_type='FLOAT',\n    **kwargs,\n)\nSet the transform for the grid from index space into object space.\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_transform\nInput socket: Transform\n\n\no_grid\nOutput socket: Grid\n\n\no_is_valid\nOutput socket: Is Valid\n\n\n\n\n\n\n\nnodes.geometry.SetID(geometry=None, selection=True, id=0, **kwargs)\nSet the id attribute on the input geometry, mainly used internally for randomizing\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_id\nInput socket: ID\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetInstanceTransform(\n    instances=None,\n    selection=True,\n    transform=None,\n    **kwargs,\n)\nSet the transformation matrix of every instance\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_selection\nInput socket: Selection\n\n\ni_transform\nInput socket: Transform\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.SetMaterial(\n    geometry=None,\n    selection=True,\n    material=None,\n    **kwargs,\n)\nAssign a material to geometry elements\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material\nInput socket: Material\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetMaterialIndex(\n    geometry=None,\n    selection=True,\n    material_index=0,\n    **kwargs,\n)\nSet the material index for each selected geometry element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_material_index\nInput socket: Material Index\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetPointRadius(\n    points=None,\n    selection=True,\n    radius=0.05000000074505806,\n    **kwargs,\n)\nSet the display size of point cloud points\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_points\nInput socket: Points\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.geometry.SetPosition(\n    geometry=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 0.0],\n    **kwargs,\n)\nSet the location of each point\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_offset\nInput socket: Offset\n\n\ni_position\nInput socket: Position\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetSelection(\n    geometry=None,\n    selection=True,\n    domain='POINT',\n    selection_type='BOOLEAN',\n    **kwargs,\n)\nSet selection of the edited geometry, for tool execution\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_selection\nInput socket: Selection\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SetShadeSmooth(\n    geometry=None,\n    selection=True,\n    shade_smooth=True,\n    domain='FACE',\n    **kwargs,\n)\nControl the smoothness of mesh normals around each face by changing the “shade smooth” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\ni_shade_smooth\nInput socket: Shade Smooth\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SetSplineCyclic(\n    geometry=None,\n    selection=True,\n    cyclic=False,\n    **kwargs,\n)\nControl whether each spline loops back on itself by changing the “cyclic” attribute\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_cyclic\nInput socket: Cyclic\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SetSplineResolution(\n    geometry=None,\n    selection=True,\n    resolution=12,\n    **kwargs,\n)\nControl how many evaluated points should be generated on every curve segment\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_resolution\nInput socket: Resolution\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.geometry.SortElements(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    sort_weight=0.0,\n    domain='POINT',\n    **kwargs,\n)\nRearrange geometry elements, changing their indices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\ni_sort_weight\nInput socket: Sort Weight\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.SplineLength(**kwargs)\nRetrieve the total length of each spline, as a distance or as a number of points\n\n\n\n\n\nName\nDescription\n\n\n\n\no_length\nOutput socket: Length\n\n\no_point_count\nOutput socket: Point Count\n\n\n\n\n\n\n\nnodes.geometry.SplineParameter(**kwargs)\nRetrieve how far along each spline a control point is\n\n\n\n\n\nName\nDescription\n\n\n\n\no_factor\nOutput socket: Factor\n\n\no_index\nOutput socket: Index\n\n\no_length\nOutput socket: Length\n\n\n\n\n\n\n\nnodes.geometry.SplitEdges(mesh=None, selection=True, **kwargs)\nDuplicate mesh edges and break connections with the surrounding faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.SplitToInstances(\n    geometry=None,\n    selection=True,\n    group_id=0,\n    domain='POINT',\n    **kwargs,\n)\nCreate separate geometries containing the elements from the same group\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_group_id\nInput socket: Group ID\n\n\ni_selection\nInput socket: Selection\n\n\no_group_id\nOutput socket: Group ID\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.StoreNamedGrid(\n    volume=None,\n    name='',\n    grid=0.0,\n    data_type='FLOAT',\n    **kwargs,\n)\nStore grid data in a volume geometry with the specified name\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\ni_name\nInput socket: Name\n\n\ni_volume\nInput socket: Volume\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.SubdivisionSurface(\n    mesh=None,\n    level=1,\n    edge_crease=0.0,\n    vertex_crease=0.0,\n    limit_surface=True,\n    uv_smooth='Keep Boundaries',\n    boundary_smooth='All',\n    **kwargs,\n)\nDivide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_boundary_smooth\nInput socket: Boundary Smooth\n\n\ni_edge_crease\nInput socket: Edge Crease\n\n\ni_level\nInput socket: Level\n\n\ni_limit_surface\nInput socket: Limit Surface\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_uv_smooth\nInput socket: UV Smooth\n\n\ni_vertex_crease\nInput socket: Vertex Crease\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.Switch(\n    switch=False,\n    false=None,\n    true=None,\n    input_type='GEOMETRY',\n    **kwargs,\n)\nSwitch between two inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_false\nInput socket: False\n\n\ni_switch\nInput socket: Switch\n\n\ni_true\nInput socket: True\n\n\no_output\nOutput socket: Output\n\n\n\n\n\n\n\nnodes.geometry.TransformGeometry(\n    geometry=None,\n    mode='Components',\n    translation=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    scale=[1.0, 1.0, 1.0],\n    transform=None,\n    **kwargs,\n)\nTranslate, rotate or scale the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_mode\nInput socket: Mode\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_scale\nInput socket: Scale\n\n\ni_transform\nInput socket: Transform\n\n\ni_translation\nInput socket: Translation\n\n\no_geometry\nOutput socket: Geometry\n\n\n\n\n\n\n\nnodes.geometry.TransformGizmo(\n    value=None,\n    position=[0.0, 0.0, 0.0],\n    rotation=[0.0, 0.0, 0.0],\n    use_translation_x=False,\n    use_translation_y=False,\n    use_translation_z=False,\n    use_rotation_x=False,\n    use_rotation_y=False,\n    use_rotation_z=False,\n    use_scale_x=False,\n    use_scale_y=False,\n    use_scale_z=False,\n    **kwargs,\n)\nShow a transform gizmo in the viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_position\nInput socket: Position\n\n\ni_rotation\nInput socket: Rotation\n\n\ni_value\nInput socket: Value\n\n\no_transform\nOutput socket: Transform\n\n\n\n\n\n\n\nnodes.geometry.TranslateInstances(\n    instances=None,\n    selection=True,\n    translation=[0.0, 0.0, 0.0],\n    local_space=True,\n    **kwargs,\n)\nMove top-level geometry instances in local or global space\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_instances\nInput socket: Instances\n\n\ni_local_space\nInput socket: Local Space\n\n\ni_selection\nInput socket: Selection\n\n\ni_translation\nInput socket: Translation\n\n\no_instances\nOutput socket: Instances\n\n\n\n\n\n\n\nnodes.geometry.Triangulate(\n    mesh=None,\n    selection=True,\n    quad_method='Shortest Diagonal',\n    n_gon_method='Beauty',\n    **kwargs,\n)\nConvert all faces in a mesh to triangular faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_n_gon_method\nInput socket: N-gon Method\n\n\ni_quad_method\nInput socket: Quad Method\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.geometry.UVTangent(method='Exact', uv=[0.0, 0.0], **kwargs)\nGenerate tangent directions based on a UV map\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_method\nInput socket: Method\n\n\ni_uv\nInput socket: UV\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.geometry.UVUnwrap(\n    selection=True,\n    seam=False,\n    margin=0.0010000000474974513,\n    fill_holes=True,\n    method='Angle Based',\n    **kwargs,\n)\nGenerate a UV map based on seam edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_fill_holes\nInput socket: Fill Holes\n\n\ni_margin\nInput socket: Margin\n\n\ni_method\nInput socket: Method\n\n\ni_seam\nInput socket: Seam\n\n\ni_selection\nInput socket: Selection\n\n\no_uv\nOutput socket: UV\n\n\n\n\n\n\n\nnodes.geometry.VertexOfCorner(corner_index=0, **kwargs)\nRetrieve the vertex each face corner is attached to\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_corner_index\nInput socket: Corner Index\n\n\no_vertex_index\nOutput socket: Vertex Index\n\n\n\n\n\n\n\nnodes.geometry.Viewer(\n    extend=None,\n    ui_shortcut=0,\n    active_index=0,\n    domain='AUTO',\n    **kwargs,\n)\nDisplay the input data in the Spreadsheet Editor\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_input_socket\nInput socket:\n\n\n\n\n\n\n\nnodes.geometry.ViewportTransform(**kwargs)\nRetrieve the view direction and location of the 3D viewport\n\n\n\n\n\nName\nDescription\n\n\n\n\no_is_orthographic\nOutput socket: Is Orthographic\n\n\no_projection\nOutput socket: Projection\n\n\no_view\nOutput socket: View\n\n\n\n\n\n\n\nnodes.geometry.VolumeCube(\n    density=1.0,\n    background=0.0,\n    min=[-1.0, -1.0, -1.0],\n    max=[1.0, 1.0, 1.0],\n    resolution_x=32,\n    resolution_y=32,\n    resolution_z=32,\n    **kwargs,\n)\nGenerate a dense volume with a field that controls the density at each grid voxel based on its position\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_background\nInput socket: Background\n\n\ni_density\nInput socket: Density\n\n\ni_max\nInput socket: Max\n\n\ni_min\nInput socket: Min\n\n\ni_resolution_x\nInput socket: Resolution X\n\n\ni_resolution_y\nInput socket: Resolution Y\n\n\ni_resolution_z\nInput socket: Resolution Z\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.geometry.VoxelizeGrid(grid=0.0, data_type='FLOAT', **kwargs)\nRemove sparseness from a volume grid by making the active tiles into voxels\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_grid\nInput socket: Grid\n\n\no_grid\nOutput socket: Grid\n\n\n\n\n\n\n\nnodes.geometry.Warning(show=True, message='', warning_type='ERROR', **kwargs)\nCreate custom warnings in node groups\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_message\nInput socket: Message\n\n\ni_show\nInput socket: Show\n\n\no_show\nOutput socket: Show",
    "crumbs": [
      "Some functions",
      "nodes.geometry"
    ]
  },
  {
    "objectID": "reference/nodes.input.html",
    "href": "reference/nodes.input.html",
    "title": "nodes.input",
    "section": "",
    "text": "nodes.input\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nActiveCamera\nRetrieve the scene’s active camera\n\n\nBoolean\nProvide a True/False value that can be connected to other nodes in the tree\n\n\nCollection\nOutput a single collection\n\n\nColor\nOutput a color value chosen with the color picker widget\n\n\nCurveTangent\nRetrieve the direction of curves at each control point\n\n\nForEachGeometryElementInput\nFor Each Geometry Element Input node\n\n\nID\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\nImage\nInput an image data-block\n\n\nIndex\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\nInstanceBounds\nCalculate position bounds of each instance’s geometry set\n\n\nInstanceRotation\nRetrieve the rotation of each instance in the geometry\n\n\nInstanceScale\nRetrieve the scale of each instance in the geometry\n\n\nInteger\nProvide an integer value that can be connected to other nodes in the tree\n\n\nIsEdgeSmooth\nRetrieve whether each edge is marked for smooth or split normals\n\n\nIsFaceSmooth\nRetrieve whether each face is marked for smooth or sharp normals\n\n\nIsSplineCyclic\nRetrieve whether each spline endpoint connects to the beginning\n\n\nMaterial\nOutput a single material\n\n\nMaterialIndex\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\nNamedLayerSelection\nOutput a selection of a Grease Pencil layer\n\n\nNormal\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\nObject\nOutput a single object\n\n\nPosition\nRetrieve a vector indicating the location of each element\n\n\nRadius\nRetrieve the radius at each point on curve or point cloud geometry\n\n\nRotation\nProvide a rotation value that can be connected to other nodes in the tree\n\n\nSceneTime\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\nShortestEdgePaths\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\nSpecialCharacters\nOutput string characters that cannot be typed directly with the keyboard\n\n\nSplineResolution\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\nString\nProvide a string value that can be connected to other nodes in the tree\n\n\nValue\nInput numerical values to other nodes in the tree\n\n\nVoxelIndex\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nnodes.input.ActiveCamera(**kwargs)\nRetrieve the scene’s active camera\n\n\n\n\n\nName\nDescription\n\n\n\n\no_active_camera\nOutput socket: Active Camera\n\n\n\n\n\n\n\nnodes.input.Boolean(boolean=False, **kwargs)\nProvide a True/False value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\n\n\n\n\n\nnodes.input.Collection(**kwargs)\nOutput a single collection\n\n\n\n\n\nName\nDescription\n\n\n\n\no_collection\nOutput socket: Collection\n\n\n\n\n\n\n\nnodes.input.Color(value=0.0, **kwargs)\nOutput a color value chosen with the color picker widget\n\n\n\n\n\nName\nDescription\n\n\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.input.CurveTangent(**kwargs)\nRetrieve the direction of curves at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.input.ForEachGeometryElementInput(\n    geometry=None,\n    selection=True,\n    extend=None,\n    **kwargs,\n)\nFor Each Geometry Element Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\ni_selection\nInput socket: Selection\n\n\no_index\nOutput socket: Index\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.input.ID(**kwargs)\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\n\n\n\nName\nDescription\n\n\n\n\no_id\nOutput socket: ID\n\n\n\n\n\n\n\nnodes.input.Image(**kwargs)\nInput an image data-block\n\n\n\n\n\nName\nDescription\n\n\n\n\no_image\nOutput socket: Image\n\n\n\n\n\n\n\nnodes.input.Index(**kwargs)\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\n\n\n\nName\nDescription\n\n\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.input.InstanceBounds(use_radius=True, **kwargs)\nCalculate position bounds of each instance’s geometry set\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.input.InstanceRotation(**kwargs)\nRetrieve the rotation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.input.InstanceScale(**kwargs)\nRetrieve the scale of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_scale\nOutput socket: Scale\n\n\n\n\n\n\n\nnodes.input.Integer(integer=1, **kwargs)\nProvide an integer value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_integer\nOutput socket: Integer\n\n\n\n\n\n\n\nnodes.input.IsEdgeSmooth(**kwargs)\nRetrieve whether each edge is marked for smooth or split normals\n\n\n\n\n\nName\nDescription\n\n\n\n\no_smooth\nOutput socket: Smooth\n\n\n\n\n\n\n\nnodes.input.IsFaceSmooth(**kwargs)\nRetrieve whether each face is marked for smooth or sharp normals\n\n\n\n\n\nName\nDescription\n\n\n\n\no_smooth\nOutput socket: Smooth\n\n\n\n\n\n\n\nnodes.input.IsSplineCyclic(**kwargs)\nRetrieve whether each spline endpoint connects to the beginning\n\n\n\n\n\nName\nDescription\n\n\n\n\no_cyclic\nOutput socket: Cyclic\n\n\n\n\n\n\n\nnodes.input.Material(**kwargs)\nOutput a single material\n\n\n\n\n\nName\nDescription\n\n\n\n\no_material\nOutput socket: Material\n\n\n\n\n\n\n\nnodes.input.MaterialIndex(**kwargs)\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\n\n\n\nName\nDescription\n\n\n\n\no_material_index\nOutput socket: Material Index\n\n\n\n\n\n\n\nnodes.input.NamedLayerSelection(name='', **kwargs)\nOutput a selection of a Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.input.Normal(legacy_corner_normals=False, **kwargs)\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\n\n\n\nName\nDescription\n\n\n\n\no_normal\nOutput socket: Normal\n\n\no_true_normal\nOutput socket: True Normal\n\n\n\n\n\n\n\nnodes.input.Object(**kwargs)\nOutput a single object\n\n\n\n\n\nName\nDescription\n\n\n\n\no_object\nOutput socket: Object\n\n\n\n\n\n\n\nnodes.input.Position(**kwargs)\nRetrieve a vector indicating the location of each element\n\n\n\n\n\nName\nDescription\n\n\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.input.Radius(**kwargs)\nRetrieve the radius at each point on curve or point cloud geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_radius\nOutput socket: Radius\n\n\n\n\n\n\n\nnodes.input.Rotation(rotation_euler=0.0, **kwargs)\nProvide a rotation value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.input.SceneTime(**kwargs)\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\n\n\n\nName\nDescription\n\n\n\n\no_frame\nOutput socket: Frame\n\n\no_seconds\nOutput socket: Seconds\n\n\n\n\n\n\n\nnodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0, **kwargs)\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_cost\nInput socket: Edge Cost\n\n\ni_end_vertex\nInput socket: End Vertex\n\n\no_next_vertex_index\nOutput socket: Next Vertex Index\n\n\no_total_cost\nOutput socket: Total Cost\n\n\n\n\n\n\n\nnodes.input.SpecialCharacters(**kwargs)\nOutput string characters that cannot be typed directly with the keyboard\n\n\n\n\n\nName\nDescription\n\n\n\n\no_line_break\nOutput socket: Line Break\n\n\no_tab\nOutput socket: Tab\n\n\n\n\n\n\n\nnodes.input.SplineResolution(**kwargs)\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\n\n\n\nName\nDescription\n\n\n\n\no_resolution\nOutput socket: Resolution\n\n\n\n\n\n\n\nnodes.input.String(string='', **kwargs)\nProvide a string value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.input.Value(**kwargs)\nInput numerical values to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.input.VoxelIndex(**kwargs)\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nName\nDescription\n\n\n\n\no_extent_x\nOutput socket: Extent X\n\n\no_extent_y\nOutput socket: Extent Y\n\n\no_extent_z\nOutput socket: Extent Z\n\n\no_is_tile\nOutput socket: Is Tile\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z",
    "crumbs": [
      "Some functions",
      "nodes.input"
    ]
  },
  {
    "objectID": "reference/nodes.input.html#classes",
    "href": "reference/nodes.input.html#classes",
    "title": "nodes.input",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nActiveCamera\nRetrieve the scene’s active camera\n\n\nBoolean\nProvide a True/False value that can be connected to other nodes in the tree\n\n\nCollection\nOutput a single collection\n\n\nColor\nOutput a color value chosen with the color picker widget\n\n\nCurveTangent\nRetrieve the direction of curves at each control point\n\n\nForEachGeometryElementInput\nFor Each Geometry Element Input node\n\n\nID\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\nImage\nInput an image data-block\n\n\nIndex\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\nInstanceBounds\nCalculate position bounds of each instance’s geometry set\n\n\nInstanceRotation\nRetrieve the rotation of each instance in the geometry\n\n\nInstanceScale\nRetrieve the scale of each instance in the geometry\n\n\nInteger\nProvide an integer value that can be connected to other nodes in the tree\n\n\nIsEdgeSmooth\nRetrieve whether each edge is marked for smooth or split normals\n\n\nIsFaceSmooth\nRetrieve whether each face is marked for smooth or sharp normals\n\n\nIsSplineCyclic\nRetrieve whether each spline endpoint connects to the beginning\n\n\nMaterial\nOutput a single material\n\n\nMaterialIndex\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\nNamedLayerSelection\nOutput a selection of a Grease Pencil layer\n\n\nNormal\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\nObject\nOutput a single object\n\n\nPosition\nRetrieve a vector indicating the location of each element\n\n\nRadius\nRetrieve the radius at each point on curve or point cloud geometry\n\n\nRotation\nProvide a rotation value that can be connected to other nodes in the tree\n\n\nSceneTime\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\nShortestEdgePaths\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\nSpecialCharacters\nOutput string characters that cannot be typed directly with the keyboard\n\n\nSplineResolution\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\nString\nProvide a string value that can be connected to other nodes in the tree\n\n\nValue\nInput numerical values to other nodes in the tree\n\n\nVoxelIndex\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nnodes.input.ActiveCamera(**kwargs)\nRetrieve the scene’s active camera\n\n\n\n\n\nName\nDescription\n\n\n\n\no_active_camera\nOutput socket: Active Camera\n\n\n\n\n\n\n\nnodes.input.Boolean(boolean=False, **kwargs)\nProvide a True/False value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_boolean\nOutput socket: Boolean\n\n\n\n\n\n\n\nnodes.input.Collection(**kwargs)\nOutput a single collection\n\n\n\n\n\nName\nDescription\n\n\n\n\no_collection\nOutput socket: Collection\n\n\n\n\n\n\n\nnodes.input.Color(value=0.0, **kwargs)\nOutput a color value chosen with the color picker widget\n\n\n\n\n\nName\nDescription\n\n\n\n\no_color\nOutput socket: Color\n\n\n\n\n\n\n\nnodes.input.CurveTangent(**kwargs)\nRetrieve the direction of curves at each control point\n\n\n\n\n\nName\nDescription\n\n\n\n\no_tangent\nOutput socket: Tangent\n\n\n\n\n\n\n\nnodes.input.ForEachGeometryElementInput(\n    geometry=None,\n    selection=True,\n    extend=None,\n    **kwargs,\n)\nFor Each Geometry Element Input node\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_geometry\nInput socket: Geometry\n\n\ni_input_socket\nInput socket:\n\n\ni_selection\nInput socket: Selection\n\n\no_index\nOutput socket: Index\n\n\no_input_socket\nOutput socket:\n\n\n\n\n\n\n\nnodes.input.ID(**kwargs)\nRetrieve a stable random identifier value from the “id” attribute on the point domain, or the index if the attribute does not exist\n\n\n\n\n\nName\nDescription\n\n\n\n\no_id\nOutput socket: ID\n\n\n\n\n\n\n\nnodes.input.Image(**kwargs)\nInput an image data-block\n\n\n\n\n\nName\nDescription\n\n\n\n\no_image\nOutput socket: Image\n\n\n\n\n\n\n\nnodes.input.Index(**kwargs)\nRetrieve an integer value indicating the position of each element in the list, starting at zero\n\n\n\n\n\nName\nDescription\n\n\n\n\no_index\nOutput socket: Index\n\n\n\n\n\n\n\nnodes.input.InstanceBounds(use_radius=True, **kwargs)\nCalculate position bounds of each instance’s geometry set\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_use_radius\nInput socket: Use Radius\n\n\no_max\nOutput socket: Max\n\n\no_min\nOutput socket: Min\n\n\n\n\n\n\n\nnodes.input.InstanceRotation(**kwargs)\nRetrieve the rotation of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.input.InstanceScale(**kwargs)\nRetrieve the scale of each instance in the geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_scale\nOutput socket: Scale\n\n\n\n\n\n\n\nnodes.input.Integer(integer=1, **kwargs)\nProvide an integer value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_integer\nOutput socket: Integer\n\n\n\n\n\n\n\nnodes.input.IsEdgeSmooth(**kwargs)\nRetrieve whether each edge is marked for smooth or split normals\n\n\n\n\n\nName\nDescription\n\n\n\n\no_smooth\nOutput socket: Smooth\n\n\n\n\n\n\n\nnodes.input.IsFaceSmooth(**kwargs)\nRetrieve whether each face is marked for smooth or sharp normals\n\n\n\n\n\nName\nDescription\n\n\n\n\no_smooth\nOutput socket: Smooth\n\n\n\n\n\n\n\nnodes.input.IsSplineCyclic(**kwargs)\nRetrieve whether each spline endpoint connects to the beginning\n\n\n\n\n\nName\nDescription\n\n\n\n\no_cyclic\nOutput socket: Cyclic\n\n\n\n\n\n\n\nnodes.input.Material(**kwargs)\nOutput a single material\n\n\n\n\n\nName\nDescription\n\n\n\n\no_material\nOutput socket: Material\n\n\n\n\n\n\n\nnodes.input.MaterialIndex(**kwargs)\nRetrieve the index of the material used for each element in the geometry’s list of materials\n\n\n\n\n\nName\nDescription\n\n\n\n\no_material_index\nOutput socket: Material Index\n\n\n\n\n\n\n\nnodes.input.NamedLayerSelection(name='', **kwargs)\nOutput a selection of a Grease Pencil layer\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_name\nInput socket: Name\n\n\no_selection\nOutput socket: Selection\n\n\n\n\n\n\n\nnodes.input.Normal(legacy_corner_normals=False, **kwargs)\nRetrieve a unit length vector indicating the direction pointing away from the geometry at each element\n\n\n\n\n\nName\nDescription\n\n\n\n\no_normal\nOutput socket: Normal\n\n\no_true_normal\nOutput socket: True Normal\n\n\n\n\n\n\n\nnodes.input.Object(**kwargs)\nOutput a single object\n\n\n\n\n\nName\nDescription\n\n\n\n\no_object\nOutput socket: Object\n\n\n\n\n\n\n\nnodes.input.Position(**kwargs)\nRetrieve a vector indicating the location of each element\n\n\n\n\n\nName\nDescription\n\n\n\n\no_position\nOutput socket: Position\n\n\n\n\n\n\n\nnodes.input.Radius(**kwargs)\nRetrieve the radius at each point on curve or point cloud geometry\n\n\n\n\n\nName\nDescription\n\n\n\n\no_radius\nOutput socket: Radius\n\n\n\n\n\n\n\nnodes.input.Rotation(rotation_euler=0.0, **kwargs)\nProvide a rotation value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_rotation\nOutput socket: Rotation\n\n\n\n\n\n\n\nnodes.input.SceneTime(**kwargs)\nRetrieve the current time in the scene’s animation in units of seconds or frames\n\n\n\n\n\nName\nDescription\n\n\n\n\no_frame\nOutput socket: Frame\n\n\no_seconds\nOutput socket: Seconds\n\n\n\n\n\n\n\nnodes.input.ShortestEdgePaths(end_vertex=False, edge_cost=1.0, **kwargs)\nFind the shortest paths along mesh edges to selected end vertices, with customizable cost per edge\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_cost\nInput socket: Edge Cost\n\n\ni_end_vertex\nInput socket: End Vertex\n\n\no_next_vertex_index\nOutput socket: Next Vertex Index\n\n\no_total_cost\nOutput socket: Total Cost\n\n\n\n\n\n\n\nnodes.input.SpecialCharacters(**kwargs)\nOutput string characters that cannot be typed directly with the keyboard\n\n\n\n\n\nName\nDescription\n\n\n\n\no_line_break\nOutput socket: Line Break\n\n\no_tab\nOutput socket: Tab\n\n\n\n\n\n\n\nnodes.input.SplineResolution(**kwargs)\nRetrieve the number of evaluated points that will be generated for every control point on curves\n\n\n\n\n\nName\nDescription\n\n\n\n\no_resolution\nOutput socket: Resolution\n\n\n\n\n\n\n\nnodes.input.String(string='', **kwargs)\nProvide a string value that can be connected to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_string\nOutput socket: String\n\n\n\n\n\n\n\nnodes.input.Value(**kwargs)\nInput numerical values to other nodes in the tree\n\n\n\n\n\nName\nDescription\n\n\n\n\no_value\nOutput socket: Value\n\n\n\n\n\n\n\nnodes.input.VoxelIndex(**kwargs)\nRetrieve the integer coordinates of the voxel that the field is evaluated on\n\n\n\n\n\nName\nDescription\n\n\n\n\no_extent_x\nOutput socket: Extent X\n\n\no_extent_y\nOutput socket: Extent Y\n\n\no_extent_z\nOutput socket: Extent Z\n\n\no_is_tile\nOutput socket: Is Tile\n\n\no_x\nOutput socket: X\n\n\no_y\nOutput socket: Y\n\n\no_z\nOutput socket: Z",
    "crumbs": [
      "Some functions",
      "nodes.input"
    ]
  },
  {
    "objectID": "reference/nodes.mesh.html",
    "href": "reference/nodes.mesh.html",
    "title": "nodes.mesh",
    "section": "",
    "text": "nodes.mesh\nAuto-generated Blender Geometry Node classes.\nDO NOT EDIT THIS FILE MANUALLY. This file is generated by molecularnodes/nodes/generator.py\nTo regenerate: Run generator.py from within Blender\nKNOWN LIMITATIONS: - Dynamic multi-input/output sockets are not yet supported (these are the unnamed sockets that appear in the UI for nodes like “Evaluate Closure”, “Join Geometry”, etc. that allow dragging in multiple connections) - TODO: Add support for dynamic socket creation\n\n\n\n\n\nName\nDescription\n\n\n\n\nCone\nGenerate a cone mesh\n\n\nCube\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\nCurveToMesh\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\nCylinder\nGenerate a cylinder mesh\n\n\nDualMesh\nConvert Faces into vertices and vertices into faces\n\n\nEdgeAngle\nThe angle between the normals of connected manifold faces\n\n\nEdgeNeighbors\nRetrieve the number of faces that use each edge as one of their sides\n\n\nEdgeVertices\nRetrieve topology information relating to each edge of a mesh\n\n\nExtrudeMesh\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\nFaceArea\nCalculate the surface area of a mesh’s faces\n\n\nFaceGroupBoundaries\nFind edges on the boundaries between groups of faces with the same ID value\n\n\nFaceNeighbors\nRetrieve topology information relating to each face of a mesh\n\n\nGrid\nGenerate a planar mesh on the XY plane\n\n\nGridToMesh\nGenerate a mesh on the “surface” of a volume grid\n\n\nIcoSphere\nGenerate a spherical mesh that consists of equally sized triangles\n\n\nIsFacePlanar\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\nMeshBoolean\nCut, subtract, or join multiple mesh inputs\n\n\nMeshCircle\nGenerate a circular ring of edges\n\n\nMeshIsland\nRetrieve information about separate connected regions in a mesh\n\n\nMeshLine\nGenerate vertices in a line and connect them with edges\n\n\nMeshToCurve\nGenerate a curve from a mesh\n\n\nMeshToDensityGrid\nCreate a filled volume grid from a mesh\n\n\nMeshToPoints\nGenerate a point cloud from a mesh’s vertices\n\n\nMeshToSDFGrid\nCreate a signed distance volume grid from a mesh\n\n\nMeshToVolume\nCreate a fog volume with the shape of the input mesh’s surface\n\n\nSetMeshNormal\nStore a normal vector for each mesh element\n\n\nSubdivideMesh\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\nUVSphere\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\nVertexNeighbors\nRetrieve topology information relating to each vertex of a mesh\n\n\nVolumeToMesh\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nnodes.mesh.Cone(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius_top=0.0,\n    radius_bottom=1.0,\n    depth=2.0,\n    fill_type='NGON',\n    **kwargs,\n)\nGenerate a cone mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius_bottom\nInput socket: Radius Bottom\n\n\ni_radius_top\nInput socket: Radius Top\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.Cube(\n    size=[1.0, 1.0, 1.0],\n    vertices_x=2,\n    vertices_y=2,\n    vertices_z=2,\n    **kwargs,\n)\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size\nInput socket: Size\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\ni_vertices_z\nInput socket: Vertices Z\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.CurveToMesh(\n    curve=None,\n    profile_curve=None,\n    scale=1.0,\n    fill_caps=False,\n    **kwargs,\n)\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_fill_caps\nInput socket: Fill Caps\n\n\ni_profile_curve\nInput socket: Profile Curve\n\n\ni_scale\nInput socket: Scale\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.Cylinder(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius=1.0,\n    depth=2.0,\n    fill_type='NGON',\n    **kwargs,\n)\nGenerate a cylinder mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius\nInput socket: Radius\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.DualMesh(mesh=None, keep_boundaries=False, **kwargs)\nConvert Faces into vertices and vertices into faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_keep_boundaries\nInput socket: Keep Boundaries\n\n\ni_mesh\nInput socket: Mesh\n\n\no_dual_mesh\nOutput socket: Dual Mesh\n\n\n\n\n\n\n\nnodes.mesh.EdgeAngle(**kwargs)\nThe angle between the normals of connected manifold faces\n\n\n\n\n\nName\nDescription\n\n\n\n\no_signed_angle\nOutput socket: Signed Angle\n\n\no_unsigned_angle\nOutput socket: Unsigned Angle\n\n\n\n\n\n\n\nnodes.mesh.EdgeNeighbors(**kwargs)\nRetrieve the number of faces that use each edge as one of their sides\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\n\n\n\n\n\nnodes.mesh.EdgeVertices(**kwargs)\nRetrieve topology information relating to each edge of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_position_1\nOutput socket: Position 1\n\n\no_position_2\nOutput socket: Position 2\n\n\no_vertex_index_1\nOutput socket: Vertex Index 1\n\n\no_vertex_index_2\nOutput socket: Vertex Index 2\n\n\n\n\n\n\n\nnodes.mesh.ExtrudeMesh(\n    mesh=None,\n    selection=True,\n    offset=[0.0, 0.0, 0.0],\n    offset_scale=1.0,\n    individual=True,\n    mode='FACES',\n    **kwargs,\n)\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_individual\nInput socket: Individual\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_offset\nInput socket: Offset\n\n\ni_offset_scale\nInput socket: Offset Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\n\n\n\n\n\nnodes.mesh.FaceArea(**kwargs)\nCalculate the surface area of a mesh’s faces\n\n\n\n\n\nName\nDescription\n\n\n\n\no_area\nOutput socket: Area\n\n\n\n\n\n\n\nnodes.mesh.FaceGroupBoundaries(face_set=0, **kwargs)\nFind edges on the boundaries between groups of faces with the same ID value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_group_id\nInput socket: Face Group ID\n\n\no_boundary_edges\nOutput socket: Boundary Edges\n\n\n\n\n\n\n\nnodes.mesh.FaceNeighbors(**kwargs)\nRetrieve topology information relating to each face of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\n\n\n\n\n\nnodes.mesh.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3, **kwargs)\nGenerate a planar mesh on the XY plane\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size_x\nInput socket: Size X\n\n\ni_size_y\nInput socket: Size Y\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.GridToMesh(\n    grid=0.0,\n    threshold=0.10000000149011612,\n    adaptivity=0.0,\n    **kwargs,\n)\nGenerate a mesh on the “surface” of a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_grid\nInput socket: Grid\n\n\ni_threshold\nInput socket: Threshold\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.IcoSphere(radius=1.0, subdivisions=1, **kwargs)\nGenerate a spherical mesh that consists of equally sized triangles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_subdivisions\nInput socket: Subdivisions\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.IsFacePlanar(threshold=0.009999999776482582, **kwargs)\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_threshold\nInput socket: Threshold\n\n\no_planar\nOutput socket: Planar\n\n\n\n\n\n\n\nnodes.mesh.MeshBoolean(\n    mesh_1=None,\n    mesh_2=None,\n    operation='DIFFERENCE',\n    solver='FLOAT',\n    **kwargs,\n)\nCut, subtract, or join multiple mesh inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh_1\nInput socket: Mesh 1\n\n\ni_mesh_2\nInput socket: Mesh 2\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate Mesh Boolean with operation ‘Difference’.\n\n\nintersect\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\nunion\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.mesh.MeshBoolean.difference(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Difference’.\n\n\n\nnodes.mesh.MeshBoolean.intersect(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\n\nnodes.mesh.MeshBoolean.union(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.mesh.MeshCircle(vertices=32, radius=1.0, fill_type='NONE', **kwargs)\nGenerate a circular ring of edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_vertices\nInput socket: Vertices\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.MeshIsland(**kwargs)\nRetrieve information about separate connected regions in a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_island_count\nOutput socket: Island Count\n\n\no_island_index\nOutput socket: Island Index\n\n\n\n\n\n\n\nnodes.mesh.MeshLine(\n    count=10,\n    start_location=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 1.0],\n    mode='OFFSET',\n    count_mode='TOTAL',\n    **kwargs,\n)\nGenerate vertices in a line and connect them with edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_offset\nInput socket: Offset\n\n\ni_start_location\nInput socket: Start Location\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.MeshToCurve(mesh=None, selection=True, mode='EDGES', **kwargs)\nGenerate a curve from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.mesh.MeshToDensityGrid(\n    mesh=None,\n    density=1.0,\n    voxel_size=0.30000001192092896,\n    gradient_width=0.20000000298023224,\n    **kwargs,\n)\nCreate a filled volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_gradient_width\nInput socket: Gradient Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_density_grid\nOutput socket: Density Grid\n\n\n\n\n\n\n\nnodes.mesh.MeshToPoints(\n    mesh=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    mode='VERTICES',\n    **kwargs,\n)\nGenerate a point cloud from a mesh’s vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.mesh.MeshToSDFGrid(\n    mesh=None,\n    voxel_size=0.30000001192092896,\n    band_width=3,\n    **kwargs,\n)\nCreate a signed distance volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_band_width\nInput socket: Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.mesh.MeshToVolume(\n    mesh=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    interior_band_width=0.20000000298023224,\n    **kwargs,\n)\nCreate a fog volume with the shape of the input mesh’s surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_interior_band_width\nInput socket: Interior Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.mesh.SetMeshNormal(\n    mesh=None,\n    remove_custom=True,\n    edge_sharpness=False,\n    face_sharpness=False,\n    mode='SHARPNESS',\n    domain='POINT',\n    **kwargs,\n)\nStore a normal vector for each mesh element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_sharpness\nInput socket: Edge Sharpness\n\n\ni_face_sharpness\nInput socket: Face Sharpness\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_remove_custom\nInput socket: Remove Custom\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.SubdivideMesh(mesh=None, level=1, **kwargs)\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_level\nInput socket: Level\n\n\ni_mesh\nInput socket: Mesh\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.UVSphere(segments=32, rings=16, radius=1.0, **kwargs)\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_rings\nInput socket: Rings\n\n\ni_segments\nInput socket: Segments\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.VertexNeighbors(**kwargs)\nRetrieve topology information relating to each vertex of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\n\n\n\n\n\nnodes.mesh.VolumeToMesh(\n    volume=None,\n    resolution_mode='Grid',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    threshold=0.10000000149011612,\n    adaptivity=0.0,\n    **kwargs,\n)\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_mesh\nOutput socket: Mesh",
    "crumbs": [
      "Some functions",
      "nodes.mesh"
    ]
  },
  {
    "objectID": "reference/nodes.mesh.html#classes",
    "href": "reference/nodes.mesh.html#classes",
    "title": "nodes.mesh",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCone\nGenerate a cone mesh\n\n\nCube\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\nCurveToMesh\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\nCylinder\nGenerate a cylinder mesh\n\n\nDualMesh\nConvert Faces into vertices and vertices into faces\n\n\nEdgeAngle\nThe angle between the normals of connected manifold faces\n\n\nEdgeNeighbors\nRetrieve the number of faces that use each edge as one of their sides\n\n\nEdgeVertices\nRetrieve topology information relating to each edge of a mesh\n\n\nExtrudeMesh\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\nFaceArea\nCalculate the surface area of a mesh’s faces\n\n\nFaceGroupBoundaries\nFind edges on the boundaries between groups of faces with the same ID value\n\n\nFaceNeighbors\nRetrieve topology information relating to each face of a mesh\n\n\nGrid\nGenerate a planar mesh on the XY plane\n\n\nGridToMesh\nGenerate a mesh on the “surface” of a volume grid\n\n\nIcoSphere\nGenerate a spherical mesh that consists of equally sized triangles\n\n\nIsFacePlanar\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\nMeshBoolean\nCut, subtract, or join multiple mesh inputs\n\n\nMeshCircle\nGenerate a circular ring of edges\n\n\nMeshIsland\nRetrieve information about separate connected regions in a mesh\n\n\nMeshLine\nGenerate vertices in a line and connect them with edges\n\n\nMeshToCurve\nGenerate a curve from a mesh\n\n\nMeshToDensityGrid\nCreate a filled volume grid from a mesh\n\n\nMeshToPoints\nGenerate a point cloud from a mesh’s vertices\n\n\nMeshToSDFGrid\nCreate a signed distance volume grid from a mesh\n\n\nMeshToVolume\nCreate a fog volume with the shape of the input mesh’s surface\n\n\nSetMeshNormal\nStore a normal vector for each mesh element\n\n\nSubdivideMesh\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\nUVSphere\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\nVertexNeighbors\nRetrieve topology information relating to each vertex of a mesh\n\n\nVolumeToMesh\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nnodes.mesh.Cone(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius_top=0.0,\n    radius_bottom=1.0,\n    depth=2.0,\n    fill_type='NGON',\n    **kwargs,\n)\nGenerate a cone mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius_bottom\nInput socket: Radius Bottom\n\n\ni_radius_top\nInput socket: Radius Top\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.Cube(\n    size=[1.0, 1.0, 1.0],\n    vertices_x=2,\n    vertices_y=2,\n    vertices_z=2,\n    **kwargs,\n)\nGenerate a cuboid mesh with variable side lengths and subdivisions\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size\nInput socket: Size\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\ni_vertices_z\nInput socket: Vertices Z\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.CurveToMesh(\n    curve=None,\n    profile_curve=None,\n    scale=1.0,\n    fill_caps=False,\n    **kwargs,\n)\nConvert curves into a mesh, optionally with a custom profile shape defined by curves\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_curve\nInput socket: Curve\n\n\ni_fill_caps\nInput socket: Fill Caps\n\n\ni_profile_curve\nInput socket: Profile Curve\n\n\ni_scale\nInput socket: Scale\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.Cylinder(\n    vertices=32,\n    side_segments=1,\n    fill_segments=1,\n    radius=1.0,\n    depth=2.0,\n    fill_type='NGON',\n    **kwargs,\n)\nGenerate a cylinder mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_depth\nInput socket: Depth\n\n\ni_fill_segments\nInput socket: Fill Segments\n\n\ni_radius\nInput socket: Radius\n\n\ni_side_segments\nInput socket: Side Segments\n\n\ni_vertices\nInput socket: Vertices\n\n\no_bottom\nOutput socket: Bottom\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.DualMesh(mesh=None, keep_boundaries=False, **kwargs)\nConvert Faces into vertices and vertices into faces\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_keep_boundaries\nInput socket: Keep Boundaries\n\n\ni_mesh\nInput socket: Mesh\n\n\no_dual_mesh\nOutput socket: Dual Mesh\n\n\n\n\n\n\n\nnodes.mesh.EdgeAngle(**kwargs)\nThe angle between the normals of connected manifold faces\n\n\n\n\n\nName\nDescription\n\n\n\n\no_signed_angle\nOutput socket: Signed Angle\n\n\no_unsigned_angle\nOutput socket: Unsigned Angle\n\n\n\n\n\n\n\nnodes.mesh.EdgeNeighbors(**kwargs)\nRetrieve the number of faces that use each edge as one of their sides\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\n\n\n\n\n\nnodes.mesh.EdgeVertices(**kwargs)\nRetrieve topology information relating to each edge of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_position_1\nOutput socket: Position 1\n\n\no_position_2\nOutput socket: Position 2\n\n\no_vertex_index_1\nOutput socket: Vertex Index 1\n\n\no_vertex_index_2\nOutput socket: Vertex Index 2\n\n\n\n\n\n\n\nnodes.mesh.ExtrudeMesh(\n    mesh=None,\n    selection=True,\n    offset=[0.0, 0.0, 0.0],\n    offset_scale=1.0,\n    individual=True,\n    mode='FACES',\n    **kwargs,\n)\nGenerate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_individual\nInput socket: Individual\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_offset\nInput socket: Offset\n\n\ni_offset_scale\nInput socket: Offset Scale\n\n\ni_selection\nInput socket: Selection\n\n\no_mesh\nOutput socket: Mesh\n\n\no_side\nOutput socket: Side\n\n\no_top\nOutput socket: Top\n\n\n\n\n\n\n\nnodes.mesh.FaceArea(**kwargs)\nCalculate the surface area of a mesh’s faces\n\n\n\n\n\nName\nDescription\n\n\n\n\no_area\nOutput socket: Area\n\n\n\n\n\n\n\nnodes.mesh.FaceGroupBoundaries(face_set=0, **kwargs)\nFind edges on the boundaries between groups of faces with the same ID value\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_face_group_id\nInput socket: Face Group ID\n\n\no_boundary_edges\nOutput socket: Boundary Edges\n\n\n\n\n\n\n\nnodes.mesh.FaceNeighbors(**kwargs)\nRetrieve topology information relating to each face of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\n\n\n\n\n\nnodes.mesh.Grid(size_x=1.0, size_y=1.0, vertices_x=3, vertices_y=3, **kwargs)\nGenerate a planar mesh on the XY plane\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_size_x\nInput socket: Size X\n\n\ni_size_y\nInput socket: Size Y\n\n\ni_vertices_x\nInput socket: Vertices X\n\n\ni_vertices_y\nInput socket: Vertices Y\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.GridToMesh(\n    grid=0.0,\n    threshold=0.10000000149011612,\n    adaptivity=0.0,\n    **kwargs,\n)\nGenerate a mesh on the “surface” of a volume grid\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_grid\nInput socket: Grid\n\n\ni_threshold\nInput socket: Threshold\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.IcoSphere(radius=1.0, subdivisions=1, **kwargs)\nGenerate a spherical mesh that consists of equally sized triangles\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_subdivisions\nInput socket: Subdivisions\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.IsFacePlanar(threshold=0.009999999776482582, **kwargs)\nRetrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_threshold\nInput socket: Threshold\n\n\no_planar\nOutput socket: Planar\n\n\n\n\n\n\n\nnodes.mesh.MeshBoolean(\n    mesh_1=None,\n    mesh_2=None,\n    operation='DIFFERENCE',\n    solver='FLOAT',\n    **kwargs,\n)\nCut, subtract, or join multiple mesh inputs\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh_1\nInput socket: Mesh 1\n\n\ni_mesh_2\nInput socket: Mesh 2\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndifference\nCreate Mesh Boolean with operation ‘Difference’.\n\n\nintersect\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\nunion\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.mesh.MeshBoolean.difference(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Difference’.\n\n\n\nnodes.mesh.MeshBoolean.intersect(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Intersect’.\n\n\n\nnodes.mesh.MeshBoolean.union(mesh_1=None, mesh_2=None)\nCreate Mesh Boolean with operation ‘Union’.\n\n\n\n\n\nnodes.mesh.MeshCircle(vertices=32, radius=1.0, fill_type='NONE', **kwargs)\nGenerate a circular ring of edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_vertices\nInput socket: Vertices\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.MeshIsland(**kwargs)\nRetrieve information about separate connected regions in a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_island_count\nOutput socket: Island Count\n\n\no_island_index\nOutput socket: Island Index\n\n\n\n\n\n\n\nnodes.mesh.MeshLine(\n    count=10,\n    start_location=[0.0, 0.0, 0.0],\n    offset=[0.0, 0.0, 1.0],\n    mode='OFFSET',\n    count_mode='TOTAL',\n    **kwargs,\n)\nGenerate vertices in a line and connect them with edges\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_count\nInput socket: Count\n\n\ni_offset\nInput socket: Offset\n\n\ni_start_location\nInput socket: Start Location\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.MeshToCurve(mesh=None, selection=True, mode='EDGES', **kwargs)\nGenerate a curve from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_selection\nInput socket: Selection\n\n\no_curve\nOutput socket: Curve\n\n\n\n\n\n\n\nnodes.mesh.MeshToDensityGrid(\n    mesh=None,\n    density=1.0,\n    voxel_size=0.30000001192092896,\n    gradient_width=0.20000000298023224,\n    **kwargs,\n)\nCreate a filled volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_gradient_width\nInput socket: Gradient Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_density_grid\nOutput socket: Density Grid\n\n\n\n\n\n\n\nnodes.mesh.MeshToPoints(\n    mesh=None,\n    selection=True,\n    position=[0.0, 0.0, 0.0],\n    radius=0.05000000074505806,\n    mode='VERTICES',\n    **kwargs,\n)\nGenerate a point cloud from a mesh’s vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_position\nInput socket: Position\n\n\ni_radius\nInput socket: Radius\n\n\ni_selection\nInput socket: Selection\n\n\no_points\nOutput socket: Points\n\n\n\n\n\n\n\nnodes.mesh.MeshToSDFGrid(\n    mesh=None,\n    voxel_size=0.30000001192092896,\n    band_width=3,\n    **kwargs,\n)\nCreate a signed distance volume grid from a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_band_width\nInput socket: Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_sdf_grid\nOutput socket: SDF Grid\n\n\n\n\n\n\n\nnodes.mesh.MeshToVolume(\n    mesh=None,\n    density=1.0,\n    resolution_mode='Amount',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    interior_band_width=0.20000000298023224,\n    **kwargs,\n)\nCreate a fog volume with the shape of the input mesh’s surface\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_density\nInput socket: Density\n\n\ni_interior_band_width\nInput socket: Interior Band Width\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_volume\nOutput socket: Volume\n\n\n\n\n\n\n\nnodes.mesh.SetMeshNormal(\n    mesh=None,\n    remove_custom=True,\n    edge_sharpness=False,\n    face_sharpness=False,\n    mode='SHARPNESS',\n    domain='POINT',\n    **kwargs,\n)\nStore a normal vector for each mesh element\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_edge_sharpness\nInput socket: Edge Sharpness\n\n\ni_face_sharpness\nInput socket: Face Sharpness\n\n\ni_mesh\nInput socket: Mesh\n\n\ni_remove_custom\nInput socket: Remove Custom\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.SubdivideMesh(mesh=None, level=1, **kwargs)\nDivide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_level\nInput socket: Level\n\n\ni_mesh\nInput socket: Mesh\n\n\no_mesh\nOutput socket: Mesh\n\n\n\n\n\n\n\nnodes.mesh.UVSphere(segments=32, rings=16, radius=1.0, **kwargs)\nGenerate a spherical mesh with quads, except for triangles at the top and bottom\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_radius\nInput socket: Radius\n\n\ni_rings\nInput socket: Rings\n\n\ni_segments\nInput socket: Segments\n\n\no_mesh\nOutput socket: Mesh\n\n\no_uv_map\nOutput socket: UV Map\n\n\n\n\n\n\n\nnodes.mesh.VertexNeighbors(**kwargs)\nRetrieve topology information relating to each vertex of a mesh\n\n\n\n\n\nName\nDescription\n\n\n\n\no_face_count\nOutput socket: Face Count\n\n\no_vertex_count\nOutput socket: Vertex Count\n\n\n\n\n\n\n\nnodes.mesh.VolumeToMesh(\n    volume=None,\n    resolution_mode='Grid',\n    voxel_size=0.30000001192092896,\n    voxel_amount=64.0,\n    threshold=0.10000000149011612,\n    adaptivity=0.0,\n    **kwargs,\n)\nGenerate a mesh on the “surface” of a volume\n\n\n\n\n\nName\nDescription\n\n\n\n\ni_adaptivity\nInput socket: Adaptivity\n\n\ni_resolution_mode\nInput socket: Resolution Mode\n\n\ni_threshold\nInput socket: Threshold\n\n\ni_volume\nInput socket: Volume\n\n\ni_voxel_amount\nInput socket: Voxel Amount\n\n\ni_voxel_size\nInput socket: Voxel Size\n\n\no_mesh\nOutput socket: Mesh",
    "crumbs": [
      "Some functions",
      "nodes.mesh"
    ]
  }
]